# Manipulation de données vectorielles {#manip_vec}


L'objectif principal de ce module est d'apprendre à manipuler des données vectorielles. 

À la fin de ce module vous saurez:

- Comment ajouter de nouveaux attributs et également comment supprimer ou éditer ces attributs.
- Comment filtrer des données vectorielles en se basant sur leur attributs (ex. isoler les villes possédants le plus de populations).
- Comment joindre spatialement deux vecteurs.
- Comment extraire les données d'un vecteur spatial pour l'intégrer aux attributs d'une seconde couche.

Vous utiliserez les librairies suivantes:

- `sf`

Vous apprendrez à utiliser les fonctions suivantes:

- TODO

Dans la section Leçon, vous utiliserez les données portant sur les municipalités du Québec,

Dans la section Exercice, vous utiliserez XXXXX

```{r load-libraries7, echo = FALSE, results='hide', warning = FALSE, message = FALSE}
#library(raster)
library(rgdal)
library(ggplot2)
library(dplyr)
library(sf)
library(svglite) ## J'ai pas besoin de ça pour créer les figures, mais pour les inclure dans le markdown, oui.
library(ggpubr)
library(mapview)
```


## Leçon

Dans le cadre de cette leçon, nous allons préparer notre saison estivale de vacances en explorant les données vectorielles relatives aux municipalités du Québec (POINTS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives)), au réseau de la SÉPAQ (POLYGONS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000)) et enfin aux sentiers de randonnées de la SÉPAQ (LINESTRINGS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/sentiers-estivaux)).

Afin de faciliter l'importation de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargez en cliquant sur un seul lien: [données sur les parcs et les villes du Québec](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Quebec_Parcs.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Donnees` pour ce module, et dézippez-le. Le dossier `Quebec_Parcs` comprend trois sous-dossiers:

- `villes`
- `parcs`
- `sentiers`

### Opérations de base {-}

Afin de se familiariser avec la manipulation de données vectorielles, nous allons exporer le territoire Québécois en se posant la question suivante: 

> Parmis les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 250km)? 

Pour répondre à cette question, il faut réaliser un ensemble d'opérations spatiales:

- Obtenir et importer dans R le fichier spatial comprenant l'ensemble des villes/municipalités du Québec.
- Obtenir la taille de population pour chacune de ces municipalités.
- Filtrer ces municipalités pour isoler les 10 municipalités ayant la taille de population la plus importante.
- Importer le fichier spatial du réseau récréatif du Québec.
- Filter les aires récréatives pour obtenir seulement les parcs nationaux.
- Tracer un polygon en forme de cercle (une zone tampon) avec 250 kms de rayon autours des dix plus grandes villes.
- Pour chacun des polygons, compter le nombre de parcs présent dans la zone tampon de 250 kms.

Dans ce chapitre, nous allons passer à travers chacune de ces étapes.

#### Importation des données {-}

La première étape consiste à lire le fichier *shapefile* de l'ensemble des villes du Québec (tel que vu dans le [chapitre 2](#lire-shp)) afin d'isoler les dix plus grandes villes du Québec.

```{r, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module7/Donnees/"
chemin_villes <- paste(chemin, "/villes/villes.shp", sep = "")
villes <- st_read(chemin_villes)
```

```{r, eval = TRUE, echo = FALSE}
villes <- st_read("Module7/data/villes/villes.shp")
```

Le *Shapefile* a maintenant été importé dans un objet R de classe `sf` avec 
On peut maintenant visuellement valider que l'importation a bien été réussi:

```{r}
mapview(villes, legend = FALSE)
```

En cliquant sur chacun des marqueurs géograĥiques (dans la carte interactive), vous pouvez accéder à la table d'attributs. 
Pour en savoir davantage sur les attributs, voici le lien vers la [la documentation](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives/resource/beb4472a-0edb-4824-b67e-40e20b425326).  Cette table d'attribut contient une diversité d'informations plus ou moins importante pour répondre à notre question. On veut donc nettoyer la table d'attribut en sélectionnant la ou les colonnes pertinentes pour notre besoin. 

#### Sélectionner des attributs (colonnes) ou des localisations (lignes) spécifiques {-}

L'objet spatial `villes` contient `r nrow(villes)` points correspondant chacun à une ville. La table d'attributs contient quant à elle `r ncol(villes)` colonnes / attributs décrivant les villes. L'attribut qui nous intéresse ici est la colonne `HAP_NM_TOP` contenant le nom de la ville. L'abbréviation `TOP` signifie [toponymie](https://fr.wikipedia.org/wiki/Toponymie) qui sert à référencer les noms propres désignant un lieu. On veut donc extraire la colonne `HAP_NM_TOP` contenant le nom des villes du Québec. 

Les objets `sf` sont manipulable de la même facon qu'un `data.frame` (étant eux-même des `data.frame`). Pour accéder à une colonne ou à une ligne spécifique dans la table d'attributs, il faut utiliser la syntaxe suivante:

```{r}
villes[1,] # Pour accéder à la première ligne. 
```

Vous pouvez remarquer que le nombre de *features* (points) à diminuer à 1. Maintenant, regardons comment séléctionner une seule colonne:

```{r}
villes[,2] # Pour accéder à la deuxième colonne. 
```

Vous pouvez remarquer que le nombre de *fields* (colonnes) à diminuer à 1. 

Les colonnes disposent toujours d'un nom unique dans un `data.frame`. On peut afficher les noms de colonnes et extraire une colonne spécifique par son nom de la manière suivante:

```{r}
names(villes)
villes[,"HAP_NM_TOP"]
# Ce qui revient également au même que la syntaxe suivante 
villes[,13] 
# Puisque cette colonne est en treizième position.
```

On souhaite à présent sélectionner le nom de la ville/municipalité car les autres attributs ne sont pas pertinent pour répondre à notre question.

```{r}
villes <- villes[,"HAP_NM_TOP"]
villes
```

On veut maintenant renommer la colonne afin d'avoir un intitulé de colonne plus explicite. 

```{r}
names(villes)
names(villes) <- c("toponyme", "geometry")
```

Si l'on veut vérifier qu'une ville se retrouve bel et bien présente dans le jeu de données, on peut utiliser la fonction `subset()` afin de filtrer les points basé sur la valeur d'un attribut:

```{r}
la_poc <- subset(villes, toponyme == "La Pocatière")
mapview(la_poc, legend = FALSE)
```

#### Joindre l'information d'une autre couche spatiale: `st_join()` {-}

On vérifiant visuellement la position des villes, on peut s'apercevoir que certaines villes se retrouvent à l'extérieur des limites administratives du Québec. 

```{r}
mapview(villes, legend = FALSE)
```

On veut filtrer ces villes pour obtenir seulement celles présentes au Québec (puisque notre question porte seulement sur le Québec). Pour accomplir cette étape, on va croiser deux sources d'informations spatiales: les villes et les limites administratives des provinces. Pour chacune des villes, on veut connaitre la province d'attache. Ce type d'opération s'appelle une jointure spatiale.

La première étape de cette jointure consiste à importer le fichier des limites administratives des provinces ([source](https://gadm.org/)). 

```{r, eval = FALSE}
chemin_provinces <- paste(chemin, "/provinces_CA/provinces_CA.shp", sep = "")
provinces <- st_read(chemin_provinces)
```

```{r, include = FALSE}
provinces <- st_read("Module7/data/provinces_CA/provinces_CA.shp")
```

On peut maintenant vérifier visuellement l'importation. En examinant la table d'attributs de l'objet `provinces` (en cliquant sur un des polygons de la carte interactive ci-dessous), on remarque que l'attribut `NAME_1` contient le nom des provinces. 

```{r}
mapview(provinces, zcol = "NAME_1")
```

La deuxième étape consiste à vérifier que les deux objets possèdent le même système de projection. Les deux objets doivent se retrouver dans le même système de coordonnées afin que la jointure spatiale puisse être réalisé. En utilisant la fonction `st_crs()`, on peut effectuer un test logique en comparant les deux projections.

```{r}
st_crs(villes) == st_crs(provinces)
```

Le test logique d'égalité (`==`) nous renvoit la réponse `r st_crs(villes) == st_crs(provinces)` qui signifie que les deux objets ne disposent pas du même système de coordonnées. On doit donc reprojeté (`st_transform()`) l'objet `provinces` dans le système de coordonnées de `villes` (voir [chapitre 3](#SRC) pour davantage d'information sur les projections et système de coordonnées).

```{r}
provinces <- st_transform(provinces, st_crs(villes))
```

Enfin, la dernière étape consiste à effectuer la jointure entre les deux couches avec comme objectif d'ajouter une colonne contenant le nom de la province à la table d'attributs de l'objet `villes`. La fonction `st_join()` permet de déterminer dans quelle province (`POLYGON`) se retrouve chacun des villes (`POINT`).

```{r}
villes <- st_join(villes, provinces[,"NAME_1"])
head(villes)
```

Pour chacune des villes, nous avons donc ajouté la province d'attache 
On peut renommer la colonne `NAME_1` (en position 2) par `province` pour être davantage explicit sur son contenu.

```{r}
names(villes)[2] <- "province"
```

On peut maintenant filtrer l'objet `villes` en utilisant se nouvelle attribut.

```{r}
villes_qc <- subset(villes, province == "Québec")
```

On vérifie que le nouveau filtre fonctionne et que nous avons les villes seulement présentes au Québec.

```{r}
mapview(villes_qc) + mapview(subset(provinces, NAME_1 == "Québec"))
```

Nous avons maintenant convenablement isolé les villes du Québec. La prochaine étape consiste à ajouter pour chacune des villes, sa taille de population. 

#### Joindre des sources d'informations externes (CSV) {-}

Nous avons à présent l'emplacement géographiques de l'ensemble des villes du Québec contenu dans un objet `villes` avec un seul attribut `toponyme` (le nom de la ville). Nous voulons maintenant ajouter pour chacune des villes, sa taille de population. Cette information est contenu dans un fichier `csv` (`Donnees/ville/population.csv`) et provient du [répertoire des municipalités du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/repertoire-des-municipalites-du-quebec/resource/19385b4e-5503-4330-9e59-f998f5918363). Nous allons d'abord importer ce fichier CSV, sélectionner les colonnes pertinentes, puis ensuite fusionner ces informations avec l'emplacement des villes (objet `villes` dans l'environnement de R).

```{r, eval = FALSE}
# On importe le fichier dans l'environnement de R
chemin_pop <- paste(chemin, "villes/population.csv", sep = "")
pop <- read.csv(chemin_pop)
```
```{r, eval = TRUE, echo = FALSE}
pop <- read.csv("Module7/data/villes/population.csv")
```

Cet objet `pop` (`data.frame`) contient `r ncol(pop)` colonnes décrivant jusqu'à la composition du conseil municipal. Toutes ces informations ne sont pas pertinentes pour répondre à notre question. On veut sélectionne les colonnes suivantes:

- `munnom`: Nom de la ville. Cette colonne servira à faire la joiture entre l'objet spatial `villes` et le fichier `csv` (`Donnees/ville/population.csv`) contenant les tailles de populations.
- `msuperf`: Superficie de la municipalité
- `mpopul`: Taille de la population résidente de la munipalité

```{r}
pop <- pop[,c("munnom","msuperf","mpopul")]
```

On peut à présent fusionner l'objet `pop` (taille de population) avec l'objet spatial `villes` en utilisant la fonction `merge()`. La jointure entre les deux objets `villes` et `pop` sera réalisé sur les colonnes `toponyme` et `munnom` respectivement. Ces deux colonnes agissent comme dénominateur communs entre les deux jeux de données et contient le nom de la municipalité. L'argument `all.x = TRUE` spécifie que toutes les entrées (POINT) de l'objet `ville` doivent être conservées. 

```{r}
villes <- merge(x = villes, y = pop, by.x="toponyme", by.y="munnom",  all.x = TRUE)
```

On renomme encore une fois les colonnes pour être explicite sur leurs contenus.

```{r}
names(villes)
names(villes)[3:4] <- c("superficie","population")
names(villes) 
```

#### Filtrer sur la table d'attributs {-}

Nous avons à présent assembler les deux pièces d'informations nécessaires pour obtenir une partie de réponse à notre question: 

> Quelles sont les dix plus grandes villes du Québec? 

Nous allons sélectionner les 10 villes présentant la population la plus grande. La première consiste à ordonner l'attribut `population` contenu dans l'objet `villes`.

```{r}
villes <- villes[order(villes$population, decreasing = TRUE),]
```

L'objet `villes` est maintenant ordonné de manière décroissante en fonction de la taille de population des villes. Les 10 premières lignes de cet objet corresponds donc au 10 villes présentant la population la plus importante au Québec. On peut donc assigner les 10 premières lignes à un nouvelle objet initulé `top10_villes`:

```{r}
top10_villes <- villes[1:10,]
top10_villes
```

On peut visualisé avec `mapview` ce nouvel objet.

```{r}
mapview(top10_villes, zcol= "population")
```

La prochaine étape pour répondre à notre question consiste à tracer une zone tampon (POLYGON) de 250 kms de rayon autours des villes (POINT) afin de dénombre le nombre de parcs nationaux se trouvant dans cette zone. 

#### Tracer un POLYGON circulaire (buffer) autour d'un POINT






### Opération sur une couche vectorielle {-}

-	Jointure par identifiant, suppression de données, extraction par attributs, dissolution de polygones.

### Opération sur plusieurs couches vectorielles {-}

-	Combinaison de couches, jointure spatiale, intersection de couches, découpage d’une couche.


## Exercice


