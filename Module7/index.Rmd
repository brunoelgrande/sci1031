# Manipulation de données vectorielles {#manip_vec}

L'objectif principal de ce module est d'apprendre à manipuler des données vectorielles. 

À la fin de ce module vous saurez:

- Ajouter de nouveaux attributs à des données vectorielles, et également supprimer ou éditer des attributs.
- Filtrer des données vectorielles en se basant sur leurs attributs.
- Joindre spatialement deux ensembles de données vectorielles.
- Extraire un sous-ensemble de données pour l'intégrer aux attributs d'un second ensemble de données spatiales. 

Vous utiliserez les bibliothèques suivantes:

- `sf`,
- `mapview`,
- `units`

Vous apprendrez à utiliser les fonctions suivantes:

- `subset()`
- `st_coordinates()`
- `class()`
- `merge()`
- `st_join()`
- `st_simplify()`
- `st_area()`
- `set_units()`
- `st_buffer()`
- `st_intercepts()`
- `rowSums()`
- `lengths()`

Dans la section [leçon](#lecon_manip_vec), vous utiliserez des données vectorielles portant sur les municipalités du Québec, sur les régions administratives du Québec et sur les parcs nationaux de la Société des établissements de plein air du Québec.

Dans la section Exercice, vous utiliserez <!-- A FAIRE -->


## Leçon {#lecon_manip_vec}


Au [module 4](#vec), vous avez appris les fonctions essentielles pour lire et visualiser des données spatiales vectorielles sous `R`. Le présent module vous amènera maintenant à manipuler des données vectorielles. 

Dans un premier temps, cette leçon vous enseignera le fonctionnement d'opérations de base sur les données vectorielles. 
<!-- Spatiale pas spatiale -->

Dans un second temps, cette leçon vous guidera dans la résolution d'une problèmatique qui nécessite de manipuler des données vectorielles.  Au cours des différentes étapes permettant de résoudre la problématique, vous mettrez en pratique les diverses fonctions `R` apprises jusqu'à maintenant. 

En particulier, la problématique à explorer porte sur la planification de vos prochaines vacances estivales au Québec. Vous aimez la nature mais vous appréciez aussi la vie urbaine. Vous aimeriez visiter une grande ville et en même temps pouvoir séjourner dans divers parcs nationaux à proximité de celle-ci. Où se rendre? Quelle ville vous permettra de faire des escapades dans une diversité de parcs? 

Plus précisément, nous allons explorer le territoire Québécois en se posant la question suivante: 

>
> **Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70 km)? **
>

#### Télécharger les données {-}

Pour résoudre cette problématique, nous allons utiliser les données vectorielles relatives aux [municipalités](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives) et aux [régions administratives du Québec](https://www.donneesquebec.ca/recherche/dataset/decoupages-administratifs), ainsi qu'au réseau de la [Société des établissements de plein air du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000), la SÉPAQ. 

Afin de faciliter le téléchargement de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargées en cliquant sur un seul lien: [données pour le module 7](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Module7_donnees.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Module7_donnees` pour ce module, et dézippez-le. Le dossier comprend trois sous-dossiers:

<!-- nettoyer le dossier  -->

- `villes`,
- `parcs.gdb`,
- `regions_admin`.



### Opérations de base 

Avant d'entamer la résolution de notre question, familiarisons-nous avec les opérations fréquemment utilisées sur les données vectorielles.


#### Importer et visualiser les données {-}


Commençons par charger les bibliothèques requises pour lire les données spatiales vectorielles (`sf`) et les visualiser (`mapview`). 

```{r load-libraries7, echo = FALSE, results='hide', warning = FALSE, message = FALSE}
library(sf)
library(mapview)
```

Maintenant, allons lire le fichier *shapefile* de l'ensemble des municipalités du Québec en utilisant la fonction `st_read()` tel que vu dans le [module 4](#lire-shp).

```{r load-villes, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module7/Module7_donnees/"
chemin_muni <- paste(chemin, "/villes/villes.shp", sep = "")
municipalites <- st_read(chemin_muni)
```

```{r load-villes2, eval = TRUE, echo = FALSE}
municipalites <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/villes/villes.shp")
#municipalites <- st_read("Module7/data/villes/villes.shp")
```

Le *shapefile* a été importé dans un objet `R` de classe `sf` (c'est-à-dire un objet importé ou généré par l'utilisation de la bibliothèque `sf`). Nous remarquons que la géométrie de cet object vectoriel est de type point (`POINT`). Plus précisément, cet objet contient 767 points (*features*) et 17 attributs (*fields*).

Pour en savoir davantage sur ces attributs de nature géographique, démographique et administrative, vous pouvez télécharger et consulter la [documentation] (https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives/resource/beb4472a-0edb-4824-b67e-40e20b425326) disponible sur le site de Données Québec.  

Nous pouvons maintenant visuellement valider que l'importation des données a bien été réussi en utilisant la fonction `mapview()`&nbsp;:

```{r visualisation}
mapview(municipalites, legend = FALSE) 
```
<br>

Dans le précédent module portant sur la [cartographie](#carto), nous avons décrit plusieurs fonctionnalités de la bibliothèque `tmap` et avons démontré sa flexibilité et à sa capacité à produire des cartes de grande qualité. Toutefois, la bibliothèque `mapview` demeure fort utile lorsque nous souhaitons visualiser rapidement des données. Par défaut, la fonction `mapview()` affiche la carte d'OpenstreeMap en arrière-pan, ce qui permet de contextualiser facilement les données. 


De plus, les cartes produites avec `mapview()` sont interactives, permettant d'accéder directement à la table d'attributs des données vectorielles représentées. Par exemple, sur la carte ci-dessus, vous n'avez qu'à cliquer sur le marqueur géographique correspondant à chaque municipalité (point) ou à chaque parc (polygone) pour obtenir la liste des attributs et leur valeur. De plus, vous pouvez choisir d'afficher l'une ou l'autre des couches en cochant la couche désirée dans la fenêtre située dans le coin supérieur gauche. 

<br>

#### Opérations sur les attributs des données vectorielles {-}

Les opérations sur les données vectorielles peuvent être séparées en deux grandes catégories. Les opérations qui portent sur les attributs des données et les opérations qui portent sur la géométrie des données. 

Les opérations réalisées sur les attributs des données vectorielles sont indépendantes de la composante spatiale des données. Ce sont des fonctions générales pour manipuler des bases de données et qui s'appliquent aux `data.frame` des données vectorielles. La présente section s'attarde à décrire certaines de ces fonctions. 


##### Filter des attributs {-}

Une opération fréquente lorsque nous manipulons des données vectorielles est celle de filtrer les données. Par exemple, dans le *shapefile* `municipalites` que nous venons d'importer, nous pourrions vouloir sélectionner seulement certaines municipalités parmi les 767 répertoriées ou certains attributs parmi les 17. Nous pourrions aussi vouloir déterminer quelles municipalités possédent une valeur spécifique pour un attribut donné.

Dans les sous-sections qui suivent, nous présenterons des opérations qui permettent de filtrer les attributs de données vectorielles.

<br>


###### Sélectionner des attributs à partir de leur indice {-}

Les objets `sf` sont manipulables de la même façon qu'un `data.frame` (étant eux-mêmes des `data.frame`). Les attributs correspondent aux colonnes tandis que les entités spatiales (points, lignes ou polygones) correspondent aux lignes du `data.frame`.

Par exemple, l'objet spatial `municipalites` contient `r nrow(municipalites)` points correspondant chacun à une municipalité. La table d'attributs contient quant à elle `r ncol(municipalites)` colonnes correspondant à chacun des attributs permettant de décrire les municipalités. 


Pour sélectionner un élément spatial spécifique d'un *shapefile*, nous pouvons simplement spécifier l'indice de la ligne qui lui est associée dans le `data.frame`. Par exemple :

```{r villes-ligne}
municipalites[1, ] # Pour accéder à la première ligne. 
```

Nous remarquons que le nombre de *features* (points) est maintenant de 1 (voir la première ligne de la sortie produite par `R`). En effet, puisque nous avons sélectionné le premier point de l'objet spatial `municipalites` nous avons exclu les 766 autres points. 

De la même manière, pour sélectionner un attribut spécifique, nous pouvons simplement spécifier l'indice de la colonne qui lui est associée :


```{r villes-col}
municipalites[, 2] # Pour accéder à la deuxième colonne. 
```

Nous remarquons également que le nombre de *fields* (colonnes) à diminuer à 1. 


####### Sélectionner des attributs à partir de leur nom {-}

Il est également possible de sélectionner un attribut particulier en spécifiant son nom.

Les colonnes disposent toujours d'un nom unique dans un `data.frame`. Nous pouvons afficher le nom des colonnes en utilisant la fonction `names()`&nbsp;:

```{r villes-nom}
names(municipalites)
```

Cette table contient 17 attributs. L'attribut nommé `HAP_NM_TOP` réfère au nom des municipalités. Notez que l'abréviation `TOP` signifie [toponyme](https://fr.wikipedia.org/wiki/Toponymie). 


Pour sélectionner cet attribut nous pouvons le faire simplement en utilisant son nom. Par exemple, en utilisant la syntaxe suivante :

```{r villes-col-nom}
municipalites[, "HAP_NM_TOP"]
# Ce qui revient également au même que la syntaxe suivante 
municipalites[, 13] 
# Puisque cette colonne est en treizième position.
```

Notez que la syntaxe familière `municipalites$HAP_NM_TOP` retourne un vecteur listant les valeurs de l'attribut `HAP_NM_TOP`, mais ne conserve pas la géométrie du *shapefile*:
```{r}
head(municipalites$HAP_NM_TOP)
```
Toutefois, la syntaxte précédente conserve la géométrie du *shapefile* et peut ainsi être utilisée pour définir un nouvel objet spatial. Par exemple, créons un nouveau *shapefile* qui contient seulement le nom des municipalités et leur position géographique :

```{r villes-topo-col2}
villes <- municipalites[,"HAP_NM_TOP"]
villes
```

Profitons-en pour renommer l'attribut `HAP_NM_TOP` afin d'avoir un intitulé de colonne plus explicite : 

```{r col-villes}
names(villes) <- c("toponyme", "geometry")
names(villes)
```
<!-- visualiser villes et en profiter pour noter que certaines villes ne sont pas à l'intérieur des frontières du QC  -->

##### Filtrer des valeurs d'attribut {-}

On peut vouloir sélectionner un ou plusieurs éléments spatiaux d'un *shapefile* qui possèdent une valeur spécifique d'attribut. Cette opération peut être réalisée en utilisant les fonctions `subset()` ou `which()`.


###### Fonction `subset()` {-}

La fonction `subset()` n'est pas spécifique aux données spatiales, c'est une fonction générale de `R` qui retourne le sous-ensemble d'un vecteur, d'une matrice or d'un tableau de données qui satisfait une condition spécifique. 

Par exemple, nous pouvons utiliser la  fonction `subset()` pour filtrer le jeu de données `villes` afin d'obtenir la localisation d'une municipalité précise:

```{r viz-villes}
la_poc <- subset(villes, toponyme == "La Pocatière")
mapview(la_poc, legend = FALSE)
```

Notez que l'objet retourné, ici `la_poc`, est de même classe que l'objet filtré, ici `villes`. Nous pouvons valider la classe d'un objet dans `R` avec la fonction `class()`. 

```{r ex-class}
class(la_poc)
```


###### Fonction `which()` {#fct_which} {-}

La fonction `which()` est aussi une fonction générale de `R`. Elle identifie la position des éléments de valeur `TRUE` dans un vecteur logique. Par exemple: 

```{r which}
#Exemple 1
which(c(TRUE, FALSE, TRUE, FALSE, TRUE))

#Exemple 2
which(c(1, 1, 2) == 2)
```

Maintenant, utilisons la fonction `which()` pour isoler la ville de La Pocatière:
```{r}
which(villes$toponyme == "La Pocatière")
```
Remarquez que la fonction `which()` retourne l'**indice** de la ligne dans la table d'attributs de l'objet `villes` satisfaisant la condition `toponyme == "La Pocatière"`. 

Nous pouvons ensuite consigner cet identifiant dans l'objet `id_la_poc` et l'utiliser pour déterminer la localisation de la ville de La Pocatière:

```{r interceptions-buffer-parcs4}
id_la_poc <- which(villes$toponyme == "La Pocatière")
villes[id_la_poc,]   
```

##### Ajouter des attributs {-}

Un autre type de manipulations fréquemment utilisé est celui d'enrichir un jeu de données vectorielles en lui ajoutant des attributs. Ces nouvelles informations peuvent provenir d'une base de données non-spatiales ou d'un autre *shapefile*.


Dans le cas de données non-spatiales, nous pouvons combiner les attributs désirés en utilisant l'opération `merge()` que nous définissons dans cette sous-section. Lorsque nous souhaitons ajouter des attributs provenant de données spatiales, nous devons faire une jointure spatiale en utilisant l'opération `st_join()`. Nous définirons `st_join()` dans la section suivante portant sur les [opérations spatiales sur les données vectorielles](#fct_join).


###### La fonction `merge()` {#fct_merge}{-}


La fonction `merge()` est une fonction générale de `R` qui sert à combiner deux tableaux de données différents en se servant de rangées ou de colonnes communes. 

Par exemple, ajoutons à chacune des municipilatés contenues dans le *shapefile* `villes` la taille de sa population. Cette information est contenue dans un fichier `csv` (`Module7_donnees/ville/population.csv`) et provient du [répertoire des municipalités du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/repertoire-des-municipalites-du-quebec/resource/19385b4e-5503-4330-9e59-f998f5918363). 

Nous allons d'abord importer ce fichier CSV dans `R` en utilisant la fonction `read.csv()`. Ensuite, nous sélectionnerons les colonnes pertinentes de ce tableau, et nous ajouterons ces informations aux attributs de l'objet spatial `villes`. 

```{r load-pop, eval = FALSE}
# On importe le fichier dans l'environnement de R
chemin_pop <- paste(chemin, "villes/population.csv", sep = "", encoding="UTF-8")
pop <- read.csv(chemin_pop)
```

```{r, eval = TRUE, echo = FALSE}
pop <- read.csv("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/villes/population.csv",encoding="UTF-8")
#pop <- read.csv("Module7/Module7_donnees/villes/population.csv",encoding="UTF-8")
```

Notez que la précision de l'encodage assure que les accents français sont bien importés lors de la lecture du document.

L'objet `pop` est un `data.frame` de `r ncol(pop)` colonnes décrivant un ensemble d'informations propres aux municipalités du Québec allant de leur nom jusqu'à la composition de leur conseil municipal. Toutes ces informations ne sont pas pertinentes pour le présent exercice. Pour faciliter la manipulation de ce tableau, sélectionnons seulement les colonnes suivantes:

- `munnom`: Nom de la ville. Cette colonne servira à faire la jointure entre l'objet spatial `villes` et l'objet `pop` contenant la taille des populations.
- `msuperf`: Superficie de la municipalité.
- `mpopul`: Taille de la population de la municipalité.

```{r select-pop-cols}
pop <- pop[, c("munnom", "msuperf", "mpopul")]
```

Le nouvel objet `pop` ainsi défini, contient seulement `r ncol(pop)` colonnes.

Nous voulons à présent fusionner l'objet `pop` avec l'objet spatial `villes` en utilisant la fonction `merge()`. Cette fusion entre les deux objets `villes` et `pop` sera réalisée sur les colonnes `toponyme` et `munnom` respectivement. Ces deux colonnes contiennent le nom des municipalités et agissent donc comme dénominateur commun entre les deux jeux de données. L'argument `all.x = TRUE` spécifie que toutes les entrées (`POINT`) de l'objet `villes` doivent être conservées. 

L'argument `all.x = FALSE` spécifie que seules les entrées (`POINT`) de l'objet `villes` qui 

```{r}
#villes_qc <- merge(x = villes_qc, y = pop, by.x="toponyme", by.y="munnom",  all.x = TRUE)
villes_pop <- merge(x = villes, y = pop, by.x="toponyme", by.y="munnom")
villes_pop
``` 

Le nouveau *shapefile* `villes_pop` contient les mêmes attributs que `villes` auxquels se sont ajoutés les attributs de `pop`. 

Remarquez que `villes_pop` contient moins d'éléments que `villes`. En effet, la fonction `merge()` n'a retenue que les villes qui étaient contenues à la fois dans le *shapefile* `villes` et dans la base de données `pop`. Pour conserver l'entièreté des éléments initialement présents dans `villes`, il faudrait ajouter l'argument `all.x = TRUE` à la fonction `merge()`. Dans ce cas, les villes dont la population n'est pas définie dans `pop` se verraient attribuer une valeur `NA` à l'attribut `mpopul`.


Renommons les colonnes de `villes_pop` pour qu'elles portent un nom plus représentatif de leur contenu. 

```{r}
names(villes_pop)
names(villes_pop)[2:3] <- c("superficie", "population")
names(villes_pop) 
```


#### Opérations spatiales sur les données vectorielles {-}

Les opérations réalisées dans la section précédente sur les attributs des données vectorielles, telles `merge()`, `which()` et `subset()`, sont indépendantes de la composante spatiale des données. Si nous changions la géométrie des objets spatiaux décrits par les données vectorielles (par exemple en changeant les coordonnées des villes), ces opérations produiraient les mêmes résultats. Ce sont des fonctions générales pour manipuler des bases de données et qui s'appliquent aux `data.frame` des données vectorielles. 

Dans la présente section, nous verrons plutôt des opérations qui dépendent de la composante spatiale des données vectorielles. Ces opérations prennent en considération la géométrie des données et certaines peuvent aussi la transformer. 


##### Jointure et agrégation spatiale {-}

Les opérations de jointure et d'aggrégation permettent de lier entre eux des éléments spatiaux sur la base d'une valeur d'attribut commune.


###### La fonction `st_join()`{#fct_join} {-}

La fonction `st_join()` de la bibliothèque `sf` permet de joindre à un *shapefile* de l'information provenant d'une autre couche spatiale. Cette opération constitue une jointure spatiale.

Par exemple, importons le *shapefile* des régions administratives du Québec, disponible dans le dossier `Module7_données`, et réalisons une jointure entre cette couche et la couche `villes`.

```{r load-reg, eval = FALSE}
# On importe le fichier dans l'environnement de R
chemin_reg <- paste(chemin, "regions_admin/regions_admin.shp", sep = "")
regions <- st_read(chemin_reg)

# on observe le contenu de ce shaphefile
regions

# on le visualise
mapview(regions)
```

```{r}
regions <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/regions_admin/regions_admin.shp")
#regions <- st_read("Module7/Module7_données/regions_admin/regions_admin.shp")
head(regions)
```
Notez que les éléments de `regions` sont des polygones. Ces polygones possèdent un seul attribut, `"Rgns_Ad"`, correspondant au nom des régions administratives que ceux-ci délimitent. 

Nous allons maintenant faire une jointure spatiale entre `villes` et `regions` afin d'associer à chaque municipalité sa région administrative d'attache.

```{r, warning = FALSE}
villes_reg = st_join(villes, regions[ ,"Rgns_Ad"])
villes_reg
```
Remarquez que l'objet `villes_reg` est identique à l'objet `villes` mais contient un attribut supplémentaire: la colonne `Rgns_Ad`.

Il est important de préciser que la fonction `st_join()` nécessite que les deux couches spatiales à joindre utilisent le même système de coordonnées de référence (SCR).

Contrairement à la fonction `merge()` vue plus haut, la fonction `st_join()` est bien une opération spatiale. En effet, `st_join(x,y)` détermine s'il y a une intersection spatiale entre chaque éléments de l'objet de gauche (`x = villes`) et l'un ou l'autre des éléments de l'objet de droite (`y = regions`). Une intersection entre deux éléments spatiaux se produit lorsqu'ils partagent une même portion de l'espace. Ainsi, il y a une intersection entre le point associé à la ville de Shawinigan et le polygone associé à la région de la Mauricie. Par ailleurs, il n'y a pas d'intersection entre le point associé à la ville de Sherbrooke et le polygone de la Mauricie.

Lorsque `st_join(x,y)` identifie la présence d'une intersection entre deux éléments, elle assigne à l'élément de gauche la valeur de l'attribut (ici `"Rgns_Ad"`) de l'élément de droite. 

Lorsqu'il n'y a pas d'intersection entre deux éléments, la fonction assigne une valeur d'attribut `NA` à l'élément de gauche. Par exemple, les données `villes` contiennent des municipalités qui ne sont pas situées au Québec. On retrouve entre autres la ville d'Albany dans l'état de New York aux États-Unis. Ainsi aucune région n'a pu être associée à ces villes.

```{r}
villes_reg[692,]
```
Si nous souhaitons que la fonction `st_join(x,y)` conserve seulement les éléments de `x` qui intersectent un ou l'autre des éléments de `y`, nous devons ajouter l'argument `left = FALSE` :

```{r, warning = FALSE}
villes_reg <- st_join(villes, regions[ ,"Rgns_Ad"], left = FALSE)
```
Visualisons le nouveau *shapefile* que nous venons de créer. Ce dernier contient seulement les municipalités à l'intérieur du territoire québécois.

```{r,  warning = FALSE}
mapview(villes_reg, legend = FALSE)
```
Notez que lorsque vous cliquez sur les points de la carte, la valeur de l'attribut  "Rngs_Ad" est maintenant également donnée.

Vous pouvez ainsi différencier visuellement les municipalités selon leur région administrative d'attache.
```{r,  warning = FALSE}
mapview(villes_reg, zcol = "Rgns_Ad", legend = FALSE)
```

Que se produit-il si nous inversons les arguments `villes` et `regions` dans la fonction `st-join()` &nbsp;? Dans ce cas, la jointure spatiale associe à chaque région les villes qui sont situées (c'est-à-dire intersectent) son territoire. Observons le résultat d'une telle jointure&nbsp;:

```{r, warning = FALSE}
reg_villes <- st_join(regions, villes[,"toponyme"], left = FALSE)
reg_villes
```
Le *shapefile* `reg_villes` est constitué des polygones de `regions`. Puisque plusieurs municipalités intersectent chaque région, le polygone d'une région donnée est dupliqué pour chacun des points. C'est-à-dire qu'une nouvelle ligne est ajoutée pour chacune des intersections identifiées.

Remarquez que nous pouvons aussi utiliser la fonction `join_st()` en vue de créer un filtre spatial, par exemple avec la fonction `subset()` &nbsp;:

```{r}
villes_CN<- subset(villes_reg, Rgns_Ad=="Côte-Nord")
mapview(villes_CN, legend = FALSE)
```

Cette opération nous a permis de filtrer les municipalités du Québec pour retenir seulement celles situées dans la région administrative de la Côte-Nord.

<!-- il faut mettre aggregate comme une fonction géométrique car elle change la geéométrie   -->

###### La fonction `aggregate()`{-}

La fonction `aggregate()` de la bibliothèque `sf` permet d'agréger (c'est-à-dire de grouper) des éléments spatiaux d'une même couche de données vectorielles. 

Afin de démontrer comment opère la fonction `aggregate()` considérons d'abord l'objet `villes_reg_pop`. Ce dernier est formé par la jointure spatiale entre `villes_pop`, le *shapefile* associant à chaque municipalité la taille de sa population, et `regions`&nbsp;:
```{r, warning = FALSE}
villes_reg_pop <- st_join(villes_pop, regions[ ,"Rgns_Ad"], left = FALSE)
villes_reg_pop
```
L'objet `villes_reg_pop` associe à chaque municipalité la taille de sa population ainsi que sa région administrative. 
En agrégeant ensemble les villes d'une même région, il nous est possible de déterminer la taille de la population de cette région. C'est ce que nous allons faire en utilisant la fonction `aggregate()`&nbsp;:


```{r, warning = FALSE}
reg_pop<-aggregate(villes_reg_pop["population"], by = list(villes_reg_pop$Rgns_Ad), FUN = sum, na.rm = TRUE)
reg_pop
```

De façon générale, la fonction `aggregate(x, by, FUN)` comprend trois arguments:
- `x` est l'objet spatial que l'on souhaite agréger,
- `by` défini la condition utilisée pour regrouper les éléments de `x`,
- `FUN` défini la fonction selon laquelle l'attribut d'un groupement est calculé à partir des attributs des éléments agrégés.

Dans notre exemple, nous avons regroupé les points de l'objet spatial `villes_reg_pop["population"]` qui possèdent la même valeur d'attribut `"Rgns_Ad"`. Les points ainsi regroupés forment une géométrie multipoint (`MULTIPOINT`). Chaque groupe de points est identifié par le nom de sa région administrative (Abitibi-Témiscamingue, Bas-Saint-Laurent, etc.). L'attribut d'un groupe est calculé en faisant la somme (`FUN = sum`) des attributs des points qui le constituent. L'argument additionnel `na.rm = TRUE` précise que lors du calcul de la somme, les éléments dont l'attribut `"population"` prend la valeur `NA` doivent être ignorés. En effet, la population de quelques municipalités n'est pas définie dans cette base de données. Notez qu'une autre fonction aurait pu être utilisée, par exemple la moyenne, le maximum, le minimum, etc.

La condition `by` peut prendre différentes forment. Elle peut être définie par une liste de longueur égale au nombre d'éléments dans `x` (c'est-à-dire le même nombre de rangées). C'est de cette façon que nous l'avons définie plus haut (la liste est de longueur égale aux nombres de points dans `villes_reg_pop`). De plus, `by` peut prendre la forme d'un objet spatial dont la géométrie est utilisée pour grouper les éléments de `x`. Dans ce cas, la géométrie du nouvel objet créé par la fonction `aggregate()` est la même que l'objet `by`.


Donnons un exemple illustrant cette situation. Agrégeons maintenant les municipalités de l'objet `villes_pop["population"]` en utilisant directement l'objet `regions` constitué de polygones &nbsp;: 

```{r, warning = FALSE}
reg_pop2 <-aggregate(villes_pop["population"], by = regions, FUN = sum, na.rm = TRUE)
reg_pop2
```
Observez que les groupements sont maintenant des polygones, et non des multipoints. Par ailleurs le calcul de l'attribut `"population"` est le même. 

Une visualisation du nouvel objet `reg_pop2` permet d'illustrer les régions selon la taille de leur population&nbsp;:
```{r}
mapview(reg_pop2)
```

Donnons un dernier exemple de l'utilisation de la fonction `aggregate()` en considérant le *shapefile* régions

```{r}
regions
```
Remarquez que certaines régions, comme la Côte-Nord, sont représentées par plusieurs polygones. C'est pour cette raison que ce *shapefile* contient 21 éléments spatiaux alors qu'il y a 17 régions administratives au Québec.

Utilisons la fonction `aggregate()` pour agréger en un seul multipolygone les polygones qui portent la même valeur d'attribut `"Rgns_Ad"`&nbsp;: 

```{r}
regions_agg <-aggregate(regions, by=list(regions$Rgns_Ad), unique)
regions_agg
```

Cette fois nous avons utilisé la fonction `unique` pour agréger les attributs qui sont de classe caractère. Remarquez que la Côte-Nord est maintenant représentée par un multipolygone (`MULTIPOLYGON`) et que le nouveau *shapefile* `regions_agg` contient 17 éléments, un pour chacune des régions administratives.

Retirons la première colonne superflue de ce nouveau *shapefile* et utilisons-le dans les futurs exemples pour désigner les régions administratives. 
```{r}
regions <- regions_agg[-1]  #pour retirer la première ligne
```


##### Opérations géométriques {-}

Les opérations géométriques sur les données vectorielles sont des opérations qui peuvent changer la géométrie des données ou qui peuvent créer, à partir de celles-ci, des nouveaux objets vectoriels de géométrie différente. 


###### La fonction `st_simplify()` {#fct_simplify}{-}

Il est parfois utile de simplifier les objets vectoriels de types ligne ou polygone afin de produire des cartes à des échelles plus petites. La simplification permet de réduire l'utilisation de la mémoire, du disque, et de la bande passante. 

La fonction `st_simplify()` de la bibliothèque `sf` permet de simplifier des objets vectoriels de types ligne ou polygone en réduisant le nombre de points que ceux-ci comprennent. Souvenez-vous qu'une ligne est constituée d'une succession de points et qu'un polygone est constitué d'un ensemble de lignes. 

Cette fonction est basée sur l'algorithme de [Douglas-Peucker](https://fr.wikipedia.org/wiki/Algorithme_de_Douglas-Peucker). Décrire le fonctionnement de cet algorithme dépasse l'objectif de ce cours. Grosso modo, l'algorithme fait appel à un seuil de distance (le paramètre `dTolerance`) qu'il utilise pour transformer en ligne droite toute courbe qui dévie d'une ligne droite par une quantité moindre que ce seuil. Cette distance réflète en quelque sorte la résolution que nous souhaitons atteindre avec l'objet simplifié.

Le seuil de tolérance étant une distance, nous l'exprimons en mètres. Nous devons alors nous assurer que l'objet spatial à simplifier est dans un système de coordonnées métriques.

En guise d'exemple, simplifions le *shapefile* des régions administratives du Québec (\@ref(fig:ex-st-simple)):

```{r, warning = FALSE }
regions_nad <- st_transform(regions, crs = 32198)
regions_simple_10 <- st_simplify(regions_nad, dTolerance = 10000) #10000m
regions_simple_40 <- st_simplify(regions_nad, dTolerance = 40000) #40000m
```


```{r ex-st-simple, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La carte des régions administratives du Québec. Polygones originaux (à gauche) et polygones simplifiés avec un seuil faible (au centre) et un seuil élevé (à droite)."}
map <- mapview(regions_nad, col.regions = "blue", alpha.regions = 0.4, legend = FALSE)
map_10 <- mapview(regions_simple_10, col.regions = "blue", alpha.regions = 0.4, legend = FALSE)
map_40 <- mapview(regions_simple_40, col.regions = "blue", alpha.regions = 0.4,legend = FALSE)

leafsync::latticeView(map,map_10, map_40, ncol = 3)
```

Remarquez que nous avons d'abord transformé l'objet spatial `regions` dans le système de coordonnées de référence NAD83, dont le EPSG correspond à 32198, puisque l'unité de ce système est le mètre.


###### La fonction `st_combine()` {#fct_combine}{-}

La fonction `st_combine()` de la bibliothèque `sf` sert à combiner des géométries afin d'en former une seule. Cette opération peut être utile lorsque nous souhaitons considérer plusieurs géométries comme formant un même objet spatial.

```{r, warning=FALSE, echo=FALSE, eval=TRUE}
reg_tourist <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/data/regions_touristiques/Shapefile/regn_tours_s250k_20160125.shp")

#reg_tourist <- st_read("Module7/Module7_données/regions_touristiques/regn_tours_s250k_20160125.shp")

#reg_tourist
iles<-subset(reg_tourist, Nom_reg_to =="Îles-de-la-Madeleine")
gasp<-subset(reg_tourist, Nom_reg_to =="Gaspésie")
#mapview(iles, col.regions = "green", alpha.regions = 0.4) + mapview(gasp, col.regions = "blue", alpha.regions = 0.4)

GIM <-iles
GIM[2,]<-gasp
GIM <-GIM[,-4]
GIM <-GIM[,-2]
names(GIM)<-c("Id", "Nom_reg", "geometry")

#GIM
#mapview(GIM, zcol = "Nom_reg")

# iles_poly<-st_cast(iles, to = "POLYGON")
# iles_poly
# mapview(iles_poly)
```
Considérons le *shapefile* `GIM` contenant deux géométries: le polygone délimitant la Gaspésie et un polygone délimitant les Îles-de-la-Madeleine.

```{r}
GIM
```

Maintenant, combinons ces deux polygones pour former une géométrie unique qui correspondra à la région administrative de la Gaspésie - Îles-de-la-Madeleine


```{r}
GIM_combine <- st_combine(GIM)
GIM_combine
```
Le nouvel objet `GIM_combine` est effectivement formé d'une seule géométrie. Notez cependant que la fonction `st_combine()` ne fusionne pas les frontières à l'intérieur du nouveau polygone formé (\@ref(fig:map-combo)). Pour unir deux polygones, il faut plutôt utiliser la fonction `st_union()` que nous définirons plus bas dans cette leçon.

```{r map-combo, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La Gaspésie et les Îles-de-la-Madeleine  traités comme deux polygones distincts (gauche), leur combinaison par la fonction `st_combine()` (centre), et leur union par la fonction `st_union()` (droite)".}
GIM_union<-st_union(iles, gasp)
GIM_combine<-st_sf(GIM_combine)#sinon la legende n'apparait aps
map_GIM <- mapview(GIM, zcol = "Nom_reg")
map_GIM_union <-mapview(GIM_union,  col.regions = "green", alpha.regions = 0.2)
map_GIM_combo <- mapview(GIM_combine, col.regions = "blue", alpha.regions = 0.2)
leafsync::latticeView(map_GIM,map_GIM_combo, map_GIM_union, ncol = 3)
```

<!--  La classe est aussi changée

```{r}
class(GIM)
class(GIM_combine)
class(GIM_union)
```

-->


###### La fonction `st_cast()` {-}

La fonction `st_cast()` sert à convertir la géométrie d'un objet spatial donné vers une autre géométrie. Cette fonction comprend deux arguments : `st_cast(x, to)`. Le premier argument, `x`, correspond à l'objet vectoriel dont on souhaite modifier la géométrie, alors que le second argument, `to` correspond à la géométrie que l'on souhaite lui attribuer. 

Donnons un exemple. Utilisons d'abord le *shapefile* `regions` pour isoler le polygone de la région administrative de la Mauricie grâce à la fonction `subset()`&nbsp;:
```{r, warning=FALSE}
Mauricie <- subset(regions,Rgns_Ad=="Mauricie")
Mauricie
```
Nous observons que l'objet `Mauricie` est bel et bien de type *polygone*. Maintenant utilisons la fonction `st_cast()` pour transformer la géométrie de cet objet en type *multiligne* et *multipoint*  &nbsp;:

```{r, warning=FALSE}
Mauricie_lines <- st_cast(Mauricie, to = "MULTILINESTRING")
Mauricie_lines
Mauricie_pts<-st_cast(Mauricie, to = "MULTIPOINT")
Mauricie_pts
```
Nous observons que les deux nouveaux objets vectoriels ont bel et bien la géométrie souhaitée (\@ref(fig:ex-cast1)).

```{r ex-cast1, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La fonction `st_cast()` a été utilisée pour transformer le polygone de la Mauricie (gauche) en multilignes (centre) et en multipoints (droite)."}

Lines<- mapview(Mauricie_lines, legend = FALSE)
Poly <- mapview(Mauricie, legend = FALSE)
Points<-mapview(Mauricie_pts, legend = FALSE)

# Visualisons les trois cartes cÃ´te à cÃ´te
leafsync::latticeView(Poly,Lines,Points, ncol = 3)
```

Dans cet exemple, nous avons en quelque sorte "décomposé" la géométrie d'un polygone en lignes puis en points. Or, la fonction `st_cast()` peut également servir à "consolider" des géométries.

En guise d'exemple, considérons l'objet `villes_NQ_combo` créé en isolant du *shapefile* `villes_reg` les villes situées dans la région administrative du Nord-du-Québec et en les combinant par l'utilisation de la fonction `st_combine()`&nbsp;:

```{r}
villes_NQ <- subset(villes_reg, Rgns_Ad == "Nord-du-Québec") 
villes_NQ_combo <- st_combine(villes_NQ)
villes_NQ_combo
```
Cet objet possède une géométrie multipoint où chaque point correspond à une municipalité du Nord-du-Québec.

Utilisons maintenant la fonction `st_cast()` pour transformer la géométrie de cet objet en ligne et en polygone &nbsp;:

```{r}
villes_NQ_lines<-st_cast(villes_NQ_combo, to = "LINESTRING")
villes_NQ_lines


villes_NQ_pol<-st_cast(villes_NQ_combo, to = "POLYGON")
villes_NQ_pol
```

```{r ex-cast2, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La fonction `st_cast()` a été utilisée pour transformer les villes du Nord-du-Québec de multipoints (gauche) en ligne (centre) et en polygone (droite).}

Points <- mapview(villes_NQ_combo, legend = FALSE)
Lines <- mapview(villes_NQ_lines, legend = FALSE)
Pol <- mapview(villes_NQ_pol, legend = FALSE)

leafsync::latticeView(Points,Lines,Pol, ncol = 3)
```
L'objet `villes_NQ_lines` correspond effectivement à un ensemble de lignes et l'objet `villes_NQ_lines` à un ensemble de polygones formés en reliant les points ensembles.


###### La fonction `st_buffer()` {-}

Une zone tampon (appelée *buffer* en anglais) est un polygone dont les frontières sont définies par une distance donnée autour d'un objet vectoriel. Une zone tampon peut être créée autour de tout objet vectoriel, que ce soit des points, des lignes ou des polygones. 

La création de zones tampons est généralement réalisée pour répondre à des questions de nature géographique. Par exemple, combien de garderies se situent à une distance de 2&nbsp;km de ma maison&nbsp;? Ou encore, combien de stations services se situent à moins de 500&nbsp;m de la route menant de Chelsey à Cantley en Outaouais&nbsp;? 

La fonction `st_buffer()` de la bibliothèque `sf` permet de créer des zones tampons. Cette fonction comprend obligatoirement deux arguments. Le premier correspond à l'objet vectoriel autour du quel nous souhaitons construire une zone tampon, et le deuxième argument défini la distance sur laquelle la zone tampon s'étendra autour de l'objet vectoriel. Comme pour la fonction `st_simplify()`, l'objet vectoriel auquel nous appliquons la fonction `st_buffer()` doit être exprimé dans un SCR d'unité de mesure métrique.

Construisons des zones tampons autour de la ville de La Pocatière, que nous avons isolée plus haut, en considérant deux distances différentes (\@ref(fig:buffer-lapoc)):

```{r}
la_poc_nad <- st_transform(la_poc, crs = 32198)
la_poc_tampon10 <- st_buffer(la_poc_nad, dist = 10e3)
la_poc_tampon50 <- st_buffer(la_poc_nad, dist = 50e3)
```

Notez que l'expression `e3` correspond au chiffre 1000 (c'est-à-dire 10 exposent 3).

```{r buffer-lapoc, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="Deux zones tampons de 10 km (en bleu) et de 50 km (en vert) autour de la ville de La Pocatière"}
# library(tmap)
# new_bb <- bb(regions_nad, xlim = c(0.25, 0.75), ylim = c(0.25, 0.75), relative = TRUE)
# mapQ <- tm_shape(regions_nad, bbox = new_bb) + tm_fill()
# mapdot <- tm_shape(la_poc_nad) + tm_dots(col="black")
# map1 <- mapQ + mapdot + tm_layout(outer.margins = c(0.3, 0.3, 0.3, 0.3)) + 
#  tm_shape(la_poc_tampon10) + tm_fill(col="blue", alpha = 0.4) + tm_borders(col="blue")
# map2<- mapQ + mapdot + tm_layout(inner.margins = c(0.3, 0.3, 0.3, 0.3)) +
#   tm_shape(la_poc_tampon50) + tm_fill(col="green", alpha = 0.4) + tm_borders(col="green")
# 
# 
# tmap_arrange(map1,map2)
mapview(la_poc_tampon50, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + mapview(la_poc_tampon10, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE)
```

Maintenant, construisons des zones tampons autour des régions administratives de l'Abitibi-Témiscamingue et du Saguenay - Lac-Saint-Jean (\@ref(fig:buffer-regions)). Utilisons d'abord la fonction `subset()` pour isoler les polygones correspondants à ces régions à partir du *shapefile* `regions_nad` dont l'unité de mesure du SCR est le mètre. 


```{r}
# Isoler les polygones des deux régions
Abitibi <- subset(regions_nad, Rgns_Ad == "Abitibi-Témiscamingue")
SagStJean <- subset(regions_nad, Rgns_Ad == "Saguenay - Lac-Saint-Jean")

# Calculer une zone tampon pour chacun des polygones
Abitibi_tampon20 <- st_buffer(Abitibi, dist = 20e3)  #20 km
SagStJean_tampon50 <- st_buffer(SagStJean, dist = 70e3)  #70 km
```

```{r buffer-regions, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="Une zone tampon de 20 km autour de la région administrative de l'Abitibi-Témicamingue et une zone tampon de 70 km autour du Saguenay - Lac-Saint-Jean."}
mapview(SagStJean_tampon50, col.regions = "green", alpha.regions = 0.2, legend = FALSE) +
mapview(SagStJean, col.regions = "green", alpha.regions = 0.4, legend = FALSE) + 
mapview(Abitibi_tampon20, col.regions = "blue", alpha.regions = 0.2,  legend = FALSE) +
mapview(Abitibi, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE) 
```

Notez que la zone tampon d'un polygone inclue le polygone d'origine. C'est-à-dire que ce n'est pas simplement une bordure autour du polygone. 

###### La fonction `st_centroid` {-}

Le centroïde d'un polygone en cartographie correspond approximativement au centre géométrique d'un polygone^[Le centre géométrique d'une forme planaire est la moyenne des positions de tous les points constituants la forme. Vous pouvez trouver des informations supplémentaires sur le centroïde [ici]^(http://wiki.gis.com/wiki/index.php/Centroid).]. Ces coordonnées servent parfois à définir la localisation du polygone. La fonction `st_centroid()` de la bibliothèque `sf` permet de calculer le centroïde de polygones.

Déterminons le centroïde des polygones de l'Abitibi et du Saguenay - Lac-Saint-Jean (\@ref(fig:centroid-regions)). Notez que la fonction `st_centroid()` nécessite également que le polygone soit défini selon un SCR dont l'unité de mesure est le mètre.

```{r, warning=FALSE}
centre_Abitibi <- st_centroid(Abitibi)
centre_Abitibi
centre_SagStJean <- st_centroid(SagStJean)
centre_SagStJean
```

La fonction `st_centroid()` retourne un objet vectoriel de type point qui conserve les attributs du polygone.

```{r centroid-regions, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="Les centroïdes (en rouge) des régions de l'Abitibi-Témicamingue (en bleu) et du Saguenay - Lac-Saint-Jean (vert) calculés avec la fonction  `st_centroid()`."}
mapview(centre_SagStJean, col.regions = "red", legend = FALSE) +
mapview(SagStJean, col.regions = "green", alpha.regions = 0.4, legend = FALSE) + 
mapview(centre_Abitibi, col.regions = "red" ,legend = FALSE) +
mapview(Abitibi, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE) 
```


######  Opérations topologiques entre deux couches {-}

Les opérations topologiques décrivent les relations spatiales entre des objets^[https://geocompr.robinlovelace.net/spatial-operations.html#topological-relations].
Ces opérations sont équivalentes aux opérations ensemblistes en mathématiques, telles l'union ou l'intersection, mais s'appliquent cette fois à des objets définis par une géométrie. 

La bibliothèque `sf` contient plusieurs opérateurs topologiques; par exemple: `st_union()`, `st_intersection()`, `st_difference()` et `st_sym_difference()`. Ces opérateurs forment un nouvel objet spatial à partir des deux objets spatiaux intérroger. Par exemple, la géométrie de l'objet `z` formé par l'opération `z <- st_union(x,y)` est constituée de la géométrie de `x` *et* de celle de `y` sans toutefois qu'il y ait de chevauchement.

Pour illustrer les opérations topologiques entre deux objets vectoriels considérons les polygones A et B créés en définissant des zones tampons à partir des polygones de l'Abitibi-Témiscamingue et du Saguenay - Lac-Saint-Jean respectivement. 

```{r}
A <- st_buffer(Abitibi, dist = 80e3)
B <- st_buffer(SagStJean, dist = 100e3)
```

```{r, warning = FALSE, echo = FALSE, eval = TRUE}
A$Rgns_Ad<-"A"
B$Rgns_Ad<-"B"
```

Calculons maintenant des opérations topologiques sur ces polygones &nbsp;: 

```{r, warning = FALSE}
union_AB <- st_union(A,B)
inter_AB <- st_intersection(A,B)
diff_AB <- st_difference(A,B)
diff_BA <- st_difference(B,A)
sym_diff_AB <- st_sym_difference(A,B)
```

Observons les géométries produites par ces opérations (figure \@ref(fig:topo-op)) &nbsp;:

```{r topo-op, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="Exemples d'opérations topologiques sur les polygones A et B. En haut: illustrations de A et B (gauche) et de `st_union(A,B)` (droite). Au centre:   illustrations de `st_difference(A,B)` (gauche) et de `st_difference(B,A)` (droite). En bas: illustrations de `st_intersection(A,B)` (gauche) et de `st_sym_difference(A,B)` (droite)."}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2)+mapview(B, col.regions = "red", alpha.regions = 0.2)
map_union <- mapview(union_AB, col.regions = "darkmagenta", alpha.regions = 0.2)
map_inter <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(inter_AB, col.regions = "darkmagenta", alpha.regions = 0.2)
map_diffAB <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(diff_AB, col.regions = "darkmagenta", alpha.regions = 0.2)
map_diffBA <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(diff_BA, col.regions = "darkmagenta", alpha.regions = 0.2)
map_symdiff <- mapview(union_AB, col.regions = "grey", alpha.regions = 0.2, legend = FALSE) + mapview(sym_diff_AB, col.regions = "darkmagenta", alpha.regions = 0.2)

leafsync::latticeView(map_AB, map_union,map_diffAB, map_diffBA, map_inter, map_symdiff, ncol = 2)
```

###### Opérations topologiques de confirmation {-}

Les opérations topologiques de confirmation sont des fonctions qui permettent de vérifier si deux objets spatiaux satisfont à une relation topologique donnée. Ces opérations ne créent pas un nouvel objet spatial, elles retournent plutôt une valeur binaire qui confirme si oui ou non la relation existe entre les deux objets interrogés. 

La bibliothèque `sf` contient plusieurs opérateurs topologiques de confirmation; par exemple: `st_intersects()`, `st_disjoint()`, `st_crosses()`, `st_overlaps()`, `st_touches()`, `st_within()` et `st_contains()`.

####### `st_intersects` {-}

La fonction `st_intersects()` vérifie si deux objets spatiaux `X` et `Y` occupent un espace commun. La fonction confirmera qu'il y a bel et bien une intersection entre les deux objets si leurs intérieurs ou leurs frontières se recoupent. `X` et `Y` peuvent avoir n'importe quelle géométrie (point, multipoint, ligne, multiligne, polygone, multipolygone) (figure  \@ref(fig:st-intersects)).


```{r st-intersects, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries satisfaisant à la condition d'intersection. Récupérer sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '50%'}
knitr::include_graphics('Module7/images/st_intersects.png')
```

```{r, echo = FALSE, warning=FALSE}
centre_A <- st_centroid(A)
centre_B <- st_centroid(B)
centre_unionAB <- st_centroid(union_AB)
centre_interAB <- st_centroid(inter_AB)


A_lines<-st_cast(A, to = "LINESTRING")
B_lines<-st_cast(B, to = "LINESTRING")
B_lines_A_lines_int<-st_intersection(B_lines,A_lines)
ABpoints<-st_cast(B_lines_A_lines_int, to = "POINT")
point_interAB<-ABpoints[1,]

A_points <-st_cast(A, to = "POINT")
A_sub<-A_points[1:100,]
A_sub <- st_combine(A_sub)
A_trait <-st_cast(A_sub, to = "LINESTRING", group_or_split = TRUE)
A_pp<-A_points[1,]

points<-st_centroid(A)[,"geometry"]
points[2,]<-st_centroid(B)[,"geometry"]
points[3,]<-st_centroid(inter_AB)[,"geometry"]
points[4,]<-st_centroid(union_AB)[,"geometry"]
#points[5,]<-point_interAB[,"geometry"]
points[5,]<-A_points[1,"geometry"]

colors<-c("Bleu","Rouge","Violet","Jaune","Vert")
points$couleur<-colors

point_bleu<- subset(points, couleur=="Bleu")
point_rouge<- subset(points, couleur=="Rouge")
point_violet<- subset(points, couleur=="Violet")
point_jaune<- subset(points, couleur=="Jaune")
point_vert<- subset(points, couleur=="Vert")

```


Pour bien comprendre comment opère `st_intersects()` considérons le polygone A utilisé précédemment ainsi que l'objet spatial `points` constitués de cinq points de couleur différente.

```{r}
points
```

```{r geo-conf1, warning=FALSE, echo=FALSE, fig.align='center', fig.cap="Exemples illustrant la fonction `st_intersects()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  ##mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  mapview(point_bleu, col.regions="blue",legend = FALSE) + 
  mapview(point_rouge, col.regions="red",legend = FALSE) +
  mapview(point_violet, col.regions="darkmagenta",legend = FALSE)+
  mapview(point_jaune, col.regions="darkgoldenrod",legend = FALSE)+
  mapview(point_vert, col.regions="darkgreen",legend = FALSE)
  ##mapview(A_trait, color = "black", lwd = 3, legend = FALSE)
map_AB
```

Utilisons a fonction `st_intersects()` pour déterminer quels points intersectent le polygone A :

```{r, warning=FALSE}
st_intersects(points, A)
```

La sortie est exprimée sous forme d'une liste contenant 5 paires éléments; une paire pour chacun des points interrogés. Le premier élément d'une paire (c'est-dire,le chiffre avant le deux-points) correspond à l'indice du point. Le second élément prend la valeur `1` si le point intersecte le polygone A, et la valeur `empty` si le point ne recoupe pas le polygone A. 

Il est aussi possible d'ajouter l'argument `sparse = FALSE` afin que la sortie s'exprime sous une forme matricielle d'éléments logiques.

```{r}
st_intersects(points, A, sparse = FALSE)
```
La forme logique est particulièrement utile lorsque nous voulons filtrer les géométries qui satisfont à la condition d'intersection. Par exemple, cette commande retourne seulement les points qui intersectent le polygone A :
```{r}
points[st_intersects(points, A, sparse = FALSE),]
```
Que se passent-ils si nous inversons les arguments de la fonction `st_intersects()` ?
```{r}
st_intersects(A, points)
```
Dans ce cas, la fonction retourne une liste d'une seule combinaison éléments associée au polygone interrogé. Cette fois, les éléments à droite du deux-points correspondent aux indices des points qui satisfont à la condition d'intersection. 


####### `st_disjoint` {-}

La fonction `st_disjoint()` vérifie la condition inverse de la fonction `st_intersects()`, c'est-à-dire l'absence d'intersection entre deux objets `X` et `Y` (figure  \@ref(fig:st-disjoint)). 


```{r st-disjoint, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries disjointes. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '50%'}
knitr::include_graphics('Module7/images/st_disjoint.png')
```

Par exemple, la fonction `st_disjoint()` permet de confirmer que les points jaune et rouge sont disjoints du polygone A (Figure  \@ref(fig:geo-conf1))&nbsp;:
```{r}
st_disjoint(A, points)
# ou encore
points$couleur[st_disjoint(A, points,sparse = FALSE)]
```

####### `st_crosses` {-}

La fonction `st_crosses()` vérifie si deux objets spatiaux `X` et `Y` se croisent. Cette fonction est donc similaire à la fonction `st_intersects()` mais elle contient des conditions supplémentaires:

* l'intersection entre les deux géométries inclue une partie mais pas l'entièreté de leurs intérieurs,
* la dimension géométrique de l'intersection doit être inférieure à la dimension maximale des deux géométries, 
* l'intersection ne peut être égale à l'une ou l'autre des géométries.

La figure \@ref(fig:st-crosses) illustre différentes combinaisons de géométries qui satisfont à la condition `st_crosses`.

```{r st-crosses, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui se croisent. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '50%'}
knitr::include_graphics('Module7/images/st_crosses.png')
```

Donnons quelques exemples pour démontrer en quoi la fonction `st_crosses()` diffère de la fonction  `st_intersects()`. Pour ce faire, considérons les géométries illustrées à la figure \@ref(fig:geo-conf2). 


```{r, warning=FALSE, echo=FALSE}
Abi_points <-st_cast(Abitibi, to = "POINT")
Abi_sub<-Abi_points[1600:2000,]
Abi_sub <- st_combine(Abi_sub)
Abi_trait <-st_cast(Abi_sub, to = "LINESTRING", group_or_split = TRUE)

B_points<-st_cast(B,to = "POINT")
B_sub<-B_points[337:387,]
B_sub <- st_combine(B_sub)
B_trait <-st_cast(B_sub, to = "LINESTRING", group_or_split = TRUE)

trait_noir<-A_trait
trait_bleu<-Abi_trait
trait_mauve<-B_trait
```

```{r geo-conf2, warning=FALSE, echo=FALSE, fig.align='center', fig.cap="Exemples illustrant la fonction `st_crosses()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  mapview(trait_bleu, color ="darkblue", lwd = 3, legend = FALSE)+
  mapview(trait_mauve, color = "purple", lwd = 3, legend = FALSE)
map_AB
```
Bien que toutes ces géométries s'intersectent, elles ne se croisent pas toutes. Vérifions d'abord la condition d'intersection &nbsp;:
```{r}
st_intersects(A,trait_bleu)
st_intersects(A,trait_mauve)
st_intersects(A,B)
```
Puis, la condition de croisement &nbsp;:
```{r}
st_crosses(A,trait_bleu)
st_crosses(A,trait_mauve)
st_crosses(A,B)
```
Le trait bleu ne croise pas le polygone A car l'intersection entre ces deux géométries est égale au trait bleu. De plus, les polygones A et B ne se croisent pas non plus car leur intersection forme un polygone. Un polygone a une dimension géométrique de 2, tout comme les polygones A et B. Ainsi, seul le trait mauve croise le polygone A. En effet, une partie seulement de sa géométrie intersecte le polygone A, le reste étant situé à l'extérieur du polygone.


####### `st_overlaps` {-}

La fonction `st_overlaps()` vérifie si l'intersection entre deux géométries de même dimension possède aussi la même dimension. De plus, cette intersection ne peut être égale à une des deux géométries interrogées. La figure \@ref(fig:st-overlaps) illustre différentes combinaisons de géométries qui satisfont à la condition de superposition.

```{r st-overlaps, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui se superposent. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '50%'}
knitr::include_graphics('Module7/images/st_overlaps.png')
```

Considérons les polygones A, B, ainsi que celui de l'Abitibi-Témiscamingue illustrés à la figure \@ref(fig:st-geo-conf3). 

```{r geo-conf3, warning=FALSE, echo=FALSE, fig.align='center', fig.cap="Exemples illustrant la fonction `st_overlaps()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
mapview(Abitibi, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + 
    mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) 
map_AB
```
Les polygones A et B satisfont la condition de superposition car leur intersection est aussi un polygone. Par ailleurs le polygone A et celui de l'Abitibi ne satisfont pas à la condition de superposition car l'intersection est identique au polygone de l'Abitibi-Témiscamingue. 

```{r}
st_overlaps(A,B)
st_overlaps(Abitibi,A)
```

####### `st_touches` {-}

La fonction `st_touches()` vérifie si deux objets `X` et `Y` ont au moins un point en commun sans toutefois que leurs interieurs s'intersectent. La figure \@ref(fig:st-touches) illustre différentes combinaisons de géométries qui se touchent.

```{r st-touches, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui se touchent. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '50%'}
knitr::include_graphics('Module7/images/st_touches.png')
```

Considérons par exemple les objets spatiaux illustrés à la figure \@ref(fig:st-geo-conf4) &nbsp;:

```{r st-geo-conf4, warning=FALSE, echo=FALSE, fig.align='center', fig.cap="Exemples illustrant la fonction `st_touches()`", out.width = '100%'}
Mauricie <- subset(regions_nad, Rgns_Ad == "Mauricie")

map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  #mapview(A_trait, color = "black", lwd = 3, legend = FALSE) +
  mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  
  mapview(point_bleu, col.regions = "blue", legend = FALSE)+
  mapview(point_vert, col.regions = "darkgreen", legend = FALSE)+
    mapview(trait_mauve, color = "purple", lwd = 3, legend = FALSE)
map_AB


mapreg<- mapview(Abitibi, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + 
    mapview(Mauricie, col.regions = "yellow", alpha.regions = 0.2, legend = FALSE)

leafsync::latticeView(map_AB, mapreg, ncol = 2)

```

La fonction `st_touches()` nous permet de vérifier que le polygone B, en rouge, touche au trait mauve et que le polygone A, en bleu, touche au point vert. Par ailleurs, la fonction confirme aussi que le polygone A ne touche pas au point bleu car ce sont leurs intérieurs qui s'intersectent. La même situation s'observe pour les polygones A et B qui partagent plus que leurs frontières. Cependant les polygones de l'Abitibi-Témiscamingue, en vert, et de la Mauricie, en jaune, s'intersectent seulement le long de leurs frontières et ainsi se touchent.

```{r, warning=FALSE}
st_touches(B, trait_mauve)
st_touches(A, point_vert)
st_touches(A, point_bleu)
st_touches(A,B)
st_touches(Abitibi,Mauricie)

```

####### `st_within`  et `st_contains` {-}

La fonction `st_within(X,Y)` vérifie si l'objet `X` est entièrement à l'intérieur de l'objet `Y`. À l'opposé, la fonction `st_contains(X,Y)` vérifie si l'objet `X` contient entièrement l'objet `Y`. L'ordre des arguments est donc important dans l'utilisation de ces deux fonctions.


La figure \@ref(fig:st-within) illustre différentes combinaisons de géométries qui sont contenues dans une autre géométrie.

```{r st-within, fig.align='center', echo=FALSE, fig.cap="Combinaisons de géométries qui contiennent ou sont contenues dans une autre géométrie. Image récupérée sur le site de documentation de **postgis**: http://postgis.net/workshops/postgis-intro/spatial_relationships.html", out.width = '50%'}
knitr::include_graphics('Module7/images/st_within.png')
```


```{r, warning = FALSE, echo = FALSE}
B_contour <- st_cast(B, to = "MULTILINESTRING")
contour_rose <- B_contour
B_points<-st_cast(B,to = "POINT")
B_sub<-B_points[40:90,]
B_trait <- st_combine(B_sub)
B_trait <-st_cast(B_trait, to = "LINESTRING", group_or_split = TRUE)

nouveau_trait_points<-st_union(B_sub[1,],point_jaune)
nouveau_trait<-st_cast(nouveau_trait_points, to = "LINESTRING")
trait_gros<-st_union(nouveau_trait, B_trait)
trait_vert<-trait_gros
```


Pour illustrer ces fonctions, considérons les objets spatiaux illustrés à la figure \@ref(fig:st-geo-conf5) &nbsp;:

```{r st-geo-conf5, warning=FALSE, echo=FALSE, fig.align='center', fig.cap="Exemples illustrant les fonctions `st_contains()` et `st_within()`.", out.width = '100%'}
map_AB <- mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE) + 
  mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE) +
  mapview(trait_bleu, color ="darkblue", lwd = 3, legend = FALSE)+
  mapview(point_bleu, col.regions = "blue", legend = FALSE)+
  mapview(contour_rose, color = "hotpink", lwd = 5, legend = FALSE)+
  mapview(trait_mauve, color = "purple", lwd = 3, legend = FALSE)+
  mapview(trait_vert, color = "seagreen", lwd = 3, legend = FALSE)

map_AB

```
La fonction `st_contains()` nous permet de vérifier que le polygone A, en bleu, contient le point bleu et le trait bleu. Par contre, le polygone A ne contient pas le trait mauve puisque ce dernier n'est pas entièrement à l'intérieur de A. De plus, le contour rose du polygone B contient entièrement le trait mauve. 


```{r}
st_contains(A, point_bleu)
st_contains(A, trait_bleu)
st_contains(A, trait_mauve)
st_contains(contour_rose, trait_mauve)
```
La fonction `st_contains()` comporte une subtilité qui peut être trompeuse. La condition `st_contains(X,Y)` est satisfaite, c'est-à-dire, l'object `X` contient l'objet `Y`, si et seulement si aucun points de `Y` se trouve à l'extérieur de `X`, et qu'au moins un point de `Y` se trouve à l'intérieur de `X`^{http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html}. En particulier, ceci signifie qu'un polygone ne contient jamais sa frontière. Ainsi, dans l'illustration de la figure \@ref(fig:st-geo-conf5), le polygone B, en rouge, ne contient pas le contour rose. Le polygone B ne contient pas non plus le trait mauve. Cependant, il contient le trait vert car ce dernier comporte des points à l'intérieur du polygone B.

```{r}
st_contains(B, contour_rose)
st_contains(B, trait_mauve)
st_contains(B, trait_vert)
```
La fonction `st_contains()` vérifie exactement la condition inverse de la fonction `st_within()`&nbsp;: 

```{r}
st_within(point_bleu, A)
st_within(trait_bleu, A)
st_within(trait_mauve, A)
st_within(trait_mauve, contour_rose)
st_within(contour_rose, B)
st_within(trait_mauve, B)
st_within(trait_vert, B)
```

Terminons cette sous-section par une remarque importante: 

>
> La fonction [`st_join()`](#fct_join), vue plus, qui permet de faire une jointure spatiale entre deux objets vectoriels s'appuie, par défaut, sur la fonction de confirmation `st_intersects()`. En effet, la fonction `st_join(x,y)` identifie la présence d'une intersection entre les éléments de `x` et de `y` puis assigne les attributs de `y` aux éléments de `x` qui satisfont cette condition d'intersection. Par aileurs, il est possible d'utiliser la fonction `st_join()` en utilisant d'autres opérations topologiques de confirmation que celle par défaut. En effet, il est possible de définir un troisième argument, `join`, pour préciser une autre opération comme `st_contains`, `st_touches`, `st_overlaps` etc. 
>

Donnons un exemple. Pour chaque régions administratives du Québec, déterminons les régions qui lui sont adjacentes. Il s'agit ici d'utiliser la fonction `st_join()` avec la condition `st_touches`&nbsp;:

```{r}
st_join(regions, regions, join = st_touches)
```

Cette fonction nous retourne un objet spatial composé de deux attributs. L'attribut de gauche, `Rgns_Ad.x` donne le nom de chaque polygone des régions administratives de `regions` alors que l'attribut de droite, `Rgns_Ad.y`, assigne à chacun de ces polygones, le nom d'une des régions administrives qui lui est voisine. Puisque chaque polygone possède plus d'une région voisine, leur nom et leur géométrie sont répétées pour chaque région voisine. 


##### Opérations de mesure {-}

Plusieurs fonctions de la bibliothèque `sf` permettent de calculer des mesures spatiales comme la distance, la superficie, ou la longueur. 

###### La fonction `st_distance()` {-}

La fonction `st_distance()` retourne la distance euclidienne entre deux objets spatiaux. Par exemple, nous pouvons utiliser cette fonction pour calculer la distance entre deux points. Calculons la distance qui sépare la ville de La Pocatière, dont nous avons isolé les coordonnées plus haut, et la ville de Rimouski.


```{r}
# Isoler le point correspondant aux coordonnées de la ville 
# de Rimouski à partir du shapefile des villes du Québec
rimouski <- subset(villes, toponyme == "Rimouski")
# Transformer rimouski dans le même SCR d'unité métrique que la_poc
rimouski_nad <-  st_transform(rimouski, crs = 32198)
# Calculer la distance
distance_lapoc_rimou <- st_distance(la_poc_nad, rimouski_nad)
distance_lapoc_rimou
```
 
La distance calculée est de `r as.integer(distance_lapoc_rimou[1])`&nbsp;m, soit environ `as.integer(round(distance_lapoc_rimou[1]/1000))` km. Notez que nous avons calculé la distance géométrique et non la distance que l'odomètre d'une voiture calculerait en voyageant sur l'autoroute entre La Pocatière et Rimouski. 

Observez que la fonction `st_distance()` retourne aussi l'unité de mesure, ici des mètres. En effet, l'objet retourné par cette fonction est de classe `units`&nbsp;:

```{r}
class(distance_lapoc_rimou)
```


Nous pouvons également utiliser la fonction `st_distance()` pour calculer la distance entre plusieurs points. Par exemple, considérons le shapefile `villes` et calculons la distance qui sépare La Pocatière de chacune des villes du Québec.

```{r}
# Transformer le SRC de villes
villes_nad <- st_transform(villes, crs = 32198)
# Calculer les distances
distance_la_poc_villes <- st_distance(la_poc_nad, villes_nad)
# Assigner le nom des villes
colnames(distance_la_poc_villes) <- villes$toponyme
# Les 10 premières entrées 
distance_la_poc_villes[1,1:10]
```
Ou encore, calculons la distance qui sépare chacune des villes du Québec &nbsp;:
```{r}
distance_villes_villes <- st_distance(villes_nad, villes_nad)
colnames(distance_villes_villes) <- villes$toponyme
rownames(distance_villes_villes) <- villes$toponyme
quelques_villes <- c(49, 154, 314, 549, 639)
distance_villes_villes[quelques_villes, quelques_villes]
```

Cette fois, la fonction `st_distance()` retourne une matrice pour laquelle chaque entrée correspond à la distance entre deux villes. Cette matrice est bien sûr symétrique et sa diagonale est nulle.


Nous pouvons aussi utiliser la fonction `st_distance()`pour calculer la distance entre un point et un polygone. Par exemple, calculons la distance entre le point correspondant au centre du polygone de l'Abitibi-Témiscamingue et de le polygone du Saguenay - Lac-Saint-Jean (voir la figure \@ref(fig:centroid_regions)).

```{r}
st_distance(centre_Abitibi, SagStJean)
```

Notez que pour calculer la distance entre un polygone et un point, ce dernier doit être situé à l'extérieur du polygone, sans quoi cette fonction retourne la valeur zéro &nbsp;:
```{r}
st_distance(centre_Abitibi, Abitibi)
```
La distance entre deux polygones se calcule de façon similaire. 

```{r}
st_distance(Abitibi, SagStJean, by_element = TRUE)
```
Cette mesure correspond à la plus petite distance séparant les deux polygones.


###### La fonction `st_area()` {-}

La fonction `st_area()` calcule la superficie d'un polygone. Calculons par exemple la superficie des polygones illustrés à la figure \@ref(fig:st-geo-conf5))&nbsp;:


```{r}
st_area(A)
st_area(B)
st_area(inter_AB)
```
Remarquez que les unités, ici des mètres carrés, sont fournies. L'objet retourné par la fonction `st_area()` est aussi de classe `units`&nbsp;:

```{r}
class(st_area(A))
```
La superficie d'objets spatiaux de dimension inférieure à deux est bien nulle&nbsp;:

```{r}
st_area(point_bleu)
st_area(trait_bleu)
```


###### La fonction `st_length()` {-}

La fonction `st_length()` calcule la longueur d'un objet spatial unidimensionnel (`LINESTRING`, `MULTILINESTRING`). 

```{r}
st_length(trait_bleu)
st_length(trait_mauve)
st_length(contour_rose)
```
Comme pour les fonctions `st_distance()` et `st_area()`, la fonction `st_length()` retourne un objet de classe `units`.


La fonction calcule une longueur nulle pour les polygones ou les points&nbsp;:
```{r}
st_length(A)
st_length(point_bleu)
```

###### La fonction `set_units` {-}

Il peut être pratique de changer les unités de mesure avec lesquelles nous travaillons. Par exemple, utiliser les mètres carrés lorsque nous traitons de larges étendues peut être encombrant. La fonction `set_units` de la bibliothèque `units` permet de transformer les unités de mesure d'un objet ou d'en assigner à un objet sans unités.

Par exemple, pour les unités de longueur&nbsp;:
```{r}
library(units)
L_m <- st_length(trait_bleu)
L_km <- set_units(L_m,km)
L_miles <- set_units(L_m, miles)

L_m
L_km
L_miles
```
Et, pour les unités d'aire&nbsp;:
```{r}
A_m2 <- st_area(A)
A_km2 <- set_units(A_m2, km2)
A_ha <- set_units(A_m2, ha) # 1 hectare (ha) mesure 100 m x 100 m

A_m2
A_km2
A_ha
```





<!--  POUR LA RESOLUTION  


Lorsque nous visualisons la position des villes, nous pouvons apercevoir que certaines villes se retrouvent à l'extérieur des limites administratives du Québec. 

```{r viz-villes2}
mapview(villes, legend = FALSE)
```

Nous voulons retirer ces villes de notre objet spatial `villes` pour retenir seulement celles présentes sur le territoire québécois (puisque notre question porte seulement sur le Québec). Pour accomplir cette étape, nous devons comparer deux sources d'informations spatiales: la position géographique des municipalités et les limites administratives des provinces. Plus précisément, pour chacune des municipalités, nous désirons connaÃ®tre sa province d'attache. Ce type d'opération s'appelle une **jointure spatiale**.

La première étape de cette jointure consiste à importer dans `R` le fichier des limites administratives des provinces canadiennes ([source](https://gadm.org/)) en utilisant à nouveau la fonction `st_read()`. 

```{r load-provinces, eval = FALSE}
chemin_provinces <- paste(chemin, "/provinces/provinces.shp", sep = "")
provinces <- st_read(chemin_provinces)
```

```{r load-provinces2, include = FALSE}
provinces <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/provinces/provinces_low_res.shp")

#provinces <- st_read("Module7/Module7_donnees/provinces/provinces_low_res.shp")
```

Remarquez que l'objet spatial `provinces` contient 13 polygones (*features*) et 10 attributs (*fields*). Ces 13 polygones correspondent aux limites géographiques des 10 provinces et 3 territoires du Canada. 

Vérifions visuellement l'importation en utilisant la fonction `mapview()`. Choisissons également d'ajouter une légende à la carte qui affiche le nom des provinces et des territories. Cette information est contenue dans l'attribut `NAME_1`. 

```{r viz-provinces}
mapview(provinces, zcol = "NAME_1")
```

Remarquez qu'en passant votre curseur sur chacun des polygones de la carte interactive, le nom de la province ou du territoire correspondant s'affiche. De plus, en cliquant sur l'un ou l'autre des polygones, la table des attributs s'affiche également. 


La deuxième étape consiste à vérifier que les deux objets possèdent le même système de projection. Les deux objets doivent utiliser le même système de coordonnées afin que la jointure spatiale puisse être réalisée. En utilisant la fonction `st_crs()`, nous pouvons effectuer un test logique en comparant les deux projections.

```{r check-proj-provinces}
st_crs(villes) == st_crs(provinces)
```

Le test logique d'égalité (`==`) nous renvoit la réponse `r st_crs(villes) == st_crs(provinces)` qui signifie que les deux objets ne disposent pas du même système de coordonnées. Nous devons donc reprojeté l'objet `provinces` dans le système de coordonnées de l'objet `villes` en utilisant la fonction `st_transform()`(retournez voir le [module 3](#SRC) pour davantage d'information sur les projections et le système de coordonnées de référence).

```{r transform-provinces}
provinces <- st_transform(provinces, st_crs(villes))
```

Enfin, la dernière étape consiste à effectuer la jointure entre les deux couches de données vectorielles avec comme objectif d'ajouter une colonne contenant le nom de la province à la table d'attributs de l'objet `villes`. La fonction `st_join()` permet d'associer le nom de la province (`POLYGON`) dans laquelle se retrouve chacune des municipalités (`POINT`) de l'objet `villes`.

```{r join-villes-provinces}
villes2 <- st_join(villes, provinces[,"NAME_1"])
head(villes2)
```

Pour chacune des villes, nous avons donc ajouté la province d'attache. L'objet spatial `villes` contient maintenant un attribut supplémentaire.
Renommons la colonne `NAME_1` (en position 2) par `province` pour que cet attribut porte un nom plus précis. 

```{r name-provinces-col}
names(villes)[2] <- "province"
```

-->

##### DU DEBUT.


La troisième étape consiste à charger la couche d'informations spatiales contenant les différentes aires récréatives du Québec. Cette information se trouve à l'intérieur d'une géodatabase disponible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000). Comme vu dans le module {#vec}, les géodatabase permettent de contenir plusieurs couches vectorielles. Nous devons donc lire la géodatabase et explorer les différentes couches afin de déterminer celle qui correspond aux aires récréatives.

```{r, eval = FALSE}
chemin_parcs_nationaux <- paste(chemin, "/parcs.gdb", sep = "")
st_layers(chemin_parcs_nationaux)
```

```{r list-layers, echo = FALSE, eval = TRUE}
st_layers("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/parcs.gdb") 
#st_layers("/Module7/data/parcs.gdb") 

```

Nous pouvons remarquer que les intitulés des différentes couches ne sont pas bien définis. Il faut donc prendre le temps de regarder la documentation accessible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000/resource/229322ef-eca2-4ae9-a511-ba599bc2745e). Ne vous inquiétez pas, je l'ai fait pour vous! En s'intéressant à la structure de données et à la nomenclature utilisée et décrite, nous pouvons déterminer que la couche `terpnq_s` correspond aux territoires des parc nationaux du Québec. Nous pouvons donc faire la lecture de la géodatabase avec la fonction `st_read()` en précisant cette couche à l'aide de l'argument `layer`.

```{r load-parcs, eval = FALSE}
chemin_parcs_nationaux <- paste(chemin, "/parcs.gdb", sep = "")
parcs_nationaux <- st_read(chemin_parcs_nationaux, layer = "terpnq_s")
```

```{r load-parcs2, echo = FALSE}
parcs_nationaux <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/parcs.gdb", layer = "terpnq_s") 
#parcs_nationaux <- st_read("Module7/data/parcs.gdb", layer = "terpnq_s") 

```


```{r visualisation}
carte_donnees <- mapview(municipalites, legend = FALSE) +                
                 mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)

carte_donnees@map
```
<br>

Notez que l'attribut "TRQ_NM_TER" de l'objet `parcs_nationaux` correspond au nom de chaque parc national.

#####


#### Lier À la question
Nous voulons maintenant filtrer l'objet `villes` afin de retenir seulement les municipalités dont la province d'attache est le Québec. Pour ce faire, nous utiliserons encore la fonction `subset()` ainsi que l'opérateur logique `==`.

```{r subset-villes}
villes_qc <- subset(villes, province == "Québec")
head(villes_qc)
```

Vous pouvez remarquer que le nouvel ensemble de points ainsi créé, c'est-à-dire l'objet spatial `villes_qc`, contient 600 points plutÃ´t que les 767 que contient l'objet `villes`. 
Vérifions que `villes_qc` contient bel et bien seulement les municipalités présentes sur le territoire québécois.

```{r viz-subset-villes}
mapview(villes_qc) + mapview(subset(provinces, NAME_1 == "Québec"))
```

Certains polygones comme celui de la province de Québec sont particulièrement fractionnés et possèdent de nombreuses Ã®les. Ce type de polygones ralentit parfois considérablement l'affichage à l'écran. Il peut alors être intéressant d'utiliser la fonction `st_simplify()` afin de réduire le niveau de détails des polygones et d'augmenter la vitesse d'affichage. 

```{r, eval = FALSE}
prov_quebec <-subset(provinces, NAME_1 == "Québec")
prov_quebec_simp <- st_simplify(st_transform(prov_quebec, crs = 32198), dTolerance = 50000)
mapview(prov_quebec_simp)
```


Notez que pour utiliser cette fonction, la projection de l'objet spatial doit être défini selon le système métrique (c-à-d en mètres). Pour nous en assurer, nous avons d'abord transformé l'objet spatial `prov_quebec` dans le système de coordonnées de référence NAD83,  dont le EPSG correspond à 32198, puisque l'unité de ce système est le mètre.

Attention si vous appliquez la transformation `st_simplify()`, vous perdez évidemment de la résolution spatiale. Cela pourrait avoir des conséquences sur le résultat de vos analyses.

Nous avons maintenant convenablement isolé les municipalités du Québec. La prochaine étape consiste à ajouter pour chacune des municipalités, la taille de sa population. 
<br>



#### Filtrer la table d'attributs {-}

L'objet spatial `villes_qc` contient donc l'attribut `toponyme` donnant le nom des municipalités et l'attribut `population' donnant la taille de la population de chaque municipalité. Ainsi, nous avons en main les deux pièces d'informations nécessaires pour obtenir une partie de la réponse à notre question: 

> Quelles sont les dix plus grandes villes du Québec? 

Pour sélectionner les 10 villes de plus grande population, une première étape consiste à ordonner l'attribut `population` contenu dans l'objet `villes_qc`. Pour ce faire, nous allons utiliser la fonction `order()`:

```{r}
villes_qc <- villes_qc[order(villes_qc$population, decreasing = TRUE), ]
```

L'objet `villes_qc` est maintenant ordonné de manière décroissante en fonction de la taille de la population des municipalités. Ainsi, les 10 premières lignes de cet objet correspondent aux 10 villes les plus grandes du Québec. On peut donc assigner les 10 premières lignes à un nouvelle objet intitulé `top10_villes`:

```{r}
top10_villes <- villes_qc[1:10, ]
top10_villes
```

Visualisons ce nouvel objet avec la fonction `mapview()`.

```{r viz-top10-villes}
mapview(top10_villes, zcol= "population")
```

### Pour chacune de ces municipalités, combien de parcs nationaux se retrouvent dans un rayon de 70&nbsp;km? 

La prochaine étape pour répondre à notre question consiste à tracer une zone tampon (`POLYGON`) de 70&nbsp;km de rayon autour de chaque municipalité (`POINT`). Ensuite, nous dénombrerons le nombre de parcs nationaux se trouvant dans ces zones. 

#### Créer des polygones (*buffer*) autour de points {-}

Nous allons créer un polygone circulaire de 70&nbsp;km autour de chaque municipalité. Une telle zone tampon s'appelle *buffer* en anglais. Pour se faire, nous allons utiliser la fonction `st_buffer(top10_villes, dist = 70e3)`. Le premier argument correspond à l'objet spatial à partir duquel nous créons les zones tampon, et le second argument correspond à la longueur du rayon des zones tampon en mètres (70&nbsp;km = 70e3&nbsp;m).


Avant de réaliser cette opération, nous devons vérifier que le système de coordonnées de référence de l'objet spatial `top10_villes` est défini en unité métrique. En effet, la distance de 70&nbsp;km pourrait être interprétée comme étant 70&nbsp;degrés si l'unité de la projection était en degré. Attention, cette erreur est très courante! Lorsque l'on veut calculer des distances euclidiennes, il faut toujours s'assurer que l'unité du système de projection est en mètre et non en degré.

```{r crs-top-villes}
st_crs(top10_villes)  
```

`UNIT["degree"...]` atteste que la projection est en degré. Nous allons donc reprojeter l'objet `top10_villes` dans le système de coordonnées de référence NAD83 qui est métrique et dont le EPSG est 32198. NAD83 correspond système de coordonnées *Conique conforme de Lambert*.

```{r transform-top-villes}
top10_villes_lcc <- st_transform(top10_villes, crs = 32198)
# On valide la projection de l'objet spatial
st_crs(top10_villes_lcc) == st_crs(32198)
```

Traçons à présent les zones tampon (*buffer*) autour des municipalités à l'aide de la fonction `st_buffer()` comme expliqué précédemment, et visualisons le résultat de cette opération

```{r buffer-top-villes}
top10_villes_buffer <- st_buffer(top10_villes_lcc, dist = 70e3) # 70 kms en mètres = 70e3
mapview(top10_villes_buffer, zcol = "toponyme", legend = FALSE)
```

Le package `sf` contient une multitude de fonctions correspondant à des opérations géométriques. Ces fonctions permettent de créer une nouvelle couche vectorielle en utilisant la géométrie d'une première couche. La Figure \@ref(fig:plot-geoOps) résume ces opérations géométriques. 

```{r plot-geoOps, fig.align='center', echo=FALSE, fig.cap="Illustration des opérations réalisables à partir du package `sf`. Extrait de l'aide mémoire de `sf` produit par Rstudio: https://github.com/rstudio/cheatsheets/raw/master/sf.pdf", out.width = '50%'}
knitr::include_graphics('Module7/images/geoOps.png')
```

<br>



<!-- A DEPLACER DANS SECTION ST_COORDINATE
Nous pouvons également déterminer les coordonnées géographiques de la municipalité de La Pocatière en utilisant la fonction `st_coordinates()`

```{r ex-coordinates}
st_coordinates(la_poc)
```

Le `X` correspond à la longitude et le `Y`, à la latitude. Cette fonction peut être appliquée sur l'ensemble des données spatiales de type vectoriel (`POLYGON`, `POINT`, `LINE`) et 
-->




#### Relations topologiques entre deux couches vectorielles {-}

Nous allons maintenant nous servir de l'objet spatial `top10_villes_buffer` contenant les zones tampon afin de dénombrer le nombre de parcs nationaux se retrouvant à l'intérieur de ces zones. On appelle cette famille d'opérations spatiales des interceptions.

<!--  DEPLACER DANS IMPORTER LES DONNNEES 
Pour réaliser cette étape, nous devons, dans un premier temps, charger la couche d'informations spatiales contenant les différentes aires récréatives du Québec. Cette information se trouve à l'intérieur d'une géodatabase téléchargeable depuis le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000). Comme vu dans le module {#vec}, les géodatabase permettent de contenir plusieurs couches vectorielles. Nous devons donc lire la géodatabase et explorer les différentes couches afin de déterminer laquelle est pertinente pour continuer notre analyse.

```{r, eval = FALSE}
chemin_parcs_nationaux <- paste(chemin, "/TRQ_100k.gdb", sep = "")
st_layers(chemin_parcs_nationaux)
```

```{r list-layers}
st_layers("Module7/data/parcs.gdb") 
```

Nous pouvons remarquer que les intitulés des différentes couches ne sont pas bien définis. Il faut donc prendre le temps de regarder la documentation accessible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000/resource/229322ef-eca2-4ae9-a511-ba599bc2745e). En s'intéressant à la structure de données et à la nomenclature utilisée et décrite, nous pouvons déterminer que la couche `terpnq_s` correspond aux territoires des parc nationaux du Québec. Nous pouvons donc faire la lecture de la géodatabase en précisant cette couche à l'aide de la fonction `st_read()`, puis la visualiser avec la fonction `mapview()` .

```{r load-parcs, eval = FALSE}
chemin_provinces <- paste(chemin, "/parcs.gdb", sep = "")
provinces <- st_read(chemin_provinces)
mapview(parcs_nationaux, zcol = "TRQ_NM_TER")
```

```{r load-parcs2, echo = FALSE}
parcs_nationaux <- st_read("Module7/data/parcs.gdb", layer = "terpnq_s") 
mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)
```


L'attribut "TRQ_NM_TER" correspond au nom de chaque parc national.
-->

Par curiosité, nous pouvons nous demander quelle fraction de la superficie du Québec est occupée par des parcs nationaux.




Pour réaliser un tel calcul, il faut obtenir la superficie de chacun des polygones correspondant aux parcs nationaux grÃ¢ce à la fonction `st_area()`. Encore une fois, nous devons d'abord nous assurer que le système de coordonnées de référence de l'objet spatial `parcs_nationaux` utilise des unités métriques, et reprojeter cette couche vers un autre CRS qui satisfait cette condition dans la négative.

```{r}
# Validation de l'unité du CRS
st_crs(parcs_nationaux)
# Puisque le CRS est en degré, nous le transformons en NAD83 (EPSG: 32198) tel que vu précédemment.
parcs_nationaux <- st_transform(parcs_nationaux, crs = 32198)
# Calcul de la superficie de chaque parcs nationaux.
st_area(parcs_nationaux)
# Calcul du pourcentage de couverture des parcs nationaux sur le territoire québécois
sum(st_area(parcs_nationaux)) / st_area(subset(provinces, NAME_1 == 'Québec')) * 100
```

La superficie des parcs nationaux du Québec représente donc `r round(sum(st_area(parcs_nationaux)) / st_area(subset(provinces, NAME_1 == 'Québec')) * 100, 2) `% de sa superficie totale.

Notez qu'il est possible à tout moment de changer l'unité de mesure en utilisant la fonction `set_units()` de la librairie `units`. 

```{r set-unit-parcs}
set_units(st_area(parcs_nationaux), km^2)
```


Retournons à présent à notre question originale, nous avons toutes les couches d'informations spatiales nécessaires pour répondre à la question: _Pour chacune des 10 plus grandes municipalités du Québec, combien de parcs nationaux se retrouvent dans un rayon de 70&nbsp;km?_. La fonction `st_intersects()` permet déterminer les parcs se trouvant partiellement ou non à l'intérieur de chacune des zones tampon. Avant de réaliser cette opération spatiale, nous devons nous assurer que les deux objets spatiaux (`top10_villes_buffer` et `parcs_nationaux`) utilisent le même système de coordonnées de référence.

```{r interceptions-buffer-parcs}
st_crs(top10_villes_buffer) == st_crs(parcs_nationaux)
```

Puisque la réponse est positive, nous pouvons utiliser la fonction `st_intersects()`:

```{r}
st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE) 
```

La fonction `st_intersects` avec l'argument `sparse = FALSE` retourne une matrice avec en ligne les zones tampons des 10 plus grandes villes (argument `x` ci-dessus) et en colonne, les 27 parcs nationaux du Québec (argument `y` ci-dessus). Pour chacune des combinaisons, la valeur boléenne renvoyée (`TRUE` ou `FALSE`) spécifie si les deux polygones se chevauchent (partiellement ou non). En utilisant l'argument `sparse = TRUE` (valeur par défault), il est possible d'obtenir un affichage plus minimaliste et lisible de la sortie de la fonction.

```{r interceptions-buffer-parcs2}
st_intersects(top10_villes_buffer, parcs_nationaux)
```

La fonction retourne cependant un objet de type `list` avec le numéro des polygones
spatiaux (ici ceux des parcs nationaux) satisfaisant la condition d'intersection. 

Pour bien comprendre l'opération spatiale réalisée, prenons l'exemple de la ville de Sherbrooke:

```{r interceptions-buffer-parcs3}
which(top10_villes_buffer$toponyme == 'Sherbrooke')
```

La fonction `which` retourne le numéro de ligne dans la table d'attributs de l'objet `top10_villes_buffer` satisfaisant la condition `toponyme == 'Sherbrooke'`. Nous consignons ensuite cet identifiant dans l'objet `id_buffer_sherbrooke`.

```{r interceptions-buffer-parcs4}
id_buffer_sherbrooke <- which(top10_villes_buffer$toponyme == 'Sherbrooke')
```

À présent, nous voulons déterminer les identifiants des parcs nationaux qui sont dans la zone tampon autour de la municipalité de Sherbrooke. Ceux-ci correspondent aux numéros des colonnes pour lesquels l'opération `st_intersects(top10_villes_buffer, parcs_nationaux,sparse = FALSE)` a retourné la valeur `TRUE` lorsque le numéro de la ligne correspond à l'identifiant de la ville de Sherbrooke. Nous pouvons déterminer facilement ces identifiants à partir du format `list` de la fonction `st_intersects()`

```{r interceptions-buffer-parcs5}
ids_parcs_sherbrooke <- st_intersects(top10_villes_buffer, parcs_nationaux)[[id_buffer_sherbrooke]]
```


Nous pouvons maintenant se servir des identifiants que nous venons de déterminer pour visualiser le polygone de la zone tampon autour de la municipalité de Sherbrooke (`id_buffer_sherbrooke`) ainsi que les polygones des parcs nationaux se trouvant dans cette zone tampon (`ids_parcs_sherbrooke`). 

```{r viz-interceptions-buffer-parcs}
mapview(parcs_nationaux[ids_parcs_sherbrooke, ], legend = FALSE) + 
mapview(top10_villes_buffer[id_buffer_sherbrooke, ], legend = FALSE, lwd = 2, color = "red")
```

Dans le cadre de se module, nous avons seulement utilisé la fonction `st_intersects`. Or, il existe une multitude d'autres opérateurs permettant de tester les relations topologiques entre deux couches de données spatiales. La figure \@ref(fig:plot-geoConf) résume ces opérations de vérifications géométriques. 

```{r plot-geoConf, fig.align='center', echo=FALSE, fig.cap="Illustration des opérations réalisables à partir du package `sf`. Extrait de l'aide mémoire de `sf` produit par Rstudio: https://github.com/rstudio/cheatsheets/raw/master/sf.pdf", out.width = '50%'}
knitr::include_graphics('Module7/images/geoConf.png')
```

Chacun de ces opérateurs utilisent la même approche que `st_intersects`. Ils retournent une liste (`sparse = TRUE`, l'argument par défault) avec les identifiants des polygones satisfaisant la conditions du test ou alors une matrice (`sparse = FALSE`) contenant des valeurs boléennes (`TRUE`/`FALSE`): le résultat du test pour chacune des combinaisons de polygones.

L'une des propriétés intéressante des valeurs boléennes (`TRUE` ou `FALSE`), renvoyées par la fonction `st_intersects`, est que la valeur `TRUE` peut être interprétée par R comme une valeur de 1 et `FALSE` comme une valeur de 0. Il est donc possible de réaliser des opérations mathématiques sur des valeurs boléennes. 

Par exemple, nous pouvons effectuer une sommation sur les lignes (zones tampons de chaque grandes municipalité) afin de déterminer combien de parcs nationaux se trouvent à l'intérieur des zones tampons (c-à-d combien d'éléments ont la valeur `TRUE`).

```{r top-villes-parcs}
rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE))

# Si l'on travaille avec l'argument sparse = FALSE:
lengths(st_intersects(x = top10_villes_buffer, y = parcs_nationaux))
```
La fonction `lengths()` permet d'obtenir la même information mais elle s'utilise sur le format `list`. `lengths()`  retourne la taille (longueur) des vecteurs (c-à-d le nombre de parcs) pour chacun des niveaux de la liste (chaque niveau étant une zone tampon).

Consignons à présent ces valeurs dans une nouvelle colonne de la table d'attributs de l'objet `top10_villes`.

```{r top-villes-parcs2}
top10_villes$nbr_parcs <- rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE))
```

Nous pouvons ordonner la table d'attributs de l'objet `top10_villes` en se basant sur la nouvelle colonne `nbr_parcs`. 

```{r top-villes-parcs3}
top10_villes <- top10_villes[order(top10_villes$nbr_parcs, decreasing = TRUE), ]
```

Finalement, il suffit d'afficher la table d'attributs de l'objet `top10_villes` afin d'obtenir la réponse tant attendu à notre question:

> Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70&nbsp;km)? 

```{r top-villes-parcs4}
top10_villes
```

Nous constatons que Sherbrooke et Saint-Jean-sur-Richelieu disposent toutes deux du plus grand nombre (4) de parcs nationaux dans un rayon de 70&nbsp;km. 


### Résolution de la question

Maintenant que nous avons appris les opérations de base pour manipuler les données vectorielles, nous sommes en mesure de répondre à la question demandée:

>
> **Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70 km)? **
>

Les données étant déjà importées, les étapes que nous devons résoudre sont les suivantes:


- Obtenir la taille de la population de chacune des municipalités.
- Filtrer ces municipalités pour retenir les 10 municipalités ayant la taille de population la plus importante.
- Lire la géodatabase du réseau de la SÉPAQ.
- Filtrer les aires récréatives pour retenir seulement les parcs nationaux.
- Tracer un polygone en forme de cercle (une zone tampon) avec 70 km de rayon autour de chacune des dix plus grandes villes.
- Pour chacun des polygones, compter le nombre de parcs présent dans la zone tampon de 70&nbsp;km.
- Déterminer la ville qui compte le plus grand nombre de parc dans la zone tampon qui lui est associée.


#####





<!---
NOTE: ICI on pourrait introduire la notion de cropping pour tenter de départager mais je pense qu'il y a déjà pas de stock alors 
-->

Dans le module 8, nous allons caractériser le profil d'élévation des 4 parcs de la région de Sherbrooke afin de trouver les meilleurs panoramas de la région.










## Exercice {#ex_map_vec}

- Pour chaque ville, qu'elle est le plus proche parc? (st_nearest_feature) *
- En utilisant les données des sentiers hivernaux de la SEPAQ (XXXX), parmi les 4 parcs de la région de Sherbrooke, lequel dispose de la plus longue distance de sentier de raquette? (Exercice plus intégrateur mais XXX)
- Départager les deux villes gagnantes en calculant le pourcentage de couverture des parcs nationaux dans la zone tampon de 70&nbsp;km. L'un des parcs de la région de Sherbrooke chevauche partiellement la zone tampon. Pour répondre à cette question, il faudra découper (`st_crop()`) ce polygone afin d'obtenir seulement la portion se retrouvant dans la zone tampon (XXX) 