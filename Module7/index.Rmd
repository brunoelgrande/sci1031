# Manipulation de données vectorielles {#manip_vec}

L'objectif principal de ce module est d'apprendre à manipuler des données vectorielles. 

À la fin de ce module vous saurez:

- Ajouter de nouveaux attributs à des données vectorielles, et également supprimer ou éditer des attributs.
- Filtrer des données vectorielles en se basant sur leurs attributs.
- Joindre spatialement deux ensembles de données vectorielles.
- Extraire un sous-ensemble de données pour l'intégrer aux attributs d'un second ensemble de données spatiales. 

Vous utiliserez les librairies suivantes:

- `sf`,
- `mapview`,
- `units`

Vous apprendrez à utiliser les fonctions suivantes:

- `subset()`
- `st_coordinates()`
- `class()`
- `merge()`
- `st_join()`
- `st_simplify()`
- `st_area()`
- `set_units()`
- `st_buffer()`
- `st_intercepts()`
- `rowSums()`
- `lengths()`

Dans la section [leçon](#lecon_manip_vec), vous utiliserez des données vectorielles portant sur les municipalités du Québec et sur les parcs nationaux de Société des établissements de plein air du Québec.

Dans la section Exercice, vous utiliserez <!-- A FAIRE -->


## Leçon {#lecon_manip_vec}


Au [module 4](#vec), vous avez appris les fonctions essentielles pour lire et visualiser des données spatiales vectorielles sous `R`. Le présent module vous amènera maintenant à manipuler des données vectorielles. 

Cette leçon est articulée autour d'une problématique qui nécessite de manipuler des données spatiales. Au cours des différentes étapes permettant d'explorer la problématique, vous apprendrez à utiliser diverses fonctions `R`. 

En effet, cette leçon vous amène à planifier vos vacances pour la prochaine saison estivale au Québec. Vous aimez la nature mais vous appréciez aussi la vie urbaine. Vous aimeriez visiter une grande ville et en même temps pouvoir séjourner dans divers parcs nationaux à proximité de celle-ci. Où se rendre? Quelle ville vous permettra de faire des escapades dans une diversité de parcs? 

Plus précisément, nous allons explorer le territoire Québécois en se posant la question suivante: 

>
> **Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70 km)? **
>

#### Télécharger les données {-}

Pour résoudre cette problématique, nous allons utiliser les données vectorielles relatives aux [municipalités du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives) et au réseau de la [Société des établissements de plein air du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000), la SÉPAQ. 

Afin de faciliter le téléchargement de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargées en cliquant sur un seul lien: [données pour le module 7](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Module7_donnees.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Module7_donnees` pour ce module, et dézippez-le. Le dossier `Quebec_Parcs` comprend trois sous-dossiers:

<!-- ajouter régions  -->

- `villes`,
- `parcs.gdb`,
- `provinces`.

 <!-- À VOIR probablement retirer et faire quelque chose de plus simple pour la partie exo  -->
Le sous-dossier `sentiers` correspond aux [sentiers de randonnées de la SÉPAQ](https://www.donneesquebec.ca/recherche/fr/dataset/sentiers-estivaux) et sera utilisé lors dans la section [exercice](#ex_manip_vec).


### Opérations de base 

Avant d'entamer la résolution de notre question, familiarisons-nous avec les opérations fréquemment utilisées sur les données matricielles.

#### Importer et visualiser les données {-}

La première étape consiste à charger les bibliothèques requises pour lire les données spatiales vectorielles (`sf`) et les visualiser (`mapview`). Nous chargeons aussi la bibliothèque `units` qui nous permettra de manipuler les unités de mesure utilisées pour le calcul d'aire ou de distance.

```{r load-libraries7, echo = FALSE, results='hide', warning = FALSE, message = FALSE}
library(sf)
library(mapview)
library(units)
```


La seconde étape consiste à lire le fichier *shapefile* de l'ensemble des municipalités du Québec en utilisant la fonction `st_read()` tel que vu dans le [module 4](#lire-shp).

```{r load-villes, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module7/Module7_donnees/"
chemin_muni <- paste(chemin, "/villes/villes.shp", sep = "")
municipalites <- st_read(chemin_muni)
```

```{r load-villes2, eval = TRUE, echo = FALSE}
municipalites <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/villes/villes.shp")
#municipalites <- st_read("Module7/data/villes/villes.shp")
```

Le *shapefile* a maintenant été importé dans un objet `R` de classe `sf` (c'est-à-dire un objet importé ou généré par l'utilisation de la librairie `sf`). Nous remarquons que la géométrie de cet object vectoriel est de type point. Plus précisément, cet objet contient 767 points (*features*) et 17 attributs (*fields*).

Pour en savoir davantage sur ces attributs de nature géographique, démographique et administrative, vous pouvez télécharger et consulter la [documentation] (https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives/resource/beb4472a-0edb-4824-b67e-40e20b425326) disponible sur le site de Données Québec.  


La troisième étape consiste à charger la couche d'informations spatiales contenant les différentes aires récréatives du Québec. Cette information se trouve à l'intérieur d'une géodatabase disponible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000). Comme vu dans le module {#vec}, les géodatabase permettent de contenir plusieurs couches vectorielles. Nous devons donc lire la géodatabase et explorer les différentes couches afin de déterminer celle qui correspond aux aires récréatives.

```{r, eval = FALSE}
chemin_parcs_nationaux <- paste(chemin, "/parcs.gdb", sep = "")
st_layers(chemin_parcs_nationaux)
```

```{r list-layers, echo = FALSE, eval = TRUE}
st_layers("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/parcs.gdb") 
#st_layers("/Module7/data/parcs.gdb") 

```

Nous pouvons remarquer que les intitulés des différentes couches ne sont pas bien définis. Il faut donc prendre le temps de regarder la documentation accessible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000/resource/229322ef-eca2-4ae9-a511-ba599bc2745e). Ne vous inquiétez pas, je l'ai fait pour vous! En s'intéressant à la structure de données et à la nomenclature utilisée et décrite, nous pouvons déterminer que la couche `terpnq_s` correspond aux territoires des parc nationaux du Québec. Nous pouvons donc faire la lecture de la géodatabase avec la fonction `st_read()` en précisant cette couche à l'aide de l'argument `layer`.

```{r load-parcs, eval = FALSE}
chemin_provinces <- paste(chemin, "/parcs.gdb", sep = "")
provinces <- st_read(chemin_provinces, layer = "terpnq_s")
```

```{r load-parcs2, echo = FALSE}
parcs_nationaux <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/parcs.gdb", layer = "terpnq_s") 
#parcs_nationaux <- st_read("Module7/data/parcs.gdb", layer = "terpnq_s") 

```

Nous pouvons maintenant visuellement valider que l'importation des données a bien été réussi en utilisant la fonction `mapview()` &nbsp;:

```{r visualisation}
carte_donnees <- mapview(municipalites, legend = FALSE) +                
                 mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)

carte_donnees@map
```
<br>

Notez que l'attribut "TRQ_NM_TER" de l'objet `parcs_nationaux` correspond au nom de chaque parc national.

Dans le précédent module portant sur la [cartographie](#carto), nous avons décrit plusieurs fonctionnalités de la bibliothèque `tmap` et avons démontré sa flexibilité et à sa capacité à produire des cartes de qualité. Toutefois, la bibliothèque `mapview` demeure fort utile lorsque nous souhaitons visualiser rapidement des données. Par défaut, la fonction `mapview()` affiche la carte d'OpenstreeMap en arrière-pan, ce qui permet de contextualiser facilement les données. 


De plus, les cartes produites avec `mapview()` sont interactives, permettant d'accéder directement à la table d'attributs des données vectorielles représentées. Par exemple, sur la carte ci-dessus, vous n'avez qu'à cliquer sur le marqueur géographique correspondant à chaque municipalité (point) ou à chaque parc (polygone) pour obtenir la liste des attributs et leur valeur. De plus, vous pouvez choisir d'afficher l'une ou l'autre des couches en cochant la couche désirée dans la fenêtre située dans le coin supérieur gauche. 


<br>

#### Opérations sur les attributs des données vectorielles {-}

##### Filter des attributs {-}

<!--  À arranger  -->
Une opération fréquente lorsque nous manipulons des données vectorielles est celle de filtrer les données. Par exemple, dans le *shapefile* `municipalites` que nous venons d'importer, nous pourrions vouloir sélectionner seulement certaines municipalités parmi les 767 répertoriées ou certains attributs parmi les 17. Nous pourrions aussi vouloir déterminer quelles municipalités possédent une valeur spécifique pour un attribut donné.

Dans les sous-sections qui suivent, nous présenterons des opérations qui permettent de filtrer des données vectorielles.

<br>


###### Sélectionner des attributs à partir de leur indice {-}

Les objets `sf` sont manipulables de la même façon qu'un `data.frame` (étant eux-mêmes des `data.frame`). Les attributs correspondent aux colonnes tandis que les entités spatiales (points, lignes ou polygones) correspondent aux lignes du `data.frame`.

Par exemple, l'objet spatial `municipalites` contient `r nrow(municipalites)` points correspondant chacun à une municipalité. La table d'attributs contient quant à elle `r ncol(municipalites)` colonnes correspondant à chacun des attributs permettant de décrire les municipalités. 

<!-- Logiquement, il faudrait retirer et garder juste sur les attributs  -->


Pour sélectionner un élément spatial spécifique d'un *shapefile*, nous pouvons simplement spécifier l'indice de la ligne qui lui est associée dans le `data.frame`. Par exemple :

```{r villes-ligne}
municipalites[1, ] # Pour accéder à la première ligne. 
```

Nous remarquons que le nombre de *features* (points) est maintenant de 1 (voir la première ligne de la sortie produite par `R`). En effet, puisque nous avons sélectionné le premier point de l'objet spatial `municipalites` nous avons exclu les 766 autres points. 

De la même manière, pour sélectionner un attribut spécifique, nous pouvons simplement spécifier l'indice de la colonne qui lui est associée :


```{r villes-col}
municipalites[, 2] # Pour accéder à la deuxième colonne. 
```

Nous remarquons également que le nombre de *fields* (colonnes) à diminuer à 1. 


####### Sélectionner des attributs à partir de leur nom {-}

Il est également possible de sélectionner un attribut particulier en spécifiant son nom.

Les colonnes disposent toujours d'un nom unique dans un `data.frame`. Nous pouvons afficher le nom des colonnes en utilisant la fonction `names()`&nbsp;:

```{r villes-nom}
names(municipalites)
```

Cette table contient 17 attributs. L'attribut nommé `HAP_NM_TOP` réfère au nom des municipalités. Notez que l’abréviation `TOP` signifie [toponyme](https://fr.wikipedia.org/wiki/Toponymie). 


Pour sélectionner cet attribut nous pouvons le faire simplement en utilisant son nom. Par exemple, en utilisant la syntaxe suivante :

```{r villes-col-nom}
municipalites[, "HAP_NM_TOP"]
# Ce qui revient également au même que la syntaxe suivante 
municipalites[, 13] 
# Puisque cette colonne est en treizième position.
```

Notez que la syntaxe familière `municipalites$HAP_NM_TOP` retourne un vecteur listant les valeurs de l'attribut `HAP_NM_TOP`, mais ne conserve pas la géométrie du *shapefile*:
```{r}
head(municipalites$HAP_NM_TOP)
```
Toutefois, la syntaxte précédente conserve la géométrie du *shapefile* et peut ainsi être utilisée pour définir un nouvel objet spatial. Par exemple, créons un nouveau *shapefile* qui contient seulement le nom des municipalités et leur position géographique :

```{r villes-topo-col2}
villes <- municipalites[,"HAP_NM_TOP"]
villes
```

Profitons-en pour renommer l'attribut `HAP_NM_TOP` afin d'avoir un intitulé de colonne plus explicite : 

```{r col-villes}
names(villes) <- c("toponyme", "geometry")
names(villes)
```
<!-- visualiser villes et en profiter pour noter que certaines villes ne sont pas à l'intérieur des frontières du QC  -->

##### Filtrer des valeurs d'attribut {-}
<!-- À arranger: ramener texte d'en haut  -->
On peut vouloir sélectionner un ou plusieurs éléments spatiaux d'un *shapefile* qui possèdent une valeur spécifique d'attribut. Cette opération peut être réalisée en utilisant les fonctions `subset()` ou `which()`.


###### Fonction `subset()` {-}

La fonction `subset()` n'est pas spécifique aux données spatiales, c'est une fonction générale de `R` qui retourne le sous-ensemble d'un vecteur, d'une matrice or d'un tableau de données qui satisfait une condition spécifique. 

Par exemple, nous pouvons utiliser la  fonction `subset()` pour filtrer le jeu de données `villes` afin d'obtenir la localisation d'une municipalité précise:

```{r viz-villes}
la_poc <- subset(villes, toponyme == "La Pocatière")
mapview(la_poc, legend = FALSE)
```

Notez que l'objet retourné, ici `la_poc`, est de même classe que l'objet filtré. Nous pouvons valider la classe d'un objet dans `R` avec la fonction `class()`. 

```{r ex-class}
class(la_poc)
```


###### Fonction `which()` {#fct_which} {-}

La fonction `which()` est aussi une fonction générale de `R`. Elle identifie la position des éléments de valeur `TRUE` dans un vecteur logique. Par exemple: 

```{r which}
#Exemple 1
which(c(TRUE, FALSE, TRUE, FALSE, TRUE))

#Exemple 2
which(c(1, 1, 2) == 2)
```

Maintenant, utilisons la fonction `which()` pour isoler la ville de La Pocatière:
```{r}
which(villes$toponyme == "La Pocatière")

```
Remarquez que la fonction `which()` retourne l'**indice** de la ligne dans la table d'attributs de l'objet `villes` satisfaisant la condition `toponyme == "La Pocatière"`. 

Nous pouvons ensuite consigner cet identifiant dans l'objet `id_la_poc` et l'utiliser pour déterminer la localisation de la ville de La Pocatière:

```{r interceptions-buffer-parcs4}
id_la_poc <- which(villes$toponyme == "La Pocatière")
villes[id_la_poc,]   
```
##### Ajouter des attributs {-}

Un autre type de manipulations fréquemment utilisé est celle d'enrichir un jeu de données vectorielles en lui ajoutant des attributs. Ces nouvelles informations peuvent provenir d'une base de données non-spatiales ou d'un autre *shapefile*.


Dans le cas de données non-spatiales, nous pouvons combiner les attributs désirés en utilisant l'opération `merge()` que nous définissons dans cette sous-section. Lorsque nous souhaitons ajouter des attributs provenant de données spatiales, nous devons faire une jointure spatiale en utilisant l'opération `st_join()`. Nous définirons `st_join()` dans la section suivante portant sur les [opérations spatiales sur les données vectorielles](#fct_join).


###### La fonction `merge()` {#fct_merge}{-}


La fonction `merge()` est une fonction générale de `R` qui sert à combiner deux tableaux de données différents en se servant de rangées ou de colonnes communes. 

Par exemple, ajoutons à chacune des municipilatés contenues dans le *shapefile* `villes` la taille de sa population. Cette information est contenue dans un fichier `csv` (`Module7_donnees/ville/population.csv`) et provient du [répertoire des municipalités du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/repertoire-des-municipalites-du-quebec/resource/19385b4e-5503-4330-9e59-f998f5918363). 

Nous allons d'abord importer ce fichier CSV dans `R` en utilisant la fonction `read.csv()`. Ensuite, nous sélectionnerons les colonnes pertinentes de ce tableau, et nous ajouterons ces informations aux attributs de l'objet spatial `villes`. 

```{r load-pop, eval = FALSE}
# On importe le fichier dans l'environnement de R
chemin_pop <- paste(chemin, "villes/population.csv", sep = "", encoding="UTF-8")
pop <- read.csv(chemin_pop)
```

```{r, eval = TRUE, echo = FALSE}
pop <- read.csv("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/villes/population.csv",encoding="UTF-8")
#pop <- read.csv("Module7/Module7_donnees/villes/population.csv",encoding="UTF-8")
```

Notez que la précision de l'encodage assure que les accents français sont bien importés lors de la lecture du document.

L'objet `pop` est un `data.frame` de `r ncol(pop)` colonnes décrivant un ensemble d'informations propres aux municipalités du Québec allant de leur nom jusqu'à la composition de leur conseil municipal. Toutes ces informations ne sont pas pertinentes pour le présent exercice. Pour faciliter la manipulation de ce tableau, sélectionnons seulement les colonnes suivantes:

- `munnom`: Nom de la ville. Cette colonne servira à faire la jointure entre l'objet spatial `villes` et l'objet `pop` contenant la taille des populations.
- `msuperf`: Superficie de la municipalité.
- `mpopul`: Taille de la population de la municipalité.

```{r select-pop-cols}
pop <- pop[, c("munnom", "msuperf", "mpopul")]
```

Le nouvel objet `pop` ainsi défini, contient seulement `r ncol(pop)` colonnes.

Nous voulons à présent fusionner l'objet `pop` avec l'objet spatial `villes` en utilisant la fonction `merge()`. Cette fusion entre les deux objets `villes` et `pop` sera réalisée sur les colonnes `toponyme` et `munnom` respectivement. Ces deux colonnes contiennent le nom des municipalités et agissent donc comme dénominateur commun entre les deux jeux de données. L'argument `all.x = TRUE` spécifie que toutes les entrées (POINT) de l'objet `villes` doivent être conservées. 

```{r}
#villes_qc <- merge(x = villes_qc, y = pop, by.x="toponyme", by.y="munnom",  all.x = TRUE)
villes_pop <- merge(x = villes, y = pop, by.x="toponyme", by.y="munnom",  all.x = TRUE)
``` 

Nous renommons encore une fois les colonnes pour qu'elles portent un nom plus représentatif de leur contenu. 

```{r}
names(villes_pop)
names(villes_pop)[2:3] <- c("superficie", "population")
names(villes_pop) 
```
Le nouveau *shapefile* `villes_pop` contient donc les mêmes éléments et les mêmes attributs que `villes` auxquels se sont ajoutés les attributs de `pop` pour les municipalités présentes à la fois dans `pop` et dans `villes`. 

```{r}
villes_pop
```


#### Opérations spatiales sur les données vectorielles {-}

Les opérations réalisées dans la section précédente sur les attributs des données vectorielles, telles `merge()`, `which()` et `subset()`, sont indépendantes de la composante spatiale des données. Si nous changions la géométrie des objets spatiaux décrits par les données vectorielles (par exemple en changeant les coordonnées des villes), ces opérations produiraient les mêmes résultats. Ce sont des fonctions générales pour manipuler des bases de données et qui s'appliquent aux `data.frame` des données vectorielles. 

Dans la présente section, nous verrons plutôt des opérations qui dépendent de la composante spatiale des données vectorielles. Ces opérations prennent en considération la géométrie des données et certaines peuvent aussi la transformer. 


##### Jointure et agrégation spatiale {-}

<!-- sur la base de la valeur de leurs attributs  -->


###### La fonction `st_join()`{#fct_join} {-}

La fonction `st_join()` de la bibliothèque `sf` permet de joindre à un *shapefile* de l'information provenant d'une autre couche spatiale. Cette opération constitue une jointure spatiale.

Par exemple, importons le *shapefile* des régions administratives du Québec, disponible dans le dossier `Module7_données`, et réalisons une jointure entre cette couche et la couche `villes`.

```{r load-reg, eval = FALSE}
# On importe le fichier dans l'environnement de R
chemin_reg <- paste(chemin, "regions_admin/regions_admin.shp", sep = "")
regions <- read.csv(chemin_reg)

# on observe le contenu de ce shaphefile
regions

# on le visualise
mapview(regions)
```

```{r}
regions <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/regions_admin/regions_admin.shp")
#regions <- st_read("Module7/Module7_données/regions_admin/regions_admin.shp")
head(regions)
```
Notez que les éléments de `regions` sont des polygones. Ces polygones possèdent un seul attribut, `"Rgns_Ad"`, correspondant au nom des régions administratives que ceux-ci délimitent. 

Nous allons maintenant faire une jointure spatiale entre `villes` et `regions` afin d'associer à chaque municipalité sa région administrative d'attache.

```{r, warning = FALSE}
villes_reg = st_join(villes, regions[ ,"Rgns_Ad"])
villes_reg
```
Remarquez que l'objet `villes_reg` est identique à l'objet `villes` mais contient un attribut supplémentaire: la colonne `Rgns_Ad`.

Il est important de préciser que la fonction `st_join()` nécessite que les deux couches spatiales à joindre utilisent le même système de coordonnées de référence (SCR).

Contrairement à la fonction `merge()` vue plus haut, la fonction `st_join()` est bien une opération spatiale. En effet, `st_join(x,y)` détermine s'il y a une intersection spatiale entre chaque éléments de l'objet de gauche (`x = villes`) et l'un ou l'autre des éléments de l'objet de droite (`y = regions`). Une intersection entre deux éléments spatiaux se produit lorsqu'ils partagent une même portion de l'espace. Ainsi, il y a une intersection entre le point associé à la ville de Shawinigan et le polygone associé à la région de la Mauricie. Par ailleurs, il n'y a pas d'intersection entre le point associé à la ville de Sherbrooke et le polygone de la Mauricie.

Lorsque `st_join(x,y)` identifie la présence d'une intersection entre deux éléments, elle assigne à l'élément de gauche la valeur de l'attribut (ici `"Rgns_Ad"`) de l'élément de droite. 

Lorsqu'il n'y a pas d'intersection entre deux éléments, la fonction assigne une valeur d'attribut `NA` à l'élément de gauche. Par exemple, les données `villes` contiennent des municipalités qui ne sont pas situées au Québec. On retrouve entre autres la ville d'Albany dans l'était de New York. Ainsi aucune région n'a pu être associée à ces villes.

```{r}
villes_reg[692,]
```
Si nous souhaitons que la fonction `st_join(x,y)` conserve seulement les éléments de `x` qui intersectent un ou l'autre des éléments de `y`, nous devons ajouter l'argument `left = FALSE` :

```{r, warning = FALSE}
villes_reg <- st_join(villes, regions[ ,"Rgns_Ad"], left = FALSE)
```
Visualisons le nouveau *shapefile* que nous venons de créer. Ce dernier contient seulement les municipalités à l'intérieur du territoire québécois.

```{r,  warning = FALSE}
mapview(villes_reg, legend = FALSE)
```
Notez que lorsque vous cliquez sur les points de la carte, la valeur de l'attribut  "Rngs_Ad" est maintenant également donnée.

Vous pouvez ainsi différencier visuellement les municipalités selon leur région administrative d'attache.
```{r,  warning = FALSE}
mapview(villes_reg, zcol = "Rgns_Ad", legend = FALSE)
```

Que se produit-il si nous inversons les arguments `villes` et `regions` dans la fonction `st-join()` &nbsp;? Dans ce cas, la jointure spatiale associe à chaque région les villes qui sont situées (c'est-à-dire intersectent) son territoire. Observons le résultat d'une telle jointure&nbsp;:

```{r, warning = FALSE}
reg_villes <- st_join(regions, villes[,"toponyme"], left = FALSE)
reg_villes
```
Le *shapefile* `reg_villes` est constitué des polygones de `regions`. Puisque plusieurs municipalités intersectent chaque région, le polygone d'une région donnée est dupliqué pour chacun des points. C'est-à-dire qu'une nouvelle ligne est ajouté pour chacune des intersections identifiées.



<!-- st-joint polygone
Pour démontrer ceci:
2. inner_join: all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned.

Similaire à ceci:
https://bookdown.org/robinlovelace/geocompr/spatial-operations.html#spatial-vec
 Like spatial subsetting, the default topological operator used by st_join() is st_intersects(). This can be changed with the join argument (see ?st_join for details). In the example above, we have added features of a polygon layer to a point layer. In other cases, we might want to join point attributes to a polygon layer. There might be occasions where more than one point falls inside one polygon. In such a case st_join() duplicates the polygon feature: it creates a new row for each match.

```{r}
mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)
names(parcs_nationaux)
parcs <- parcs_nationaux[, c(1,2,9)]
parcs <-st_transform(parcs, crs=st_crs(villes))
```

```{r}
parcs_reg = st_join(parcs, regions[ ,"Rgns_Ad"])
mapview(parcs_reg, zcol="Rgns_Ad")

```

-->

Remarquez que nous pouvons aussi utiliser la fonction `join_st()` en vue de créer un filtre spatial, par exemple avec la fonction `subset()` &nbsp;:

```{r}
villes_CN<- subset(villes_reg, Rgns_Ad=="Côte-Nord")
mapview(villes_CN, legend = FALSE)
```

Cette opération nous a permis de filtrer les municipalités du Québec pour retenir seulement celles situées dans la région administrative de la Côte-Nord.



###### La fonction `aggregate()`{-}

La fonction `aggregate()` de la bibliothèque `sf` permet d'agréger (c'est-à-dire de grouper) des éléments spatiaux d'une même couche de données vectorielles. 

Afin de démontrer comment opère la fonction `aggregate()` considérons d'abord l'objet `villes_reg_pop`. Ce dernier est formé par la jointure spatiale entre `villes_pop`, le *shapefile* associant à chaque municipalité la taille de sa population, et `regions`&nbsp;:
```{r, warning = FALSE}
villes_reg_pop <- st_join(villes_pop, regions[ ,"Rgns_Ad"], left = FALSE)
villes_reg_pop
```
L'objet `villes_reg_pop` associe à chaque municipalité la taille de sa population ainsi que sa région administrative. 
En agrégeant ensemble les villes d'une même région, il nous est possible de déterminer la taille de la population de cette région. C'est ce que nous allons faire en utilisant la fonction `aggregate()`&nbsp;:


```{r, warning = FALSE}
reg_pop<-aggregate(villes_reg_pop["population"], by = list(villes_reg_pop$Rgns_Ad), FUN = sum, na.rm = TRUE)
reg_pop
```

De façon générale, la fonction `aggregate(x, by, FUN)` comprend trois arguments:
- `x` est l'objet spatial que l'on souhaite agréger,
- `by` défini la condition utilisée pour regrouper les éléments de `x`,
- `FUN` défini la fonction selon laquelle l'attribut d'un groupement est calculé à partir des attributs des éléments agrégés.

Dans notre exemple, nous avons regroupé les points de l'objet spatial `villes_reg_pop["population"]` qui possèdent la même valeur d'attribut `"Rgns_Ad"`. Les points ainsi regroupés forment une géométrie multipoint. Chaque groupe de points est identifié par le nom de sa région administrative. L'attribut d'un groupe est calculé en faisant la somme (`FUN = sum`) des attributs des points qui le constituent. L'argument additionnel `na.rm = TRUE` précise que lors du calcul de la somme, les éléments dont l'attribut `"population"` prend la valeur `NA` doivent être ignorés. En effet, la population de quelques municipalités n'est pas définie dans cette base de données. Notez qu'une autre fonction aurait pu être utilisée, par exemple la moyenne, le maximum, le minimum, etc.

La condition `by` peut prendre différentes forment. Elle peut être définie par une liste de longueur égale au nombre d'éléments dans `x` (c'est-à-dire le même nombre de rangées). C'est de cette façon que nous l'avons définie plus haut. De plus, `by` peut prendre la forme d'un objet spatial dont la géométrie est utilisée pour grouper les éléments de `x`. Dans ce cas, la géométrie du nouvel objet créé par la fonction `aggregate()` est la même que l'objet `by`.


Donnons un exemple illustrant cette situation. Agrégeons maintenant les municipalités de l'objet `villes_pop["population"]` en utilisant directement l'objet `regions` constitué de polygones &nbsp;: 

```{r, warning = FALSE}
reg_pop2 <-aggregate(villes_pop["population"], by = regions, FUN = sum, na.rm = TRUE)
reg_pop2
```
Observez que les groupements sont maintenant des polygones, et non des multipoints. Par ailleurs le calcul de l'attribut `"population"` est le même. 

Une visualisation du nouvel objet `reg_pop2` permet d'illustrer les régions selon la taille de leur population&nbsp;:
```{r}
reg_pop2
```
<!-- SERA plus simple de parler de ça après avoir défini les fonctions topologiques -->
Il est important de préciser que les fonctions `st_join()` et `aggregate()` utilisent implicitement la fonction `st_intersects()`. Nous discuterons plus en détail de cette fonction ainsi que d'autres fonctions topologiques dans la sous-section sur les relations topologiques
NOTE utilise implicitement st_intersects
<!----------------------------------------------------------------->



##### Opérations géométriques {-}
<!-- faire une intro -->

Les opérations géométriques affectent la géométrie des objets vectoriels?


###### La fonction `st_simplify()` {#fct_simplify}{-}

Il est parfois utile de simplifier les objets vectoriels de types ligne ou polygone afin de produire des cartes à des échelles plus petites. La simplification permet de réduire l'utilisation de la mémoire, du disque, et de la bande passante. 

La fonction `st_simplify()` de la bibliothèque `sf` permet simplifier des objets vectoriels de types ligne ou polygone en réduisant le nombre de points que ceux-ci comprennent (souvenez-vous qu'une ligne est constituée d'une succession de points et qu'un polygone est constitué d'un ensemble de lignes). 

Cette fonction est basée sur l'algorithme de [Douglas-Peucker](https://fr.wikipedia.org/wiki/Algorithme_de_Douglas-Peucker). Décrire le fonctionnement de cet algorithme dépasse l'objectif de ce cours. Grosso modo, l'algorithme fait appel à un seuil de distance (le paramètre `dTolerance`) qu'il utilise pour transformer en ligne droite toute courbe qui dévie d'une ligne droite par une quantité moindre que ce seuil. Cette distance réflète en quelque sorte la résolution que nous souhaitons atteindre avec l'objet simplifié.

Le seuil de tolérance étant une distance, nous l'exprimons en mètres. Nous devons alors nous assurer que l'objet spatial à simplifier est dans un système de coordonnées métriques.

En guise d'exemple, simplifions le *shapefile* des régions administratives du Québec:

```{r, warning = FALSE }
regions_nad <- st_transform(regions, crs = 32198)
regions_simple_10 <- st_simplify(regions_nad, dTolerance = 10000) #10000m
regions_simple_30 <- st_simplify(regions_nad, dTolerance = 30000) #30000m
```


```{r, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La carte des régions administratives du Québec. Polygones originaux (à gauche) et polygones simplifiés avec un seuil faible (au centre) et un seuil élevé (à droite)."}
library(tmap)
map0<-tm_shape(regions_nad)+tm_fill(col="blue", alpha = 0.4) + tm_borders(col="black")
map1<-tm_shape(regions_simple_10)+tm_fill(col="blue", alpha = 0.4) + tm_borders(col="black")
map2<-tm_shape(regions_simple_30)+tm_fill(col="blue", alpha = 0.4) + tm_borders(col="black")

tmap_arrange(map0,map1,map2)
```

Remarquez que nous avons d’abord transformé l’objet spatial `regions` dans le système de coordonnées de référence NAD83, dont le EPSG correspond à 32198, puisque l’unité de ce système est le mètre.


###### La fonction `st_combine()` {#fct_combine}{-}

<!-- INTRO   -->



```{r}
villes_NQ <- subset(villes_reg, Rgns_Ad == "Nord-du-Québec") 
villes_NQ

villes_NQ_combo <- st_combine(villes_NQ)
villes_NQ_combo

villes_NQ_union <- st_union(villes_NQ)
```
```{r}
mapview(villes_NQ)
mapview(villes_NQ_combo)
```

```{r}
reg_combo<-st_combine(regions)
reg_combo
mapview(reg_combo)

reg_union<-st_union(regions)
reg_union
mapview(reg_union)
```



###### La fonction `st_cast()` {-}
<!--  INTRO  -->
Le terme anglais *cast* signifie plâtre ou moule en français.

La fonction `st_cast(x, to)` comprend deux arguments. Le premier argument, `x`, correspond à l'objet vectoriel dont on souhaite modifier la géométrie, alors que le second argument, `to` correspond à la géométrie que l'on souhaite lui attribuer. 

Donnons un exemple. Utilisons d'abord le *shapefile* `regions` pour isoler le polygone de la région administrative de la Mauricie grâce à la fonciton `subset()`&nbsp;:
```{r}
Mauricie <- subset(regions,Rgns_Ad=="Mauricie")
Mauricie
```
Nous observons que l'objet `Mauricie` est bel et bien de type *polygone*. Maintenant utilisons la fonction `st_cast()` pour transformer la géométrie de cet objet en type *multilignes* et *multipoints*  &nbsp;:

```{r, warning=FALSE}
Mauricie_lines <- st_cast(Mauricie, to = "MULTILINESTRING")
Mauricie_lines
Mauricie_pts<-st_cast(Mauricie, to = "MULTIPOINT")
Mauricie_pts
```
Nous observons que les deux nouveaux objets vectoriels ont bel et bien la géométrie souhaitée ()

```{r ex_cast1, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La fonction `st_cast()` a été utilisée pour transformer le polygone de la Mauricie (gauche) en multilignes (centre) et en multipoints (droite)."}

Lines<- mapview(Mauricie_lines, legend = FALSE)
Poly <- mapview(Mauricie, legend = FALSE)
Points<-mapview(Mauricie_pts, legend = FALSE)

# Visualisons les trois cartes côte à côte
leafsync::latticeView(Poly,Lines,Points, ncol = 3)
```

Dans cet exemple, nous avons en quelque sorte "dissous" la géométrie d'un polygone en lignes puis en points. Or, la fonction `st_cast()` peut également servir à "consolider" des géométries.

En guise d'exemple, considérons l'objet `villes_NQ_combo` que nous avons créé plus haut avec la fonction `st_combine()`&nbsp;:

```{r}
villes_NQ_combo
```
Cet objet possède une géométrie multipoint où chaque point correspond à une municipalité du Nord-du-Québec.

Utilisons la fonction `st_cast()` pour transformer la géométrie de cet objet en ligne et en polygone &nbsp;:

```{r}
villes_NQ_lines<-st_cast(villes_NQ_combo, to = "LINESTRING")
villes_NQ_lines


villes_NQ_pol<-st_cast(villes_NQ_combo, to = "POLYGON")
villes_NQ_pol
```
```{r ex_cast2, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="La fonction `st_cast()` a été utilisée pour transformer les villes du Nord-du-Québec de multipoints (gauche) en ligne (centre) et en polygone (droite).}

Points <- mapview(villes_NQ_combo, legend = FALSE)
Lines <- mapview(villes_NQ_lines, legend = FALSE)
Pol <- mapview(villes_NQ_pol, legend = FALSE)

leafsync::latticeView(Points,Lines,Pol, ncol = 3)
```




###### La fonction `st_buffer()` {-}

Une zone tampon est un polygone dont les frontières sont définies par une distance donnée autour d'un objet vectoriel. Une zone tampon peut être créée autour de tout objet vectoriel, que ce soit des points, des lignes ou des polygones. 

La création de zones tampons est généralement réalisée pour répondre à des questions de nature géographique. Par exemple, combien de garderies se situent à une distance de 2&nbsp;km de ma maison&nbsp;? Ou encore, combien de stations services se situent à moins de 500&nbsp;m de la route menant de Chelsey à Cantley, en Outaouais&nbsp;? 


La fonction `st_buffer()` de la bibliothèque `sf` permet de créer des zones tampons - appelées *buffers* en anglais. Cette fonction comprend obligatoirement deux arguments. Le premier correspond à l'objet vectoriel autour du quel nous souhaitons construire une zone tampon, et le deuxième argument défini la distance sur laquelle la zone tampon s'étendra autour de l'objet vectoriel. Comme pour la fonction `st_simplify()`, l'objet vectoriel auquel nous appliquons la fonction `st_buffer()` doit être exprimé dans un CRS d'unité de mesure métrique.

Construisons des zones tampons autour de la ville de La Pocatière, que nous avons isolée plus haut, en considérant deux distances différentes:

```{r}
la_poc_nad <- st_transform(la_poc, crs = 32198)
la_poc_tampon10 <- st_buffer(la_poc_nad, dist = 10e3)
la_poc_tampon50 <- st_buffer(la_poc_nad, dist = 50e3)
```

```{r buffer_lapoc, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="Deux zones tampons de 10 km (bleu) et de 50 km autour de la ville de La Pocatière"}
# library(tmap)
# new_bb <- bb(regions_nad, xlim = c(0.25, 0.75), ylim = c(0.25, 0.75), relative = TRUE)
# mapQ <- tm_shape(regions_nad, bbox = new_bb) + tm_fill()
# mapdot <- tm_shape(la_poc_nad) + tm_dots(col="black")
# map1 <- mapQ + mapdot + tm_layout(outer.margins = c(0.3, 0.3, 0.3, 0.3)) + 
#  tm_shape(la_poc_tampon10) + tm_fill(col="blue", alpha = 0.4) + tm_borders(col="blue")
# map2<- mapQ + mapdot + tm_layout(inner.margins = c(0.3, 0.3, 0.3, 0.3)) +
#   tm_shape(la_poc_tampon50) + tm_fill(col="green", alpha = 0.4) + tm_borders(col="green")
# 
# 
# tmap_arrange(map1,map2)
mapview(la_poc_tampon50, col.regions = "green", alpha.regions = 0.2, legend = FALSE) + mapview(la_poc_tampon10, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE)
```

Notez que l'expression `e3` correspond au chiffre 1000 (c'est-à-dire 10 exposent 3).

Maintenant, construisons des zones tampons autour des régions administratives de l'Abitibi-Témiscamingue et de la Mauricie. Utilisons d'abord la fonction `subset()` pour isoler les polygones correspondants à ces régions à partir du *shapefile* `regions_nad` dont l'unité de mesure du CRS est le mètre. 


```{r}
# Isoler les polygones des deux régions
Abitibi <- subset(regions_nad, Rgns_Ad == "Abitibi-Témiscamingue")
SagStJean <- subset(regions_nad, Rgns_Ad == "Saguenay - Lac-Saint-Jean")

# Calculer une zone tampon pour chacun des polygones
Abitibi_tampon10 <- st_buffer(Abitibi, dist = 20e3)
SagStJean_tampon50 <- st_buffer(SagStJean, dist = 70e3)
```

```{r buffer_regions, echo = FALSE, warning = FALSE, fig.align = 'left', out.width = '100%', fig.cap="Une zone tampon de 20 km autour de la région administrative de l'Abitibi-Témicamingue et une zone tampon de 70 km autour de la Mauricie."}
mapview(SagStJean_tampon50, col.regions = "green", alpha.regions = 0.2, legend = FALSE) +
mapview(SagStJean, col.regions = "green", alpha.regions = 0.4, legend = FALSE) + 
mapview(Abitibi_tampon10, col.regions = "blue", alpha.regions = 0.2,  legend = FALSE) +
mapview(Abitibi, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE) 
```

Notez que la zone tampon d'un polygone inclue le polygone d'origine. C'est-à-dire que ce n'est pas simplement une bordure autour du polygone. 



###### La fonction `st_centroid` {-}

Trouver le centre d'un polygone

```{r}
centre_Abitibi <- st_centroid(Abitibi)
centre_Abitibi
centre_SagStJean <- st_centroid(SagStJean)
centre_SagStJean
```

Retourne un objet vectoriel qui conserve les attributs.

```{r}
mapview(centre_SagStJean, col.regions = "red", legend = FALSE) +
mapview(SagStJean, col.regions = "green", alpha.regions = 0.4, legend = FALSE) + 
mapview(centre_Abitibi, col.regions = "red" ,legend = FALSE) +
mapview(Abitibi, col.regions = "blue", alpha.regions = 0.4,  legend = FALSE) 
```


###### Les fonctions de découpage spatial {-}
```{r}
A <- st_buffer(Abitibi, dist = 80e3)
B <- st_buffer(SagStJean, dist = 100e3)
```

```{r}
mapview(A, col.regions = "blue", alpha.regions = 0.2, legend = FALSE)+
mapview(B, col.regions = "red", alpha.regions = 0.2, legend = FALSE)
```

<!-- | arranger: faire tout ensemble  -->

###### La fonction `st_union()` {-}

```{r}
unionAB <- st_union(A,B)
mapview(unionAB)
```
###### La fonction `st_intersection()` {-}

```{r}
inter <- st_intersection(A,B)
mapview(union, col.regions = "grey", alpha.regions = 0.2) + mapview(inter)
```
```{r}
diff_AB <- st_difference(A,B)
mapview(diff)
diff_BA <- st_difference(B,A)
sym_diff <- st_sym_difference(A,B)
mapview(sym_diff)
```
Dire quelque chose sur la fonction st_combine.

##### Opérations topologiques {-}
<!-- OU faire tout ensemble comme plus haut pour d/coupage spatial.   -->

###### La fonction st_intersects {-}
<!-- A comprendre   -->


```{r}
centre_A <- st_centroid(A)
centre_B <- st_centroid(B)
centre_unionAB <- st_centroid(unionAB)
```
```{r}
st_intersects(B, centre_A)
st_intersects(B, centre_B)
st_intersects(B, centre_unionAB)
st_intersects(A,B)
```
<!-- A FAIRE  -->

###### La fonction st_disjoint {-}
###### La fonction st_touches {-}
###### La fonction st_within {-}
###### La fonction st_is_within_distance {-}


##### Opérations de mesures {-}

###### La fonction `st_distance()` {-}

```{r}
rimouski <- subset(villes, toponyme == "Rimouski")
rimouski_nad <-  st_transform(rimouski, crs = 32198)
distance_lapoc_rimou <- st_distance(la_poc_nad, rimouski_nad)
distance_lapoc_rimou
```
Observez que la fonction `st_distance()` retourne aussi l'unité de mesure, ici des mètres.
La distance calculée est de `r as.integer(distance_lapoc_rimou[1])`&nbsp;m, soit environ `as.integer(round(distance_lapoc_rimou[1]/1000))` km. Notez que nous avons calculée la distance géométrique et non la distance que l'odomètre d'une voiture calculerait en voyageant sur l'autoroute entre La Pocatière et Rimouski. 

```{r}
villes_nad <- st_transform(villes, crs = 32198)
distance_la_poc_villes <- st_distance(la_poc_nad, villes_nad)
distance_la_poc_villes[1,1:10]
```

Entre un point et un polygone

```{r}
st_distance(centre_Abitibi, SagStJean)
```

Le point doit être à l'extérieur du polygone, sans quoi cette fonction retourne la valeur zéro.
```{r}
st_distance(centre_Abitibi, Abitibi)
```


```{r}
st_distance(Abitibi, SagStJean)
```

###### La fonction `st_area()` {-}

```{r}
st_area(Abitibi)
st_area(Abitibi_tampon10)
```
###### La fonction `st_length()` {-}

Créer une ligne qui va de centre abitibi à centre st-jean à la_poc
Mesurer la longueur

```{r}
c_abitibi<-as.vector(st_coordinates(centre_Abitibi))
c_sagstjean <- as.vector(st_coordinates(centre_SagStJean))
mat<- rbind(c_abitibi, c_sagstjean)

a<-st_join(centre_Abitibi, centre_SagStJean)
                     
                     
                     
                     
```
###### La fonction `set_units` {-}



<!--  POUR LA RESOLUTION  


Lorsque nous visualisons la position des villes, nous pouvons apercevoir que certaines villes se retrouvent à l'extérieur des limites administratives du Québec. 

```{r viz-villes2}
mapview(villes, legend = FALSE)
```

Nous voulons retirer ces villes de notre objet spatial `villes` pour retenir seulement celles présentes sur le territoire québécois (puisque notre question porte seulement sur le Québec). Pour accomplir cette étape, nous devons comparer deux sources d'informations spatiales: la position géographique des municipalités et les limites administratives des provinces. Plus précisément, pour chacune des municipalités, nous désirons connaître sa province d'attache. Ce type d'opération s'appelle une **jointure spatiale**.

La première étape de cette jointure consiste à importer dans `R` le fichier des limites administratives des provinces canadiennes ([source](https://gadm.org/)) en utilisant à nouveau la fonction `st_read()`. 

```{r load-provinces, eval = FALSE}
chemin_provinces <- paste(chemin, "/provinces/provinces.shp", sep = "")
provinces <- st_read(chemin_provinces)
```

```{r load-provinces2, include = FALSE}
provinces <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module7/Module7_donnees/provinces/provinces_low_res.shp")

#provinces <- st_read("Module7/Module7_donnees/provinces/provinces_low_res.shp")
```

Remarquez que l'objet spatial `provinces` contient 13 polygones (*features*) et 10 attributs (*fields*). Ces 13 polygones correspondent aux limites géographiques des 10 provinces et 3 territoires du Canada. 

Vérifions visuellement l'importation en utilisant la fonction `mapview()`. Choisissons également d'ajouter une légende à la carte qui affiche le nom des provinces et des territories. Cette information est contenue dans l'attribut `NAME_1`. 

```{r viz-provinces}
mapview(provinces, zcol = "NAME_1")
```

Remarquez qu'en passant votre curseur sur chacun des polygones de la carte interactive, le nom de la province ou du territoire correspondant s'affiche. De plus, en cliquant sur l'un ou l'autre des polygones, la table des attributs s'affiche également. 


La deuxième étape consiste à vérifier que les deux objets possèdent le même système de projection. Les deux objets doivent utiliser le même système de coordonnées afin que la jointure spatiale puisse être réalisée. En utilisant la fonction `st_crs()`, nous pouvons effectuer un test logique en comparant les deux projections.

```{r check-proj-provinces}
st_crs(villes) == st_crs(provinces)
```

Le test logique d'égalité (`==`) nous renvoit la réponse `r st_crs(villes) == st_crs(provinces)` qui signifie que les deux objets ne disposent pas du même système de coordonnées. Nous devons donc reprojeté l'objet `provinces` dans le système de coordonnées de l'objet `villes` en utilisant la fonction `st_transform()`(retournez voir le [module 3](#SRC) pour davantage d'information sur les projections et le système de coordonnées de référence).

```{r transform-provinces}
provinces <- st_transform(provinces, st_crs(villes))
```

Enfin, la dernière étape consiste à effectuer la jointure entre les deux couches de données vectorielles avec comme objectif d'ajouter une colonne contenant le nom de la province à la table d'attributs de l'objet `villes`. La fonction `st_join()` permet d'associer le nom de la province (`POLYGON`) dans laquelle se retrouve chacune des municipalités (`POINT`) de l'objet `villes`.

```{r join-villes-provinces}
villes2 <- st_join(villes, provinces[,"NAME_1"])
head(villes2)
```

Pour chacune des villes, nous avons donc ajouté la province d'attache. L'objet spatial `villes` contient maintenant un attribut supplémentaire.
Renommons la colonne `NAME_1` (en position 2) par `province` pour que cet attribut porte un nom plus précis. 

```{r name-provinces-col}
names(villes)[2] <- "province"
```

-->

#### Lier À la question
Nous voulons maintenant filtrer l'objet `villes` afin de retenir seulement les municipalités dont la province d'attache est le Québec. Pour ce faire, nous utiliserons encore la fonction `subset()` ainsi que l'opérateur logique `==`.

```{r subset-villes}
villes_qc <- subset(villes, province == "Québec")
head(villes_qc)
```

Vous pouvez remarquer que le nouvel ensemble de points ainsi créé, c'est-à-dire l'objet spatial `villes_qc`, contient 600 points plutôt que les 767 que contient l'objet `villes`. 
Vérifions que `villes_qc` contient bel et bien seulement les municipalités présentes sur le territoire québécois.

```{r viz-subset-villes}
mapview(villes_qc) + mapview(subset(provinces, NAME_1 == "Québec"))
```

Certains polygones comme celui de la province de Québec sont particulièrement fractionnés et possèdent de nombreuses îles. Ce type de polygones ralentit parfois considérablement l'affichage à l'écran. Il peut alors être intéressant d'utiliser la fonction `st_simplify()` afin de réduire le niveau de détails des polygones et d'augmenter la vitesse d'affichage. 

```{r, eval = FALSE}
prov_quebec <-subset(provinces, NAME_1 == "Québec")
prov_quebec_simp <- st_simplify(st_transform(prov_quebec, crs = 32198), dTolerance = 50000)
mapview(prov_quebec_simp)
```


Notez que pour utiliser cette fonction, la projection de l'objet spatial doit être défini selon le système métrique (c-à-d en mètres). Pour nous en assurer, nous avons d'abord transformé l'objet spatial `prov_quebec` dans le système de coordonnées de référence NAD83,  dont le EPSG correspond à 32198, puisque l'unité de ce système est le mètre.

Attention si vous appliquez la transformation `st_simplify()`, vous perdez évidemment de la résolution spatiale. Cela pourrait avoir des conséquences sur le résultat de vos analyses.

Nous avons maintenant convenablement isolé les municipalités du Québec. La prochaine étape consiste à ajouter pour chacune des municipalités, la taille de sa population. 
<br>



#### Filtrer la table d'attributs {-}

L'objet spatial `villes_qc` contient donc l'attribut `toponyme` donnant le nom des municipalités et l'attribut `population' donnant la taille de la population de chaque municipalité. Ainsi, nous avons en main les deux pièces d'informations nécessaires pour obtenir une partie de la réponse à notre question: 

> Quelles sont les dix plus grandes villes du Québec? 

Pour sélectionner les 10 villes de plus grande population, une première étape consiste à ordonner l'attribut `population` contenu dans l'objet `villes_qc`. Pour ce faire, nous allons utiliser la fonction `order()`:

```{r}
villes_qc <- villes_qc[order(villes_qc$population, decreasing = TRUE), ]
```

L'objet `villes_qc` est maintenant ordonné de manière décroissante en fonction de la taille de la population des municipalités. Ainsi, les 10 premières lignes de cet objet correspondent aux 10 villes les plus grandes du Québec. On peut donc assigner les 10 premières lignes à un nouvelle objet intitulé `top10_villes`:

```{r}
top10_villes <- villes_qc[1:10, ]
top10_villes
```

Visualisons ce nouvel objet avec la fonction `mapview()`.

```{r viz-top10-villes}
mapview(top10_villes, zcol= "population")
```

### Pour chacune de ces municipalités, combien de parcs nationaux se retrouvent dans un rayon de 70&nbsp;km? 

La prochaine étape pour répondre à notre question consiste à tracer une zone tampon (`POLYGON`) de 70&nbsp;km de rayon autour de chaque municipalité (`POINT`). Ensuite, nous dénombrerons le nombre de parcs nationaux se trouvant dans ces zones. 

#### Créer des polygones (*buffer*) autour de points {-}

Nous allons créer un polygone circulaire de 70&nbsp;km autour de chaque municipalité. Une telle zone tampon s'appelle *buffer* en anglais. Pour se faire, nous allons utiliser la fonction `st_buffer(top10_villes, dist = 70e3)`. Le premier argument correspond à l'objet spatial à partir duquel nous créons les zones tampon, et le second argument correspond à la longueur du rayon des zones tampon en mètres (70&nbsp;km = 70e3&nbsp;m).


Avant de réaliser cette opération, nous devons vérifier que le système de coordonnées de référence de l'objet spatial `top10_villes` est défini en unité métrique. En effet, la distance de 70&nbsp;km pourrait être interprétée comme étant 70&nbsp;degrés si l'unité de la projection était en degré. Attention, cette erreur est très courante! Lorsque l'on veut calculer des distances euclidiennes, il faut toujours s'assurer que l'unité du système de projection est en mètre et non en degré.

```{r crs-top-villes}
st_crs(top10_villes)  
```

`UNIT["degree"...]` atteste que la projection est en degré. Nous allons donc reprojeter l'objet `top10_villes` dans le système de coordonnées de référence NAD83 qui est métrique et dont le EPSG est 32198. NAD83 correspond système de coordonnées *Conique conforme de Lambert*.

```{r transform-top-villes}
top10_villes_lcc <- st_transform(top10_villes, crs = 32198)
# On valide la projection de l'objet spatial
st_crs(top10_villes_lcc) == st_crs(32198)
```

Traçons à présent les zones tampon (*buffer*) autour des municipalités à l'aide de la fonction `st_buffer()` comme expliqué précédemment, et visualisons le résultat de cette opération

```{r buffer-top-villes}
top10_villes_buffer <- st_buffer(top10_villes_lcc, dist = 70e3) # 70 kms en mètres = 70e3
mapview(top10_villes_buffer, zcol = "toponyme", legend = FALSE)
```

Le package `sf` contient une multitude de fonctions correspondant à des opérations géométriques. Ces fonctions permettent de créer une nouvelle couche vectorielle en utilisant la géométrie d'une première couche. La Figure \@ref(fig:plot-geoOps) résume ces opérations géométriques. 

```{r plot-geoOps, fig.align='center', echo=FALSE, fig.cap="Illustration des opérations réalisables à partir du package `sf`. Extrait de l'aide mémoire de `sf` produit par Rstudio: https://github.com/rstudio/cheatsheets/raw/master/sf.pdf", out.width = '50%'}
knitr::include_graphics('Module7/images/geoOps.png')
```

<br>



<!-- A DEPLACER DANS SECTION ST_COORDINATE
Nous pouvons également déterminer les coordonnées géographiques de la municipalité de La Pocatière en utilisant la fonction `st_coordinates()`

```{r ex-coordinates}
st_coordinates(la_poc)
```

Le `X` correspond à la longitude et le `Y`, à la latitude. Cette fonction peut être appliquée sur l'ensemble des données spatiales de type vectoriel (`POLYGON`, `POINT`, `LINE`) et 
-->




#### Relations topologiques entre deux couches vectorielles {-}

Nous allons maintenant nous servir de l'objet spatial `top10_villes_buffer` contenant les zones tampon afin de dénombrer le nombre de parcs nationaux se retrouvant à l'intérieur de ces zones. On appelle cette famille d'opérations spatiales des interceptions.

<!--  DEPLACER DANS IMPORTER LES DONNNEES 
Pour réaliser cette étape, nous devons, dans un premier temps, charger la couche d'informations spatiales contenant les différentes aires récréatives du Québec. Cette information se trouve à l'intérieur d'une géodatabase téléchargeable depuis le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000). Comme vu dans le module {#vec}, les géodatabase permettent de contenir plusieurs couches vectorielles. Nous devons donc lire la géodatabase et explorer les différentes couches afin de déterminer laquelle est pertinente pour continuer notre analyse.

```{r, eval = FALSE}
chemin_parcs_nationaux <- paste(chemin, "/TRQ_100k.gdb", sep = "")
st_layers(chemin_parcs_nationaux)
```

```{r list-layers}
st_layers("Module7/data/parcs.gdb") 
```

Nous pouvons remarquer que les intitulés des différentes couches ne sont pas bien définis. Il faut donc prendre le temps de regarder la documentation accessible sur le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000/resource/229322ef-eca2-4ae9-a511-ba599bc2745e). En s'intéressant à la structure de données et à la nomenclature utilisée et décrite, nous pouvons déterminer que la couche `terpnq_s` correspond aux territoires des parc nationaux du Québec. Nous pouvons donc faire la lecture de la géodatabase en précisant cette couche à l'aide de la fonction `st_read()`, puis la visualiser avec la fonction `mapview()` .

```{r load-parcs, eval = FALSE}
chemin_provinces <- paste(chemin, "/parcs.gdb", sep = "")
provinces <- st_read(chemin_provinces)
mapview(parcs_nationaux, zcol = "TRQ_NM_TER")
```

```{r load-parcs2, echo = FALSE}
parcs_nationaux <- st_read("Module7/data/parcs.gdb", layer = "terpnq_s") 
mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)
```


L'attribut "TRQ_NM_TER" correspond au nom de chaque parc national.
-->

Par curiosité, nous pouvons nous demander quelle fraction de la superficie du Québec est occupée par des parcs nationaux.




Pour réaliser un tel calcul, il faut obtenir la superficie de chacun des polygones correspondant aux parcs nationaux grâce à la fonction `st_area()`. Encore une fois, nous devons d'abord nous assurer que le système de coordonnées de référence de l'objet spatial `parcs_nationaux` utilise des unités métriques, et reprojeter cette couche vers un autre CRS qui satisfait cette condition dans la négative.

```{r}
# Validation de l'unité du CRS
st_crs(parcs_nationaux)
# Puisque le CRS est en degré, nous le transformons en NAD83 (EPSG: 32198) tel que vu précédemment.
parcs_nationaux <- st_transform(parcs_nationaux, crs = 32198)
# Calcul de la superficie de chaque parcs nationaux.
st_area(parcs_nationaux)
# Calcul du pourcentage de couverture des parcs nationaux sur le territoire québécois
sum(st_area(parcs_nationaux)) / st_area(subset(provinces, NAME_1 == 'Québec')) * 100
```

La superficie des parcs nationaux du Québec représente donc `r round(sum(st_area(parcs_nationaux)) / st_area(subset(provinces, NAME_1 == 'Québec')) * 100, 2) `% de sa superficie totale.

Notez qu'il est possible à tout moment de changer l'unité de mesure en utilisant la fonction `set_units()` de la librairie `units`. 

```{r set-unit-parcs}
set_units(st_area(parcs_nationaux), km^2)
```


Retournons à présent à notre question originale, nous avons toutes les couches d'informations spatiales nécessaires pour répondre à la question: _Pour chacune des 10 plus grandes municipalités du Québec, combien de parcs nationaux se retrouvent dans un rayon de 70&nbsp;km?_. La fonction `st_intersects()` permet déterminer les parcs se trouvant partiellement ou non à l'intérieur de chacune des zones tampon. Avant de réaliser cette opération spatiale, nous devons nous assurer que les deux objets spatiaux (`top10_villes_buffer` et `parcs_nationaux`) utilisent le même système de coordonnées de référence.

```{r interceptions-buffer-parcs}
st_crs(top10_villes_buffer) == st_crs(parcs_nationaux)
```

Puisque la réponse est positive, nous pouvons utiliser la fonction `st_intersects()`:

```{r}
st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE) 
```

La fonction `st_intersects` avec l'argument `sparse = FALSE` retourne une matrice avec en ligne les zones tampons des 10 plus grandes villes (argument `x` ci-dessus) et en colonne, les 27 parcs nationaux du Québec (argument `y` ci-dessus). Pour chacune des combinaisons, la valeur boléenne renvoyée (`TRUE` ou `FALSE`) spécifie si les deux polygones se chevauchent (partiellement ou non). En utilisant l'argument `sparse = TRUE` (valeur par défault), il est possible d'obtenir un affichage plus minimaliste et lisible de la sortie de la fonction.

```{r interceptions-buffer-parcs2}
st_intersects(top10_villes_buffer, parcs_nationaux)
```

La fonction retourne cependant un objet de type `list` avec le numéro des polygones
spatiaux (ici ceux des parcs nationaux) satisfaisant la condition d'intersection. 

Pour bien comprendre l'opération spatiale réalisée, prenons l'exemple de la ville de Sherbrooke:

```{r interceptions-buffer-parcs3}
which(top10_villes_buffer$toponyme == 'Sherbrooke')
```

La fonction `which` retourne le numéro de ligne dans la table d'attributs de l'objet `top10_villes_buffer` satisfaisant la condition `toponyme == 'Sherbrooke'`. Nous consignons ensuite cet identifiant dans l'objet `id_buffer_sherbrooke`.

```{r interceptions-buffer-parcs4}
id_buffer_sherbrooke <- which(top10_villes_buffer$toponyme == 'Sherbrooke')
```

À présent, nous voulons déterminer les identifiants des parcs nationaux qui sont dans la zone tampon autour de la municipalité de Sherbrooke. Ceux-ci correspondent aux numéros des colonnes pour lesquels l'opération `st_intersects(top10_villes_buffer, parcs_nationaux,sparse = FALSE)` a retourné la valeur `TRUE` lorsque le numéro de la ligne correspond à l'identifiant de la ville de Sherbrooke. Nous pouvons déterminer facilement ces identifiants à partir du format `list` de la fonction `st_intersects()`

```{r interceptions-buffer-parcs5}
ids_parcs_sherbrooke <- st_intersects(top10_villes_buffer, parcs_nationaux)[[id_buffer_sherbrooke]]
```


Nous pouvons maintenant se servir des identifiants que nous venons de déterminer pour visualiser le polygone de la zone tampon autour de la municipalité de Sherbrooke (`id_buffer_sherbrooke`) ainsi que les polygones des parcs nationaux se trouvant dans cette zone tampon (`ids_parcs_sherbrooke`). 

```{r viz-interceptions-buffer-parcs}
mapview(parcs_nationaux[ids_parcs_sherbrooke, ], legend = FALSE) + 
mapview(top10_villes_buffer[id_buffer_sherbrooke, ], legend = FALSE, lwd = 2, color = "red")
```

Dans le cadre de se module, nous avons seulement utilisé la fonction `st_intersects`. Or, il existe une multitude d'autres opérateurs permettant de tester les relations topologiques entre deux couches de données spatiales. La figure \@ref(fig:plot-geoConf) résume ces opérations de vérifications géométriques. 

```{r plot-geoConf, fig.align='center', echo=FALSE, fig.cap="Illustration des opérations réalisables à partir du package `sf`. Extrait de l'aide mémoire de `sf` produit par Rstudio: https://github.com/rstudio/cheatsheets/raw/master/sf.pdf", out.width = '50%'}
knitr::include_graphics('Module7/images/geoConf.png')
```

Chacun de ces opérateurs utilisent la même approche que `st_intersects`. Ils retournent une liste (`sparse = TRUE`, l'argument par défault) avec les identifiants des polygones satisfaisant la conditions du test ou alors une matrice (`sparse = FALSE`) contenant des valeurs boléennes (`TRUE`/`FALSE`): le résultat du test pour chacune des combinaisons de polygones.

L'une des propriétés intéressante des valeurs boléennes (`TRUE` ou `FALSE`), renvoyées par la fonction `st_intersects`, est que la valeur `TRUE` peut être interprétée par R comme une valeur de 1 et `FALSE` comme une valeur de 0. Il est donc possible de réaliser des opérations mathématiques sur des valeurs boléennes. 

Par exemple, nous pouvons effectuer une sommation sur les lignes (zones tampons de chaque grandes municipalité) afin de déterminer combien de parcs nationaux se trouvent à l'intérieur des zones tampons (c-à-d combien d'éléments ont la valeur `TRUE`).

```{r top-villes-parcs}
rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE))

# Si l'on travaille avec l'argument sparse = FALSE:
lengths(st_intersects(x = top10_villes_buffer, y = parcs_nationaux))
```
La fonction `lengths()` permet d'obtenir la même information mais elle s'utilise sur le format `list`. `lengths()`  retourne la taille (longueur) des vecteurs (c-à-d le nombre de parcs) pour chacun des niveaux de la liste (chaque niveau étant une zone tampon).

Consignons à présent ces valeurs dans une nouvelle colonne de la table d'attributs de l'objet `top10_villes`.

```{r top-villes-parcs2}
top10_villes$nbr_parcs <- rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE))
```

Nous pouvons ordonner la table d'attributs de l'objet `top10_villes` en se basant sur la nouvelle colonne `nbr_parcs`. 

```{r top-villes-parcs3}
top10_villes <- top10_villes[order(top10_villes$nbr_parcs, decreasing = TRUE), ]
```

Finalement, il suffit d'afficher la table d'attributs de l'objet `top10_villes` afin d'obtenir la réponse tant attendu à notre question:

> Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70&nbsp;km)? 

```{r top-villes-parcs4}
top10_villes
```

Nous constatons que Sherbrooke et Saint-Jean-sur-Richelieu disposent toutes deux du plus grand nombre (4) de parcs nationaux dans un rayon de 70&nbsp;km. 


### Résolution de la question

Maintenant que nous avons appris les opérations de base pour manipuler les données vectorielles, nous sommes en mesure de répondre à la question demandée:

>
> **Parmi les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70 km)? **
>

Les données étant déjà importées, les étapes que nous devons résoudre sont les suivantes:


- Obtenir la taille de la population de chacune des municipalités.
- Filtrer ces municipalités pour retenir les 10 municipalités ayant la taille de population la plus importante.
- Lire la géodatabase du réseau de la SÉPAQ.
- Filtrer les aires récréatives pour retenir seulement les parcs nationaux.
- Tracer un polygone en forme de cercle (une zone tampon) avec 70 km de rayon autour de chacune des dix plus grandes villes.
- Pour chacun des polygones, compter le nombre de parcs présent dans la zone tampon de 70&nbsp;km.
- Déterminer la ville qui compte le plus grand nombre de parc dans la zone tampon qui lui est associée.


#####





<!---
NOTE: ICI on pourrait introduire la notion de cropping pour tenter de départager mais je pense qu'il y a déjà pas de stock alors 
-->

Dans le module 8, nous allons caractériser le profil d'élévation des 4 parcs de la région de Sherbrooke afin de trouver les meilleurs panoramas de la région.










## Exercice {#ex_map_vec}

- Pour chaque ville, qu'elle est le plus proche parc? (st_nearest_feature) *
- En utilisant les données des sentiers hivernaux de la SEPAQ (XXXX), parmi les 4 parcs de la région de Sherbrooke, lequel dispose de la plus longue distance de sentier de raquette? (Exercice plus intégrateur mais XXX)
- Départager les deux villes gagnantes en calculant le pourcentage de couverture des parcs nationaux dans la zone tampon de 70&nbsp;km. L'un des parcs de la région de Sherbrooke chevauche partiellement la zone tampon. Pour répondre à cette question, il faudra découper (`st_crop()`) ce polygone afin d'obtenir seulement la portion se retrouvant dans la zone tampon (XXX) 