# Manipulation de données vectorielles {#manip_vec}

L'objectif principal de ce module est d'apprendre à manipuler des données vectorielles. 

À la fin de ce module vous saurez:

- Comment ajouter de nouveaux attributs et également comment supprimer ou éditer ces attributs.
- Comment filtrer des données vectorielles en se basant sur leur attributs (ex. isoler les villes possédants le plus de populations).
- Comment joindre spatialement deux vecteurs.
- Comment extraire les données d'un vecteur spatial pour l'intégrer aux attributs d'une seconde couche.

Vous utiliserez les librairies suivantes:

- `sf`
- `mapview`
- `units`

Vous apprendrez à utiliser les fonctions suivantes:

- `subset`
- `st_coordinates`
- `class`
- `merge`
- `st_join`
- `st_simplify`
- `st_area`
- `set_units`
- `st_buffer`
- `st_intercepts`
- `rowSums`
- `lengths`

Dans la section Leçon, vous utiliserez les données portant sur les municipalités du Québec,

Dans la section Exercice, vous utiliserez XXXXX

```{r load-libraries7, echo = FALSE, results='hide', warning = FALSE, message = FALSE}
library(sf)
library(mapview)
library(units)
```


## Leçon

Dans le cadre de cette leçon, nous allons préparer notre saison estivale de vacances en explorant les données vectorielles relatives aux municipalités du Québec (POINTS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives)), au réseau de la SÉPAQ (POLYGONS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000)) et enfin aux sentiers de randonnées de la SÉPAQ (LINESTRINGS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/sentiers-estivaux)).

Afin de faciliter l'importation de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargez en cliquant sur un seul lien: [données sur les parcs et les villes du Québec](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Quebec_Parcs.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Donnees` pour ce module, et dézippez-le. Le dossier `Quebec_Parcs` comprend trois sous-dossiers:

- `villes`
- `parcs`
- `sentiers`

### Opérations de base {-}

Afin de se familiariser avec la manipulation de données vectorielles, nous allons exporer le territoire Québécois en se posant la question suivante: 

> Parmis les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70km)? 

Pour répondre à cette question, il faut réaliser un ensemble d'opérations spatiales:

- Obtenir et importer dans R le fichier spatial comprenant l'ensemble des villes/municipalités du Québec.
- Obtenir la taille de population pour chacune de ces municipalités.
- Filtrer ces municipalités pour isoler les 10 municipalités ayant la taille de population la plus importante.
- Importer le fichier spatial du réseau récréatif du Québec.
- Filter les aires récréatives pour obtenir seulement les parcs nationaux.
- Tracer un polygon en forme de cercle (une zone tampon) avec 70 kms de rayon autours des dix plus grandes villes.
- Pour chacun des polygons, compter le nombre de parcs présent dans la zone tampon de 70 kms.

Dans ce chapitre, nous allons passer à travers chacune de ces étapes.

### Quelles sont les 10 plus grandes villes du Québec? {-}

#### Importation des données {-}

La première étape consiste à lire le fichier *shapefile* de l'ensemble des villes du Québec (tel que vu dans le [chapitre 2](#lire-shp)) afin d'isoler les dix plus grandes villes du Québec.

```{r, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module7/Donnees/"
chemin_villes <- paste(chemin, "/villes/villes.shp", sep = "")
villes <- st_read(chemin_villes)
```

```{r, eval = TRUE, echo = FALSE}
villes <- st_read("Module7/data/villes/villes.shp")
```

Le *Shapefile* a maintenant été importé dans un objet R de classe `sf` avec 
On peut maintenant visuellement valider que l'importation a bien été réussi:

```{r}
mapview(villes, legend = FALSE)
```

En cliquant sur chacun des marqueurs géograĥiques (dans la carte interactive), vous pouvez accéder à la table d'attributs. 
Pour en savoir davantage sur les attributs, voici le lien vers la [la documentation](https://www.donneesquebec.ca/recherche/fr/dataset/base-de-donnees-geographiques-et-administratives/resource/beb4472a-0edb-4824-b67e-40e20b425326).  Cette table d'attribut contient une diversité d'informations plus ou moins importante pour répondre à notre question. On veut donc nettoyer la table d'attribut en sélectionnant la ou les colonnes pertinentes pour notre besoin. 

#### Sélectionner des attributs (colonnes) ou des localisations (lignes) spécifiques {-}

L'objet spatial `villes` contient `r nrow(villes)` points correspondant chacun à une ville. La table d'attributs contient quant à elle `r ncol(villes)` colonnes / attributs décrivant les villes. L'attribut qui nous intéresse ici est la colonne `HAP_NM_TOP` contenant le nom de la ville. L'abbréviation `TOP` signifie [toponymie](https://fr.wikipedia.org/wiki/Toponymie) qui sert à référencer les noms propres désignant un lieu. On veut donc extraire la colonne `HAP_NM_TOP` contenant le nom (toponyme) des villes du Québec. 

Les objets `sf` sont manipulables de la même facon qu'un `data.frame` (étant eux-même des `data.frame`). Pour accéder à une colonne ou à une ligne spécifique dans la table d'attributs, il faut utiliser la syntaxe suivante:

```{r}
villes[1,] # Pour accéder à la première ligne. 
```

Vous pouvez remarquer que le nombre de *features* (points) à diminuer à 1. Maintenant, regardons comment séléctionner une seule colonne:

```{r}
villes[,2] # Pour accéder à la deuxième colonne. 
```

Vous pouvez remarquer que le nombre de *fields* (colonnes) à diminuer à 1. 

Les colonnes disposent toujours d'un nom unique dans un `data.frame`. On peut afficher les noms de colonnes et extraire une colonne spécifique par son nom de la manière suivante:

```{r}
names(villes)
villes[,"HAP_NM_TOP"]
# Ce qui revient également au même que la syntaxe suivante 
villes[,13] 
# Puisque cette colonne est en treizième position.
```

On souhaite à présent sélectionner le nom de la ville/municipalité car les autres attributs ne sont pas pertinent pour répondre à notre question.

```{r}
villes <- villes[,"HAP_NM_TOP"]
villes
```

On veut maintenant renommer la colonne afin d'avoir un intitulé de colonne plus explicite. 

```{r}
names(villes)
names(villes) <- c("toponyme", "geometry")
```

Si l'on veut vérifier qu'une ville se retrouve bel et bien présente dans le jeu de données, on peut utiliser la fonction `subset()` afin de filtrer les points basé sur la valeur d'un attribut:

```{r}
la_poc <- subset(villes, toponyme == "La Pocatière")
mapview(la_poc, legend = FALSE)
```

On peut également récupérer les coordonnées géographiques de la ville de La Pocatière en applicant la fonction `st_coordinates()`

```{r}
st_coordinates(la_poc)
```

Le `X` correspond à la longitude et le `Y`, à la latitude. Cette fonction peut être appliqué sur l'ensemble des données spatiales de type vectorielles (`POLYGON`, `POINT`, `LINE`) et appartenant à la classe d'objet `sf` (c.a.d généré/importé par le package `sf`). On peut valider la classe d'un objet dans R avec la fonction `class()`. 

```{r}
class(la_poc)
```

#### Joindre l'information d'une autre couche spatiale: `st_join()` {-}

On vérifiant visuellement la position des villes, on peut s'apercevoir que certaines villes se retrouvent à l'extérieur des limites administratives du Québec. 

```{r}
mapview(villes, legend = FALSE)
```

On veut filtrer ces villes pour obtenir seulement celles présentes au Québec (puisque notre question porte seulement sur le Québec). Pour accomplir cette étape, on va croiser deux sources d'informations spatiales: les villes et les limites administratives des provinces. Pour chacune des villes, on veut connaitre la province d'attache. Ce type d'opération s'appelle une jointure spatiale.

La première étape de cette jointure consiste à importer le fichier des limites administratives des provinces ([source](https://gadm.org/)). 

```{r, eval = FALSE}
chemin_provinces <- paste(chemin, "/provinces_CA/provinces_CA.shp", sep = "")
provinces <- st_read(chemin_provinces)
```

```{r, include = FALSE}
provinces <- st_read("Module7/data/provinces_CA/provinces_CA.shp")
```

On peut maintenant vérifier visuellement l'importation. En examinant la table d'attributs de l'objet `provinces` (en cliquant sur un des polygons de la carte interactive ci-dessous), on remarque que l'attribut `NAME_1` contient le nom des provinces. 

```{r}
mapview(provinces, zcol = "NAME_1")
```

La deuxième étape consiste à vérifier que les deux objets possèdent le même système de projection. Les deux objets doivent se retrouver dans le même système de coordonnées afin que la jointure spatiale puisse être réalisé. En utilisant la fonction `st_crs()`, on peut effectuer un test logique en comparant les deux projections.

```{r}
st_crs(villes) == st_crs(provinces)
```

Le test logique d'égalité (`==`) nous renvoit la réponse `r st_crs(villes) == st_crs(provinces)` qui signifie que les deux objets ne disposent pas du même système de coordonnées. On doit donc reprojeté (`st_transform()`) l'objet `provinces` dans le système de coordonnées de `villes` (voir [chapitre 3](#SRC) pour davantage d'information sur les projections et système de coordonnées).

```{r}
provinces <- st_transform(provinces, st_crs(villes))
```

Enfin, la dernière étape consiste à effectuer la jointure entre les deux couches avec comme objectif d'ajouter une colonne contenant le nom de la province à la table d'attributs de l'objet `villes`. La fonction `st_join()` permet de déterminer dans quelle province (`POLYGON`) se retrouve chacun des villes (`POINT`).

```{r}
villes <- st_join(villes, provinces[,"NAME_1"])
head(villes)
```

Pour chacune des villes, nous avons donc ajouté la province d'attache 
On peut renommer la colonne `NAME_1` (en position 2) par `province` pour être davantage explicit sur son contenu.

```{r}
names(villes)[2] <- "province"
```

On peut maintenant filtrer l'objet `villes` en utilisant se nouvelle attribut.

```{r}
villes_qc <- subset(villes, province == "Québec")
```

On vérifie que le nouveau filtre fonctionne et que nous avons les villes seulement présentes au Québec.

```{r}
mapview(villes_qc) + mapview(subset(provinces, NAME_1 == "Québec"))
```

Certains polygones comme le Québec sont particulièrement échancré et possèdent de nombreuses îles. Ce type de polygon ralentissent parfois considérablement l'affichage à l'écran. Il peut être intéressant d'utiliser la fonction `st_simplify` afin d'attinuer le niveau de détails des polygones. il faut s'assurer que l'unité de projection est en système métrique.

```{r, eval = FALSE}
provs_simplifie <- st_simplify(st_transform(provinces, crs = 32198))
mapview(provs_simplifie, dTolerance = 50000)
```

Attention si vous appliquez cette transformation, prendre note que vous perdez de la résolution spatiale. Cela pourrait avoir des impacts sur le résultat de vos analyses.

Nous avons maintenant convenablement isolé les villes du Québec. La prochaine étape consiste à ajouter pour chacune des villes, sa taille de population. 

#### Joindre des sources d'informations externes (CSV) {-}

Nous avons à présent l'emplacement géographiques de l'ensemble des villes du Québec contenu dans un objet `villes` avec un seul attribut `toponyme` (le nom de la ville). Nous voulons maintenant ajouter pour chacune des villes, sa taille de population. Cette information est contenu dans un fichier `csv` (`Donnees/ville/population.csv`) et provient du [répertoire des municipalités du Québec](https://www.donneesquebec.ca/recherche/fr/dataset/repertoire-des-municipalites-du-quebec/resource/19385b4e-5503-4330-9e59-f998f5918363). Nous allons d'abord importer ce fichier CSV, sélectionner les colonnes pertinentes, puis ensuite fusionner ces informations avec l'emplacement des villes (objet `villes` dans l'environnement de R).

```{r, eval = FALSE}
# On importe le fichier dans l'environnement de R
chemin_pop <- paste(chemin, "villes/population.csv", sep = "")
pop <- read.csv(chemin_pop)
```
```{r, eval = TRUE, echo = FALSE}
pop <- read.csv("Module7/data/villes/population.csv")
```

Cet objet `pop` (`data.frame`) contient `r ncol(pop)` colonnes décrivant jusqu'à la composition du conseil municipal. Toutes ces informations ne sont pas pertinentes pour répondre à notre question. On veut sélectionne les colonnes suivantes:

- `munnom`: Nom de la ville. Cette colonne servira à faire la joiture entre l'objet spatial `villes` et le fichier `csv` (`Donnees/ville/population.csv`) contenant les tailles de populations.
- `msuperf`: Superficie de la municipalité
- `mpopul`: Taille de la population résidente de la munipalité

```{r}
pop <- pop[,c("munnom","msuperf","mpopul")]
```

On peut à présent fusionner l'objet `pop` (taille de population) avec l'objet spatial `villes` en utilisant la fonction `merge()`. La jointure entre les deux objets `villes` et `pop` sera réalisé sur les colonnes `toponyme` et `munnom` respectivement. Ces deux colonnes agissent comme dénominateur communs entre les deux jeux de données et contient le nom de la municipalité. L'argument `all.x = TRUE` spécifie que toutes les entrées (POINT) de l'objet `ville` doivent être conservées. 

```{r}
villes <- merge(x = villes, y = pop, by.x="toponyme", by.y="munnom",  all.x = TRUE)
``` 

On renomme encore une fois les colonnes pour être explicite sur leurs contenus.

```{r}
names(villes)
names(villes)[3:4] <- c("superficie","population")
names(villes) 
```

#### Filtrer sur la table d'attributs {-}

Nous avons à présent assembler les deux pièces d'informations nécessaires pour obtenir une partie de réponse à notre question: 

> Quelles sont les dix plus grandes villes du Québec? 

Nous allons sélectionner les 10 villes présentant la population la plus grande. La première consiste à ordonner l'attribut `population` contenu dans l'objet `villes`.

```{r}
villes <- villes[order(villes$population, decreasing = TRUE),]
```

L'objet `villes` est maintenant ordonné de manière décroissante en fonction de la taille de population des villes. Les 10 premières lignes de cet objet corresponds donc au 10 villes présentant la population la plus importante au Québec. On peut donc assigner les 10 premières lignes à un nouvelle objet initulé `top10_villes`:

```{r}
top10_villes <- villes[1:10,]
top10_villes
```

On peut visualisé avec `mapview` ce nouvel objet.

```{r}
mapview(top10_villes, zcol= "population")
```

### Pour chacune de ces villes, combien de parcs nationaux se retrouvent dans un rayon de 70 kms? {-}

La prochaine étape pour répondre à notre question consiste à tracer une zone tampon (`POLYGON`) de 70 kms de rayon autours des villes (`POINT`) afin de dénombre le nombre de parcs nationaux se trouvant dans cette zone. 

#### Créer des polygones (buffer) autours de points {-}

La première étape consiste à tracer un polygon autours des villes. Pour cela, nous allons utiliser la fonction `st_buffer(top10_villes, dist = 70)`. Le premier argument détermine l'objet spatial et le second la distance (en mètre) autours de la ville. Avant de réaliser cette opération, nous devons vérifier que la couche spatiale des 10 plus grandes villes disposent d'un systèmes de coordonnées projetés en unité métrique pour être sûr que les 70 kms ne soit pas interprété comme 70 degree, puisque l'unité est déterminer en fonction de la projection de l'objet spatial. Cette erreur est très courante. Lorsque l'on veut calculer des distances euclidiennes, il faut toujours s'assurer que l'unité du système de projection est en mètre et non en degrée.

```{r}
st_crs(top10_villes)  
```

`UNIT["degree"...]` atteste que la projection est en degrée. Nous allons à présent reprojeter l'objet `top10_villes` dans un système de projection métrique. Puisque nous sommes au Québec, nous allons utilisé l'[un des systèmes de projection métrique de référence](https://mern.gouv.qc.ca/wp-content/uploads/CO_codes_epsg_quebec.pdf) intitulé *Conique conforme de Lambert du Québec* (NAD83, EPSG: 32198). 

```{r}
top10_villes_lcc <- st_transform(top10_villes, crs = 32198)
# On valide la projection de l'objet spatial
st_crs(top10_villes_lcc) == st_crs(32198)
```

On peut à présent tracer les zones tampons (*buffer*) autours des points à l'aide de la fonction `st_buffer()` expliqué précédemment.

```{r}
top10_villes_buffer <- st_buffer(top10_villes_lcc, dist = 70e3) # 70 kms en mètres = 70e3
mapview(top10_villes_buffer, zcol = "toponyme", legend = FALSE)
```
Il existe une multitude de fonctions dans le package `sf` permettant de créer une couche vectorielle à partir d'une autre couche en utilisant sa configuration spatiale. 

```{r fig.align='center', echo=FALSE, fig.cap="Illustration des opérations réalisables à partir du package `sf`. Extrait de l'aide mémoire de `sf` produit par Rstudio: https://github.com/rstudio/cheatsheets/raw/master/sf.pdf", out.width = '50%'}
knitr::include_graphics('Module7/images/geoOps.png')
```

Nous allons par la suite nous servir de cette couche contenant les polygons afin de dénombrer le nombre de parcs nationaux se retrouvant à l'intérieur. On appelle cette famille d'opérations spatiales, des interceptions.

#### Relations topologiques entre deux couches vectorielles {-}

Pour réaliser cette étape, nous devons dans un premier temps charger la couche d'informations spatiales contenant les différentes aires récréatives du Québec. Cette information se retrouve à l'intérieur d'une géodatabase téléchargeable depuis le site de [données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000). Comme vu dans le module 2, les géodatabase permettent de contenir plusieurs couches vectorielles. Nous devons donc lire la géodatabase et lister les différentes couches afin de déterminer laquelle est pertinente pour continuer notre analyse.

```{r}
st_layers("Module7/data/TRQ_100k.gdb/") 
```

Comme on peut le remarquer, les intitulés des différentes couches ne sont pas explicites. Il faut donc prendre le temps de regarder la documentation [accessible sur le site de données ouvertes Québec](https://www.donneesquebec.ca/recherche/fr/dataset/couche-des-territoires-recreatifs-du-quebec-a-l-echelle-de-1-100-000/resource/229322ef-eca2-4ae9-a511-ba599bc2745e). En s'intéressant à la structure de données et à la nomenclature utilisée et décrite, on peut identifier que la couche `terpnq_s` correspond aux territoires des parc nationaux du Québec. On peut maintenant faire la lecture de cette couche à l'aide de la fonction `st_read()`.

```{r, eval = FALSE}
chemin_provinces <- paste(chemin, "/TRQ_100k.gdb", sep = "")
provinces <- st_read(chemin_provinces)
mapview(parcs_nationaux, zcol = "TRQ_NM_TER")
```

```{r, echo = FALSE}
parcs_nationaux <- st_read("Module7/data/TRQ_100k.gdb/", layer = "terpnq_s") 
mapview(parcs_nationaux, zcol = "TRQ_NM_TER", legend = FALSE)
```

Par curiosité, on peut se demander qu'elle est le pourcentage de couverture des parcs nationaux sur le territoire québcois. Pour cela, il faut obtenir la superficie de chacun des polygones grâce à la fonction `st_area()`. On doit d'abord s'assurer que la projection est en système métrique et reprojeter la couche si ce n'est pas le cas dans un autre système de coordonnées métriques.

```{r}
# Validation de l'unité du système de projection (unité métrique)
st_crs(parcs_nationaux)
# Puisque le système de coordonnées est en degrée, on reprojecte le système en projection
# Conique conforme de Lambert du Québec (NAD83, EPSG: 32198) tel que vu précédemment.
parcs_nationaux <- st_transform(parcs_nationaux, crs = 32198)
# Calcul de la superficie de chaque parcs nationaux.
st_area(parcs_nationaux)
# Calcul du pourcentage de couverture des parcs nationaux sur le territoire québécois
sum(st_area(parcs_nationaux)) / st_area(subset(provinces, NAME_1 == 'Québec')) * 100
```

Le pourcentage de couverture spatial des parcs nationaux (SÉPAQ) pour la province de Québec est de `r round(sum(st_area(parcs_nationaux)) / st_area(subset(provinces, NAME_1 == 'Québec')) * 100, 2) `%. Noter également qu'il est possible à tout moment de changer l'unité de mesure en utilisant la fonction `set_units()` dans le package `units`. 

```{r}
set_units(st_area(parcs_nationaux), km^2)
```

Retournons à présent à notre question originale, nous avons toutes les couches d'informations spatiales pour répondre à la question: _Pour chacune des 10 plus grandes villes du Québec, combien de parcs nationaux se retrouvent dans un rayon de 70 kms?_. La fonction `st_intersects` permet de tester qu'elles sont les parcs se retouvant partiellement ou non à l'intérieur de chacun des buffers. Avant de réaliser ce type d'opération spatiale, il faut toujours s'assurer que les deux objets spatiaux (`top10_villes_buffer` et `parcs_nationaux`) disposent de la même projection.

```{r}
st_crs(top10_villes_buffer) == st_crs(parcs_nationaux)
st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE) 
```

La fonction `st_intersects` avec l'argument `sparse = FALSE` retourne une matrice avec en ligne les zones tampons des 10 plus grandes villes (argument `x` ci-dessus) et en colonne, les 27 parcs nationaux du Québec (argument `y` ci-dessus). Pour chacune des combinaisons, la valeur boléenne renvoyée (`TRUE` ou `FALSE`) détermine si les deux polygones se chevauchent (partiellement ou non). En utilisant l'argument `sparse = TRUE` (valeur par défault), il est possible d'obtenir un affichage plus minimaliste et lisible de la sortie de la fonction.

```{r}
st_intersects(top10_villes_buffer, parcs_nationaux)
```

La fonction retourne cependant un objet de type `list` avec le numéro des polygones
spatiaux (ici les parcs nationaux) satisfaisant la condition d'intersection. Pour bien comprendre l'opération spatiale réaliser, il est possible de visualiser cette intersection spatiale. Prenons l'exemple de la ville de Sherbrooke:

```{r}
which(top10_villes_buffer$toponyme == 'Sherbrooke')
```

La fonction which permet de retourner le numéro de ligne dans la table d'attributs) de l'objet `top10_villes_buffer` satisfant la condition `toponyme == 'Sherbrooke'`. On consigne ensuite la sortie de la fonction dans un objet `id_buffer_sherbrooke`.

```{r}
id_buffer_sherbrooke <- which(top10_villes_buffer$toponyme == 'Sherbrooke')
```
À présent, on récupère le niveau de la liste comprenant les identifiants des parcs nationaux qui chevauchent la zone tampon de la ville de Sherbrooke.

```{r}
ids_parcs_sherbrooke <- st_intersects(top10_villes_buffer, parcs_nationaux)[[id_buffer_sherbrooke]]
```
On peut maintenant séléctionner les polygones (zones tampon et parcs nationaux) se retrouvant dans le secteur de la ville de sherbrooke en se basant sur les identifiants isolés précédemments (`id_buffer_sherbrooke` et `ids_parcs_sherbrooke`). On se sert de ces identifiants afin de visualiser le résultat de l'opération spatiale d'intersection.

```{r}
mapview(parcs_nationaux[ids_parcs_sherbrooke,], legend = FALSE) + 
mapview(top10_villes_buffer[id_buffer_sherbrooke,], fill = NA, legend = FALSE, lwd = 2, color = "red")
```

Dans le cadre de se module, nous avons seulement utilisé la fonction `st_intersect` mais il existe une multitude d'autres opérateur permettant de tester les relations topologiques entre deux couches spatiales. 

```{r fig.align='center', echo=FALSE, fig.cap="Illustration des opérations réalisables à partir du package `sf`. Extrait de l'aide mémoire de `sf` produit par Rstudio: https://github.com/rstudio/cheatsheets/raw/master/sf.pdf", out.width = '50%'}
knitr::include_graphics('Module7/images/geoConf.png')
```

Chacun de ses opérateurs utilisent la même approche. Ils retournent une liste (`sparse = TRUE`, l'argument par défault) avec les identifiants des polygones satisfaisant la conditions du test ou alors une matrice (`sparse = FALSE`) remplie de valeurs boléennes (`TRUE`/`FALSE`): le résultat du test pour chacune des combinaisons de polygones.

L'une des propriétés intéressante des valeurs boléennes (`TRUE` ou `FALSE`), renvoyé par la fonction `st_intersects`, est que la valeur `TRUE` peut être interprété par R comme une valeur de 1 et `FALSE` comme 0. Il est donc possible de réaliser des opérations mathématiques sur des valeurs boléennes. On peut ainsi effectuer une sommation sur les lignes (zones tampons des grandes villes) afin de déterminer combien de parcs nationaux (en colonne dans la matrice) possèdent la valuer `TRUE` se retrouvent ainsi à l'intérieur des zones tampons.

```{r}
rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE))

# Si l'on travaille avec l'argument sparse = FALSE:
lengths(st_intersects(x = top10_villes_buffer, y = parcs_nationaux))
```
La fonction lengths retourne la dimension des vecteurs (c.a.d le nombre de parcs) pour chacune des niveaux de la liste (chaque niveau étant une zone tampon).

On consigne à présent ces valeurs dans une nouvelle colonne de la table d'attributs de l'objet `top10_villes`.

```{r}
top10_villes$nbr_parcs <- rowSums(st_intersects(x = top10_villes_buffer, y = parcs_nationaux, sparse = FALSE))
```

Enfin, on ordonne la table d'attributs en se basant sur la nouvelle colonne `nbr_parcs`. 

```{r}
top10_villes <- top10_villes[order(top10_villes$nbr_parcs, decreasing = TRUE),]
```

On affiche maintenant la table d'attributs afin d'obtenir la réponse tant attendu à notre question:

> Parmis les dix plus grandes villes du Québec, quelle est celle qui dispose du plus grand nombre de parcs nationaux (dans un rayon de 70km)? 

```{r}
top10_villes
```

On constate que Sherbrooke et Saint-Jean-sur-Richelieu dispose tout deux du plus grand nombre (4) de parcs nationaux dans un rayon de 70 kms. 

<!---
NOTE: ICI on pourrait introduire la notion de cropping pour tenter de départager mais je pense qu'il y a déjà pas de stock alors 
-->

Pour le module 8, nous nous allons caractériser le profil d'élévation des 4 parcs de la région de Sherbooke afin de trouver les meilleurs panoramas de la région.

## Exercice

- Pour chaque ville, qu'elle est le plus proche parc? (st_nearest_feature) *
- En utilisant les données des sentiers hivernaux de la SEPAQ (XXXX), parmis les 4 parcs de la région de sherbrooke, lequelle dispose de la plus longue distance de sentier de raquette? (Exercice plus intégrateur mais **)
- Départager les deux villes gagnantes en calculant le pourcentage de couverture des parcs nationaux dans la zone tampon de 70 km. L'un des parcs de la région de sherbrooke chevauche partiellement la zone tampon. Pour répondre à cette question, il faudra découpé (`st_crop`) ce polygone afin d'obtenir seulement la portion se retrouvant dans la zone tampon (**) 