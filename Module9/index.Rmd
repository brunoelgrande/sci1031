# Données spatiotemporelles {#spatiotemp}

Manipuler le temps (les dates, les heures, les secondes, etc.) représente une compétence indispensable en science des données et les données spatio-temporelles ont cette particularité d'être doublement indexées : dans le temps et dans l'espace. L'objectif principal de ce module est justement de manipuler des objets spatiaux, vecteurs et rasters, qui sont aussi indexés dans le temps, et ce à différentes échelles temporelles.


À la fin de ce module vous saurez&nbsp;:

- Manipuler le temps et les dates.
- Écrire des fonctions simples et les utiliser pour structurer vos scripts.
- Créer des animations simples qui montre l’évolution de données spatialisées dans le temps.
- Utiliser les objets de classe `rasterStack`.


Vous utiliserez les bibliothèques suivantes&nbsp;:

- `mapview`
- `raster`
- `sf`
- `lubridate`
- `animation`

Vous apprendrez à utiliser les fonctions suivantes&nbsp;:

- `sort()`, `table()`
- `st_length()`
- `st_cast()`
- `stack()`
- `calc()`
- `as_date_time()`, `ym()`, `hour()`, `minute()`, `second()`
- `getZ()`, `setZ()`

Dans la première partie de la section [Leçon](#lecon_spatiotemp), nous manipulerons des données des trajets de vélo dans la ville de Montréal. Dans la seconde partie, nous utiliserons des données matricielles de températures et de précipitations  autour et nous travaillerons sur une échelle de temps plu grossière, avec des données mensuelles sur une période de 10 ans. 

Dans la section [Exercice](#ex_spatiotemp), vous utiliserez XXX




## Leçon {#lecon_spatiotemp}

Cette leçon est structurée autour de deux exemples inspirés des autres modules.
Dans la première partie, nous allons analyser un jeu de données de 400 trajets de cyclistes à Montréal. Cette analyse nous conduira à manipuler des objets
vectorielles à des échelles de temps fines (de l'ordre de quelques heures). Dans la seconde partie nous étudierons l'évolution au cours des 10 dernières années des température et précipitations dans la région du parc national du Mont-Mégantic. Nous manipulerons alors des climatiques mensuelles sous forme d'une série de rasters.



### Trajets de vélo à la ville de Montréal

Dans cette section nous allons manipuler le temps et l'espace avec un ensemble de 400 trajets de vélo et avec cette ensemble de données nous répondrons aux deux questions suivante&nbsp;:

* Quel trajet présente la vitesse moyenne la plus élevée?

* Quelle est période de l'année favorite des cyclistes du jeu de données?

Nous finirons cette partie avec un exercice de visualisation du trajet le plus long, sous forme d'animation. 


#### Importer les données 

Le site de la ville de Montréal et le site [Données Québec](https://www.donneesquebec.ca/), mettent à disposition un jeu de données incluant près [5000 trajets individuels à vélo](https://www.donneesquebec.ca/recherche/dataset/vmtl-trajets-individuels-velo-enregistre-mon-resovelo#). Ces trajets ont été obtenus avec l'application ["Mon RésoVélo"](https://apps.apple.com/ca/app/mon-r%C3%A9sov%C3%A9lo/id664766113) qui enregistre les positions du cyclistes à intervalle régulier. Les données de trajets brutes ont ensuite été traitées avant d'être rendues disponibles en ligne sous licence [*creative common* (CC-BY)](https://creativecommons.org/licenses/by/4.0/deed.fr) (les trajets ont notamment été anonymisés, reportez-vous au lien précédent pour plus d’informations relatives au traitement de ces données).


L'ensemble de ces trajets est contenu dans un fichier
[GeoJSON](https://fr.wikipedia.org/wiki/GeoJSON) `trip5000.json` qui a été
zippé. Ces données étant un peu volumineuses (>150MB), nous avons seulement
gardé les 400 premiers trajets. Aussi, nous avons enlevé la colonne `liste_segments_jsonb` qui permet d'identifier les pistes cyclables et les portions du réseau routier emprunter par les cyclistes. Nous avons fait ce pré-traitement en utilisant des manipulations vues dans
les modules précédents, que nous décrivons ci-dessous&nbsp;:

```R
library(sf)
tmp <- st_read("trip5000.json") 
st_write(tmp[1:400, names(tmp) != "liste_segments_jsonb"], "trip400.geojson") 
```

Nous pouvons maintenant utiliser le fichier `trip400.geojson` disponible à l'URL suivante [XXX]() comme suit&nbsp;:

```{r, eval = FALSE}
chemin <- "D:/votrechemin/SCI1031/Module9/Donnees/"
chemin_trajet <- paste(chemin, "/trip400.geojson", sep = "")
trajets <- st_read(chemin_trajet)
trajets
```

```{r read_trajet, echo = FALSE, message = FALSE}
library(sf)
trajets <- st_read("Module9/data/trip400.geojson")
trajets
```

Il s'agit d'un objet de classe `sf` qui contient un ensemble de 400 lignes décrivant les trajets à vélo et pour lesquels nous avons les informations suivantes&nbsp;:

```{r, names_trajet}
names(trajets)
```

Dans la suite nous utiliserons les colonnes suivantes:

- `start` : date et heure associées au début du trajet, 
- `stop` : date et heure associées à la fin du trajet,
- `length`: longueur du trajet.



#### Quel trajet présente la vitesse moyenne la plus élevée?

Nous avons maintenant importée 400 trajets à vélo et nous cherchons, dans un premier temps, celui qui présente la vitesse moyenne la plus élevée. Pour calculer une vitesse, nous devons diviser une longueur par le temps. Nous avons donc besoin de trouver la distance des trajets. Dans la table des attributs de `trajets`, il y a une colonne `length` qui nous donne cette distance.

```{r, col_length}
trajets$length[1:20] 
```

Sans cette colonne, il demeure relativement aisé de calculer ces distances avec la fonction `st_length()` qui calcule la longueur de chaque ligne de `trajets`. 


```{r trajet_length}
len <- st_length(trajets)
len[1:20]
```

Est-ce que les deux distances sont identiques? Un moyen simple de le vérifier est de visualiser une distance en fonction de l'autre.

```{r, len_vs_len}
plot(trajets$length, st_length(trajets), 
  xlab = "distance - colonne 'length' (m)", # 
  ylab = "distance - st_length() (m)", 
  pch = 19) # change le symbole des points
abline(a = 0, b = 1, lty = 2) # ligne 1:1; lty = 2 donne une ligne discontinue
```

Nous voyons ainsi rapidement que tous les points sont sur la ligne 1:1, donc les valeurs sont identiques (ou très proches, car nous n'avons pas fait de tests formels, ils se pourraient donc qu'il y ait de minimes différences entre les deux distances). 

Il nous reste à quantifier la durée des trajets pour obtenir les vitesses moyennes. Pour cela, nous avons besoin des les colonnes `start` et `stop`. Pour la manipulation des dates et du temps, nous allons utiliser la bibliothèque [`lubridate`](https://CRAN.R-project.org/package=lubridate). R dispose, de base, de toutes les fonctionnalités nécessaires à la manipulation des dates et du temps, `lubridate` rend ces manipulations plus intuitives (l'aide mémoire (<https://github.com/rstudio/cheatsheets/raw/master/lubridate.pdf> fait un tour d'horizon complet des fonctionnalités de `lubridate`). 

Regardons à présent la classe des colonnes `start` et `stop`&nbsp;:

```{r}
class(trajets$start)
class(trajets$stop)
```

Les classes de ces objets signifient que les chaînes de caractères suivent une norme [POSIX](https://fr.wikipedia.org/wiki/POSIX) (*Portable Operating System Interface*), en l'occurrence `POSIXct` (*calendar time*) est une variété de `POSIXt` (*time*) qui contient le nombre de secondes écoulées depuis l'[Heure Unix](https://fr.wikipedia.org/wiki/Heure_Unix) (*Epoch time*), le 1^er^ janvier 1970 00:00:00 UTC. Ainsi, en convertissant les objets de classe `POSIXct` en objet de classe `numeric`, nous obtenons ce nombre de secondes, par exemple&nbsp;:

```{r}
nb_sec <- as.numeric(trajets$start)
nb_sec[1:20]
```

Ces classes peuvent être manipulées avec les fonctions de `lubridate`, par exemple nous pouvons extraire l'année avec la fonction `year()`&nbsp;:

```{r get_year, message = FALSE}
library(lubridate)
year(trajets$start)[1:20]
```

Aussi, la soustraction de deux objets `POSIXct` nous donne un objet de classe `difftime` qui exprime une durée en seconde:

```{r duree}
duree <- trajets$stop[1] - trajets$start[1]
duree
class(duree)
```
Nous calculons alors les durées pour les différents trajets.

```{r}
trajets$duree_s <- trajets$stop - trajets$start
```

Regardons les distributions de longueurs et de durées en dessinant un histogramme avec la fonction `hist()`. 


```{r histo, fig.width = 9.5}
par(mfrow = c(1, 2)) # figure a deux panneaux côte à côte
hist(trajets$length, 
  breaks = seq(0, 44000, 2000), # spécifie les catégories de longueur
  xlab = "Longueur (m)",
  ylab = "Fréquence",
  main = "" # pas de titre
) 
hist(as.numeric(trajets$duree_s), 
  breaks = seq(0, 20000, 1000),
  xlab = "Durée (s)",
  ylab = "Fréquence",
  main = "" # pas de titre
)
```

Nous rajoutons maintenant une colonne `vitesse_m_s` à `trajets` qui est la vitesse moyenne exprimée en mètre par seconde. 

```{r vitesse}
trajets$vitesse_m_s <- trajets$length/as.numeric(trajets$duree_s)
```

Il peut être préférable d'exprimer ces vitesse en kilomètre par heure, pour cela il nous suffit de diviser par 1000 pour convertir les mètres en kilomètres et multiplier les secondes par 3600 pour les convertir en heures, ce qui revient à multiplier par 3.6

```{r kms}
trajets$vitesse_km_h <- trajets$vitesse_m_s*3.6
```

Nous allons maintenant ordonner les vitesse avec et regarder les 10 premières valeurs: 

```{r sort_vitesse}
vit_dec <- sort(trajets$vitesse_km_h, decreasing = TRUE)[1:10]
```
Le plus rapide des cyslistes circule à une vitesse moyenne de `r format(vit_dec[1], digits = 3)`&nbsp;km/h, ce qui ne semble pas réaliste et un problème d'enregistrement est probablement à l'origine, nous excluons ce trajet le second et retenons le second comme étant le plus rapide. Pour l'extraire, nous utiliser la fonction `order()`...

```{r traj_rapide}
traj_rapide <- trajets[order(trajets$vitesse_km_h, decreasing = TRUE)[2], ]
traj_rapide 
```

... et nous le visualisons avec `mapview()`.

```{r}
library(mapview)
mapview(traj_rapide)
```

Un trajet bien singulier, à 22h près du parc Laurier.




#### Quelle est période de l'année favorite des cyclistes du jeu de données?


Pour répondre à cette deuxième question, nous allons commencer par identifier le mois de l'année qui compte le plus de trajet à vélo (les trajets on été enregistrés en 2013). Pour cela, nous allons utiliser la fonction `month()` de la bibliothèque `lubridate`. Cette fonction nous retourne le mois associé à un objet de classe `POSIXct`

```{r fun_month}
month(trajets$start[1])
```

`month` nous offre aussi la possibilité d'utiliser les noms de mois sous forme de facteurs, de manière abbréviés&nbsp;:

```{r}
month(trajets$start[1], label = TRUE)
```

ou complet&nbsp;:

```{r}
month(trajets$start[1], label = TRUE, abbr = FALSE)
```

Nous utilisons seulement les numéros de mois et nous créons une colonne `month` dans la table d'attribut de `trajets` pour les conserver&nbsp;:

```{r}
trajets$mois <- month(trajets$start)
```

une manière efficace de compter le nombre d'occurrence est d'appliquer la fonction `table()` sur la colonne nouvellement créée&nbsp;:

```{r table_month}
nb_mois <- table(trajets$mois)
nb_mois 
```

Juillet est donc le mois qui concentre le plus de trajet à vélo dans le jeu de données étudié. Nous allons maintenant regardé le jour qui concentre le plus de trajet avec la fonction `day()`. Nous commençons par ajouter une colonne `jour`.

```{r jour}
trajets$jour <- day(trajets$start)
```

Nous isolons ensuite que les trajets qui sont en juillet.

```{r traj_juillet, fig.width = 9.5}
traj_juillet <- trajets[trajets$mois == 7, ]
```

Enfin, nous visualiser le nombre de trajet par jour avec les fonctions `table()` et `barplot()` cette fois-ci. 

```{r barplot_day, fig.width = 9.5}
barplot(
  table(traj_juillet$jour),
  xlab = "Jour de juillet",
  ylab = "Nombre de trajets"
)
```

C'est donc le 10 juillet que nous recensons le plus grand nombre de trajets.
Nous allons même aller à l'échelle de l'heure et nous recommençons les étapes précédentes avec la fonction `hour`. Au passage mentionnons la la bibliothèque [`hms`](https://CRAN.R-project.org/package=hms) pour manipuler les heures, minutes et secondes (nous ne l'utiliserons pas ici, mais elles pourraient vous être utile pour vos futurs projets).

```{r traj_10juillet, fig.width = 9.5}
trajets$heure <- hour(trajets$start)
traj_10juillet <- trajets[trajets$mois == 7 & trajets$jour == 10, ]
barplot(
  table(traj_10juillet$heure),
  xlab = "Jour de juillet",
  ylab = "Nombre de trajets"
)
```

C'est donc à 17h le 10 juillet que les trajets sont le plus nombreux.





#### Le trajet le plus long en animation

Nous allons à présent animer le chemin le plus long, nous voulons créer un fichier [GIF](https://fr.wikipedia.org/wiki/Graphics_Interchange_Format) qui illustrera le parcours du cycliste. Pour y arriver nous devrons faire les étapes suivantes&nbsp;:

1. Trouver le chemin le plus long.

2. Associer un temps à chaque segment du parcours. 

3. Créer une même figure à différent point du parcours.

4. Rassembler les figure et en faire un fichier GIF.


La première étape est une manipulation de filtre que nous avons fait à maintes reprises. Cette fois-ci appliquons `which.max()` sur la colonne `length()` et nous filtrons avec `[`. 

```{r traj_long}
traj_long <- trajets[which.max(trajets$length), ]
```

Regardons ce trajet&nbsp;:

```{r}
mapview(traj_long)
```

Passons à la seconde étape. Pour pouvoir associer un temps à chaque portion du trajet, nous allons commencer par convertir la ligne en point avec la fonction `st_cast()`.

```{r}
traj_long_pts <- st_as_sf(st_cast(st_geometry(traj_long), to = "POINT"))
```

Décortiquons cette ligne: 

1. nous utilisons la géométrie de `traj_long` avec `st_geometry()`,

2. nous faisons la conversion point/ligne avec `st_cast()`,

3. l'objet de classe `sfc` ainsi obtenu est converti en objet de classe `sf` avec `st_as_sf()`.


Nous ajoutons alors, au nouvel objet de classe `sf` ainsi créé, une colonne temps. Pour cela nous créons une séquence régulière (l'application "Mon RésoVélo" enregistrant des coordonnées spatiales à intervalle régulier) avec la fonction `seq()` en spécifiant le temps de départ (dans la colonne `start`), le temps d'arrivé (colonne stop `stop`) et le nombre de point que doit inclure la séquence (argument `length.out`) qui est le nombre de ligne (`nrow()`) de la table d'attribut de `traj_long`.

```{r seq_time}
traj_long_pts$temps <- seq(
  from = traj_long$start, 
  to = traj_long$stop, 
  length.out = nrow(traj_long_pts)
)
```

Maintenant nous allons créer l'animation. Pour y parvenir nous avons besoin d'être capable de visualiser le trajet à différent moment. Nous commençons par le faire pour les 2000 premiers points de `traj_long_pts`.

```{r pt_to_li}
lin <- st_cast(st_combine(traj_long_pts[1:2000, ]), "LINESTRING")
```

Cette ligne contient les étapes suivantes: 

1. nous extrayons les 2000 premiers points avec `[`, 
2. nous les combinons en `MULTIPOINT` avec `st_combine()`,
3. nous transformons le `MULTIPOINT` en `LINESTRING` avec `st_cast()`. 

Notons que sans l'étape 2, `st_cast()` transformera chaque point en ligne ce qui donnera un ensemble de lignes de un seul point. Regardons cette section avec `mapview()`.

```{r}
mapview(lin) 
```

Grâce à l'étape précédente nous pouvons facilement avoir accès à l'heure correspondant au dernier point de ce trajet. 

```{r}
traj_long_pts[2000, "temps"]
```

Et avec `st_length()` nous pouvons avoir la distance parcourue pour cette section&nbsp;:

```{r}
st_length(lin)
```

Pour l'animation nous ferons des cartes simples avec le package `tmap` et nous ajouterons ces deux éléments que nous combinons avec `paste0()`. 

```{r simple_map}
library(tmap)
tm_shape(lin, bbox = st_bbox(traj_long_pts)) + 
  tm_lines(lwd = 2, col = "#62852eaa") + 
  tm_layout(main.title = paste0(
    "temps: ",
    traj_long_pts[2000, "temps"], 
    " / distance", st_length(lin)
  ),  main.title.size = 0.9)
```

Il nous reste alors à faire ce même graphique pour un nombre croissant de points et nous combinerons toutes ces graphiques en un GIF. Nous allons structurer notre code avec quelques fonctions. Nous devons donc prendre un peu de temps pour expliquer comment créer une fonction. Jusqu'ici nous avons utiliser de nombreuses fonctions sans que nous n'ayons eu besoin de créer nos propres fonctions. Pour comprendre comment est structurer une fonction, nous en créons une simple. 

```{r}
ma_fonction <- function(a, b = 1) {
  if (b > 0) {
    c <- a + b
  } else {
    c <- a - 2*b
  }
  return(c) # ou simplement c
}
```

Dans R, une fonction est un objet créé avec `function`. Comme tout objet nous pouvons l'assigner à une variable et dans notre exemple, nous l'assignons à `ma_fonction` qui sera le nom de la fonction. Dans la parenthèse qui suit `function`, nous écrivons les arguments de la fonction, en l'occurrence pour `ma_fonction`, nous avons `a` et `b`. Dans notre exemple `b` a une valeur par défaut qui est 1, donc si nous ne spécifier pas `b`, alors Le corps de la fonction est l'expression juste après cette parenthèse, dans notre case cela inclut tout ce qui est entre accolades (`{}`). Une fonction peut comprendre autant de ligne de code que souhaité et peut contenir n'importe quel code R valid. Pour l'exemple nous avons utiliser un test logique `if`/`else`. Une fonction dans R retourne la dernière ligne de code (l’utilisation de `return()` à la dernière ligne est optionnelle, mais permet de clarifier ce que retourne la fonction). Une fois la fonction créée, nous l'appelons comme toute autre fonction. 

```{r}
ma_fonction(1) # utlise b = 1
ma_fonction(1, 2)
ma_fonction(1, -2)
```

Notre fonction principale, `visual()`, a pour argument les points du trajet, `traj_pts` et le nombre de points à combiner, que nous appellerons `n` et reprendra les étapes précédentes.


```R
visual <- function(traj_pts, n = 100) {
  # extraction
  pts <- traj_pts[1:n, ] 
  lin <- st_cast(st_combine(pts), "LINESTRING")
  # graphique
  tm_shape(lin, bbox = st_bbox(traj_long_pts)) + 
    tm_lines(lwd = 2, col = "#62852eaa") + 
    tm_layout(main.title = paste0(
      "temps: ",
      traj_long_pts[n, "temps"], 
      " / distance", st_length(lin)
    ), main.title.size = 0.9)
}
```

Nous allons faire quelques amélioration sur le texte en créant deux autres fonctions. La première `txt_temps()` a pour argument un temps (nous utiliserons le temps du point `n`) et retourne un texte formaté grâce aux fonctionnalités de `lubridate`. 


```{r txt_temps}
txt_temps <- function(temps) {
  paste0(hour(temps), "h ", minute(temps), "m ", floor(second(temps)), "s")
} 
```

La seconde prend pour argument une line et retourne un texte formaté comprenant la distance en kilomètre. 
 
```{r txt_distance}
txt_distance <- function(lin) {
  len <- st_length(lin)
  paste0("Distance parcourue: ", format(as.numeric(len)/1000, digits = 4), "km")
}
```

Notons que la fonction `format()` nous permet de contrôler le nombre de chiffres (`digits`) affiché. Dans `visual()`, nous appelons ces deux fonctions. De plus nous ajoutons un argument, `basemap`, qui nous permet d'ajouter un fond de carte. Cet argument a pour valeur `NULL` par défaut, ce qui nous permet d'avoir un cas sans carte de fond par défaut. Enfin nous allons nous assurer qu'il y ait au moins 2 points car nous avons besoin de 2 points pour faire une ligne. 


```{r visual}
visual <- function(traj_pts, n = 100, basemap = NULL) {
  stopifnot(n > 1)
  tps <- traj_pts$temps[n]
  pts <- traj_pts[1:n, drop = FALSE]
  lin <- st_cast(st_combine(pts), "LINESTRING")
  basemap + 
  tm_shape(lin, bbox = st_bbox(traj_long_pts)) + 
    tm_lines(lwd = 2, col = "#62852eaa") +
    tm_layout(main.title = paste0(txt_temps(tps), "  -  ", txt_distance(lin)), 
    main.title.size = 0.9)
}
```

Nous pouvons maintenant faire la figure pour le nombre de point désiré, avec un minimum de 2 et un maximum de `r nrow(traj_long_pts)` points). Pour faire la figure précédente nous utilisons le code suivant&nbsp;:

```{r}
visual(traj_long_pts, 2000)
```

Que nous avons à modifier légèrement pour faire la même figure avec les 4000 points.

```{r}
visual(traj_long_pts, 4000)
```

Pour faire un GIF nous utilisons la fonction `saveGIF()` du package `animation`. Cette fonction prend en premier argument une expression (du code R) qui permet de généré une série de figures qui seront combinées en GIF. Pour nous allons faire une nouvelle fonction `anim()` qui nous permet de généré une série de `n_img` de notre trajet en appelant `visual()`.


```{R}
anim <- function(traj_pts, n_img = 10, basemap = NULL) {
  for (i in floor(seq(2, nrow(traj_pts), length.out = n_img))) {
    print(visual(traj_pts, i, basemap))
  }
}
```

Quelques remarques: 

* Nous utilisons `seq()` pour générer une séquence entre 2 et le maximum de points (`r nrow(traj_long_pts)`). 

* La séquence peut générer des nombres décimaux, mais `visual()` demande des nombre entiers, nous utilisons alors `floor()` pour la conversion. 

* Nous reprenons l'argument `basemap` pour qu'il puisse être passé à `visual()`. 

Nous pouvons maintenant utilisé `saveGIF()`.

```R
saveGIF(anim(20), movie.name = "anim1.gif", ani.height = 500, ani.width = 500)
```

![](Module9/img/anim1.gif)

Pour finir, nous allons ajouter un fond de carte. Pour cela nous allons télécharger un fond de carte de [OpenStreetMap](https://www.openstreetmap.org) grâce à fonction `osm.raster()` de la bibliothèque [`rosm`](https://CRAN.R-project.org/package=rosm).

```R
library(raster)
library(rosm)
bm <- osm.raster(extent(traj_long_pts), crop = TRUE)
bm
```

Nous créons alors un fond de carte rapide avec `tmap` et la fonction `tm_rgb()`

```R
saveGIF(animation(20, tm_shape(bm) + tm_rgb()), 
   movie.name = "anim2.gif", ani.height = 500, ani.width = 500)
```

![](Module9/img/anim2.gif)














### Précipitations et Température autour du Mont-Mégantic

Nous allons maintenant nous intéresser aux précipitations et aux températures moyennes autour du par national du Mont-Mégantic entre 2007 et 2016. Nous nous poserons deux nouvelles questions&nbsp;:

* Quelle est le mois disposant du plus faible?

* Quelle est le mois le plus chaud?

Nous terminerons par un nouveau travail de visualisation avec profiles de temperature et precipitation, ainsi qu'une animation.



#### Importer les données 

Les données sont au format [NetCDF (Network Common Data Form)](https://fr.wikipedia.org/wiki/NetCDF) et peuvent être importées en utilisant la fonction `stack()`. Ces données ont été préparées à partir de données climatiques à haute résolution pour l'Amérique du Nord [@macdonald_north_2020], disponibles sur l'espace dédié à l'archivage de données du centre allemand de calcul pour le climat, [DKRZ](https://cera-www.dkrz.de/WDCC/ui/cerasearch/project?acronym=CanClim). Nous importons ces données avec la fonction `stack()` du pacake `raster`.


```{r stack, message = FALSE}
library(raster)
# temperature minimale par mois pour
mint <- stack("Module9/data/mint.nc")
# temperature maximale par mois 
maxt <- stack("Module9/data/maxt.nc")
# total des precipitations par mois 
pcp <- stack("Module9/data/pcp.nc")
```

```{r}
class(mint)
```

Il s'agit là d'objets de classe `rasterStack` que nous détaillons dans la section suivante.


#### Les objets `rasterStack`

Pour cette section, nous nous concentrons sur `mint`, mais tout ce que nous
voyons ici s'applique aux autres objets `rasterStack` que nous avons importés.
Inspectons rapidement ce nouvel objet.

```{r}
mint
```

Nous obtenons des informations similaire à celle d'un objet de classe `rasterLayer`, cependant la ligne qui indique les dimensions a un élément de plus indiquant le nombre de couche, et les valeurs affichés sont les valeurs minimales et maximales pour les différentes couches. 


##### Extraire les informations générales


Un raster `rasterStack` est en fait une collection de`rasterLayer` qui
ont la même projection spatiale, la même résolution, la même étendue
spatiale et donc le même nombre de cellules. Pour obtenir ces informations individuellement, nous utilisons les mêmes fonctions que pour les `rasterLayer`. 

```{r}
extent(mint)
projection(mint)
ncell(mint)
```

Les dimensions du `rasterStack` peuvent être aussi être affichées avec `dim()` 

```{r}
dim(mint)
```

Comme nous pouvons les constater, 3 nombres sont retournés, un de plus pour les `rasterLayer`s, le dernier chiffre est le nombre de couches que nous avons mentionné plus haut, ici `r nlayers(mint)`. Ce nombre peut aussi être affiché en utilisant la fonction `nlayers()`. 


```{r}
nlayers(mint[[1]])
```


L'objet `mint` est une donc collection de `r nlayers(mint)` `rasterLayer`s, chacune de ces couches représente des valeurs de température minimales sur toutes la zone pour un mois donné. Ici les couches sont ordonnées dans le temps (elles ont été combinées ainsi) et nous avons 1 couche par mois sur 10 ans. 



##### Extraire une selection de couches

Il est possible d'accéder à n'importe quelle couche (`rasterLayer`) en utilisant `[[`: 

```{r}
class(mint[[1]])
# Raster de Température minimale du mois de janvier de la première année (2007)
mint[[1]]
# Raster de Température minimale du mois de décembre de la dernière année (2016)
mint[[120]]
```

Nous pouvons aussi prendre une séquence d'indices et obtenir un autre `rasterStack`. Par exemple, nous pouvons obtenir les données de la première année en utilisant les 12 premiers indices.

```{r}
mint[[1:12]]
```

Nous pouvons aussi obtenir les températures minimales pour les 10 mois de septembre, nous utilisons pour cela la fonction `seq()`.

```{r}
mint[[seq(9, by = 12, length.out = 10)]]
```



##### Extraire et manipuler les valeurs

Nous pouvons extraire les valeurs en utilisant la double indexation: `[[` pour choisir les couches désirées, et puis `[` pour extraire les valeurs des couches sélectionnées. Ainsi, nous pouvons extraire les valeurs des 10 premières cellules pour la première année. 

```{r}
mint[[1:12]][1:10]
```

Nous obtenons une matrice de 12 colonnes (1 colonne par mois) et 10 lignes (1 par cellule). Il est aussi possible d'utiliser `getValues()` et pour un objet `rasterStack`, l'ensemble des valeurs nous sont alors retournées sous forme de matrice. 

```{r}
val <- getValues(mint)
dim(val)
```

Pour appliquer les mêmes opérations sur les différentes couches, il est donc possible d'utiliser la valeur après avoir utilisé `getValues()`. 

```{r}
apply(val, 1, min)
```


Nous pouvons aussi utiliser `summary()` qui nous donne un aperçu de la distribution des valeurs pour chaque couche.  

```{r}
su_mint <- summary(mint)
su_mint[1:10]
```


Aussi certaine


##### Visualiser 


```{r, warning = FALSE}


mapview(mint[[1:3]])
```



```{r}
plot(max(mint))
plot(max(mint))
```

```{r}
quantile(mint)
```

```{r}
plot(calc(mint, quantile)) 
```



```{r}
paste0(rep(1:12, 10), "/", rep(1:10, each = 12))
temps <- my(paste0(rep(1:12, 10), "/", rep(1:10, each = 12)))
names(mint) <- paste0(temps)
```

```{r setZ}
mint <- setZ(mint, temps)
getZ(mint)
```

```{r}
temps <- my(paste0(rep(1:12, 10), rep(1:10, each = 12)))
names(mint) <- paste0(temps)
```


TODO 
<!-- crop -->


#### Question 1

* Quelle est le mois disposant du plus faible niveau de pluviométrie pour le parc national possédant ce sommet?


1. cropper elevation raster autour du parc

2. Sur dix ans, mois par mois


```{r}
ra_mean <- list()
for (i in 1:12) {
  ra_mean[[i]] <- mean(mint[[i + (0:9)*12]])
}
ra <- stack(ra_mean)
names(ra) <- month.name[1:12]
plot(ra)
```


```{r}
val <- apply(getValues(ra), 2, mean)
val 
which.min(val)
```


* Trouver le mois le moins pluvieux pour préparer notre saison de randonnée.

- On extract les valeurs de précipitation (par mois) du rasterStack pour le parc que l'on a ciblé
- On montre comment on peut réaliser une moyenne entre deux mois rasterStack[[1]] + rasterStack[[2]] / 2 ou alors mean rasterStack[[1:2]]. 

- which.min pour déterminer le raster du stack disposant de la plus petite valeur
- Compléter avec d'autre chose, ca me parait léger... à voir quand au dessus ce sera écrit..


#### Profile temperature et precipitation


```{r}
# TODO le mettre en fonction!
plot(0.1*apply(getValues(mint), 2, mean), type = "l", lty = 2)
lines(1:120, apply(getValues(maxt), 2, mean), lty = 2, col = 2)
```


#### Visualisation

<!-- profile et raster a coté avec le parc -->
<!-- 
plot(mint[[2]]) 
plot(0.1*apply(getValues(mint), 2, mean), type = "l", lty = 2) -->


### Remarques finales

L'écosystème de package R est toujours en activement, aisn quelque années
vous pourrez faire les même opérations avec des finctoins au nom similaires. 
Cela dit tout ce qui a été vu ici reste valid.




## Exercice {#ex_spatiotemp}


