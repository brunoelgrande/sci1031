# Données spatiotemporelles {#spatiotemp}

Manipuler le temps (les dates, les heures, les secondes, etc.) représente une compétence indispensable en science des données et les données spatio-temporelles ont cette particularité d'être doublement indexées : dans le temps et dans l'espace. L'objectif principal de ce module est justement de manipuler des objets spatiaux, vecteurs et rasters, qui sont aussi indexés dans le temps, et ce à différentes échelles temporelles.


À la fin de ce module vous saurez&nbsp;:

- Manipuler le temps et les dates.
- Écrire des fonctions simples et les utiliser pour structurer vos scripts.
- Créer des animations simples qui montre l’évolution de données spatialisées dans le temps.
- Utiliser les objets de classe `rasterStack`.


Vous utiliserez les bibliothèques suivantes&nbsp;:

- `mapview`
- `raster`
- `sf`
- `lubridate`
- `animation`

Vous apprendrez à utiliser les fonctions suivantes&nbsp;:

- `sort()`, `table()`
- `st_length()`
- `stack()`
- `calc()`
- `as_date_time()`, `ym()`, `hour()`, `minute()`, `second()`
- `getZ()`, `setZ()`

Dans la première partie de la section [Leçon](#lecon_spatiotemp), nous manipulerons des données des trajets de vélo dans la ville de Montréal. Dans la seconde partie, nous utiliserons des données matricielles de températures et de précipitations  autour et nous travaillerons sur une échelle de temps plu grossière, avec des données mensuelles sur une période de 10 ans. 

Dans la section [Exercice](#ex_spatiotemp), vous utiliserez XXX




## Leçon {#lecon_spatiotemp}

Cette leçon est structurée autour de deux exemples inspirés des autres modules.
Dans la première partie, nous allons analyser un jeu de données de 400 trajets de cyclistes à Montréal. Cette analyse nous conduira à manipuler des objets
vectorielles à des échelles de temps fines (de l'ordre de quelques heures). Dans la seconde partie nous étudierons l'évolution au cours des 10 dernières années des température et précipitations dans la région du parc national du Mont-Mégantic. Nous manipulerons alors des climatiques mensuelles sous forme d'une série de rasters.



### Trajets de vélo à la ville de Montréal

Dans cette section nous allons manipuler le temps et l'espace avec un ensemble de 400 trajets de vélo et avec cette ensemble de données nous répondrons aux deux questions suivante&nbsp;:

* Quel trajet présente la vitesse moyenne la plus élevée?

* Quelle est période de l'année favorite des cyclistes du jeu de données?

Nous finirons cette partie avec un exercice de visualisation du trajet le plus long, sous forme d'animation. 


#### Importer les données 

Le site de la ville de Montréal et le site [Données Québec](https://www.donneesquebec.ca/), mettent à disposition un jeu de données incluant près [5000 trajets individuels à vélo](https://www.donneesquebec.ca/recherche/dataset/vmtl-trajets-individuels-velo-enregistre-mon-resovelo#). Ces trajets ont été obtenus avec l'application ["Mon RésoVélo"](https://apps.apple.com/ca/app/mon-r%C3%A9sov%C3%A9lo/id664766113) qui enregistre les positions du cyclistes à intervalle régulier. Les données de trajets brutes ont ensuite été traitées avant d'être rendues disponibles en ligne sous licence [*creative common* (CC-BY)](https://creativecommons.org/licenses/by/4.0/deed.fr) (les trajets ont notamment été anonymisés, reportez-vous au lien précédent pour plus d’informations relatives au traitement de ces données).


L'ensemble de ces trajets est contenu dans un fichier
[GeoJSON](https://fr.wikipedia.org/wiki/GeoJSON) `trip5000.json` qui a été
zippé. Ces données étant un peu volumineuses (>150MB), nous avons seulement
gardé les 400 premiers trajets. Aussi, nous avons enlevé la colonne `liste_segments_jsonb` qui permet d'identifier les pistes cyclables et les portions du réseau routier emprunter par les cyclistes. Nous avons fait ce pré-traitement en utilisant des manipulations vues dans
les modules précédents, que nous décrivons ci-dessous&nbsp;:

```R
library(sf)
tmp <- st_read("trip5000.json") 
st_write(tmp[1:400, names(tmp) != "liste_segments_jsonb"], "trip400.geojson") 
```

Nous pouvons maintenant utiliser le fichier `trip400.geojson` disponible à l'URL suivante [XXX]() comme suit&nbsp;:

```{r, eval = FALSE}
chemin <- "D:/votrechemin/SCI1031/Module9/Donnees/"
chemin_trajet <- paste(chemin, "/trip400.geojson", sep = "")
trajets <- st_read(chemin_trajet)
trajets
```

```{r read_trajet, echo = FALSE, message = FALSE}
library(sf)
trajets <- st_read("Module9/data/trip400.geojson")
trajets
```

Il s'agit d'un objet de classe `sf` qui contient un ensemble de 400 lignes décrivant les trajets à vélo et pour lesquels nous avons les informations suivantes&nbsp;:

```{r, names_trajet}
names(trajets)
```

Dans la suite nous utiliserons les colonnes suivantes:

- `start` : date et heure associées au début du trajet, 
- `stop` : date et heure associées à la fin du trajet,
- `length`: longueur du trajet.



#### Quel trajet présente la vitesse moyenne la plus élevée?

Nous avons maintenant importée 400 trajets à vélo et nous cherchons, dans un premier temps, celui qui présente la vitesse moyenne la plus élevée. Pour calculer une vitesse, nous devons diviser une longueur par le temps. Nous avons donc besoin de trouver la distance des trajets. Dans la table des attributs de `trajets`, il y a une colonne `length` qui nous donne cette distance.

```{r, col_length}
trajets$length[1:20] 
```

Sans cette colonne, il demeure relativement aisé de calculer ces distances avec la fonction `st_length()` qui calcule la longueur de chaque ligne de `trajets`. 


```{r trajet_length}
len <- st_length(trajets)
len[1:20]
```

Est-ce que les deux distances sont identiques? Un moyen simple de le vérifier est de visualiser une distance en fonction de l'autre.

```{r, len_vs_len}
plot(trajets$length, st_length(trajets), 
  xlab = "distance - colonne 'length' (m)", # 
  ylab = "distance - st_length() (m)", 
  pch = 19) # change le symbole des points
abline(a = 0, b = 1, lty = 2) # ligne 1:1; lty = 2 donne une ligne discontinue
```

Nous voyons ainsi rapidement que tous les points sont sur la ligne 1:1, donc les valeurs sont identiques (ou très proches, car nous n'avons pas fait de tests formels, ils se pourraient donc qu'il y ait de minimes différences entre les deux distances). 

Il nous reste à quantifier la durée des trajets pour obtenir les vitesses moyennes. Pour cela, nous avons besoin des les colonnes `start` et `stop`. Pour la manipulation des dates et du temps, nous allons utiliser la bibliothèque [`lubridate`](https://CRAN.R-project.org/package=lubridate). R dispose, de base, de toutes les fonctionnalités nécessaires à la manipulation des dates et du temps, `lubridate` rend ces manipulations plus intuitives (l'aide mémoire (<https://github.com/rstudio/cheatsheets/raw/master/lubridate.pdf> fait un tour d'horizon complet des fonctionnalités de `lubridate`). 

Regardons à présent la classe des colonnes `start` et `stop`&nbsp;:

```{r}
class(trajets$start)
class(trajets$stop)
```

Les classes de ces objets signifient que les chaînes de charactère suivent une norme [POSIX](https://fr.wikipedia.org/wiki/POSIX) (*Portable Operating System Interface*), en l'occurrence `POSIXct` (*calendar time*) est une variété de `POSIXt` (*time*) qui contient le nombre de secondes écoulées depuis l'[Heure Unix](https://fr.wikipedia.org/wiki/Heure_Unix) (*Epoch time*), le 1^er^ janvier 1970 00:00:00 UTC. Ainsi, en convertissant les objets de classe `POSIXct` en objet de classe `numeric`, nous obtenons ce nombre de secondes, par exemple&nbsp;:

```{r}
nb_sec <- as.numeric(trajets$start)
nb_sec[1:20]
```

Ces classes peuvent être manipulées avec les fonctions de `lubridate`, par exemple nous pouvons extraire l'année avec la fonction `year()`&nbsp;:

```{r get_year, message = FALSE}
library(lubridate)
year(trajets$start)[1:20]
```

Aussi, la soustraction de deux objets `POSIXct` nous donne un objet de classe `difftime` qui exprime une durée en seconde:

```{r duree}
duree <- trajets$stop[1] - trajets$start[1]
duree
class(duree)
```
Nous calculons alors les durées pour les différents trajets.

```{r}
trajets$duree_s <- trajets$stop - trajets$start
```

Regardons les distributions de longueurs et de durées en dessinant un histogramme avec la fonction `hist()`. 


```{r histo, fig.width = 9.5}
par(mfrow = c(1, 2)) # figure a deux panneaux côte à côte
hist(trajets$length, 
  breaks = seq(0, 44000, 2000), # spécifie les catégories de longueur
  xlab = "Longueur (m)",
  ylab = "Fréquence",
  main = "" # pas de titre
) 
hist(as.numeric(trajets$duree_s), 
  breaks = seq(0, 20000, 1000),
  xlab = "Durée (s)",
  ylab = "Fréquence",
  main = "" # pas de titre
)
```

Nous rajoutons maintenant une colonne `vitesse_m_s` à `trajets` qui est la vitesse moyenne exprimé en mètre par seconde. 

```{r vitesse}
trajets$vitesse_m_s <- trajets$length/as.numeric(trajets$duree_s)
```

Il peut être préférable d'exprimer ces vitesse en kilomètre par heure, pour cela il nous suffit de diviser par 1000 pour convertir les mètres en kilomètres et multiplier les secondes par 3600 pour les convertir en heures, ce qui revient à multiplier par 3.6

```{r kms}
trajets$vitesse_km_h <- trajets$vitesse_m_s*3.6
```

Nous allons maintenant ordonner les vitesse avec et regarder les 10 premieères valeurs: 

```{r sort_vitesse}
vit_dec <- sort(trajets$vitesse_km_h, decreasing = TRUE)[1:10]
```
Le premier va a une vitesse de `r format(vit_dec[1], digits = 3)`&nbsp;km/h, ce qui ne semble pas réaliste et un problème d'enregistrement est probablement à l'origine, nous excluons ce trajet le second et retenons le second comme étant le plus rapide. Pour l'extraire, nous utiliser la fonction `order()`...

```{r traj_rapide}
traj_rapide <- trajets[order(trajets$vitesse_km_h, decreasing = TRUE)[2], ]
traj_rapide 
```

... et nous le visualisons avec `mapview`.

```{r}
library(mapview)
mapview(traj_rapide)
```

Un trajet bien singulier, à 22h près du parc Laurier.




#### Quelle est période de l'année favorite des cyclistes du jeu de données?


Pour répondre à cette deuxième question, nous allons commencer par identifier le mois de l'année qui compte le plus de trajet à vélo (les trajets on été enregistrés en 2013). Pour cela, nous allons utiliser la fonction `month()` de la bibliothèque `lubridate`. Cette fonction nous retourne le mois associé à un objet de classe `POSIXct`

```{r fun_month}
month(trajets$start[1])
```

`month` nous offre aussi la possibilité d'utiliser les noms de mois sous forme de facteurs, de manière abbréviés&nbsp;:

```{r}
month(trajets$start[1], label = TRUE)
```

ou complet&nbsp;:

```{r}
month(trajets$start[1], label = TRUE, abbr = FALSE)
```

Nous utilisons seulement les numéros de mois et nous créons une colonne `month` dans la table d'attribut de `trajets` pour les conserver&nbsp;:

```{r}
trajets$mois <- month(trajets$start)
```

une manière efficace de compter le nombre d'occurrence est d'appliquer la fonction `table()` sur la colonne nouvellement créée&nbsp;:

```{r table_month}
nb_mois <- table(trajets$mois)
nb_mois 
```

Juillet est donc le mois qui concentre le plus de trajet à vélo dans le jeu de données étudié. Nous allons maintenant regardé le jour qui concentre le plus de trajet avec la fonction `day()`. Nous commençons par ajouter une colonne `jour` 

```{r jour}
trajets$jour <- day(trajets$start)
```

puis nous isolons que les trajets qui sont en juillet

```{r traj_juillet, fig.width = 9.5}
traj_juillet <- trajets[trajets$mois == 7, ]
```

puis nous visualiser le nombre de trajet par jour avec les fonctions `table()` et `barplot()` cette fois-ci. 

```{r barplot_day, fig.width = 9.5}
barplot(
  table(traj_juillet$jour),
  xlab = "Jour de juillet",
  ylab = "Nombre de trajets"
)
```

C'est donc le 10 juillet que nous recensons le plus grand nombre de trajets.
Nous allons même aller à l'échelle de l'heure et nous recommençons les étapes précédentes avec la fonction `hour`. Au passage mentionnons la la bibliothèque [`hms`](https://CRAN.R-project.org/package=hms) pour manipuler les heures, minutes et secondes (nous ne l'utiliserons pas ici, mais elles pourraient vous être utile).

```{r traj_10juillet, fig.width = 9.5}
trajets$heure <- hour(trajets$start)
traj_10juillet <- trajets[trajets$mois == 7 & trajets$jour == 10, ]
barplot(
  table(traj_10juillet$heure),
  xlab = "Jour de juillet",
  ylab = "Nombre de trajets"
)
```

C'est donc à 17h le 10 juillet que les trajets sont le plus nombreux.





### Visualisons

Nous allons à présent faire une animer le chemin le plus long. Pour y arriver nous devrons faire les étapes suivantes&nbsp;:


 qui montrera le chemin le plus. 
Passé un peu plus de temps pour visualiser les données. 

```{r}
library(mapview)
traj_long <- trajets[which.max(trajets$length), ]
mapview(traj_long)
```

```{r}
traj_long$n_coord
```


```{r}
traj_long_pts <- st_as_sf(st_cast(st_geometry(traj_long), "POINT"))
traj_long_pts$temps <- seq(traj_long$start, traj_long$stop, length.out = nrow(traj_long_pts))
```

```{r}
txt_temps <- function(temps) {
  paste0("Temps: ", hour(temps), "h ", minute(temps), "m ", floor(second(temps)), "s")
} 
txt_distance <- function(line) {
  len <- st_length(line)
  paste0(" - Distance parcourue: ", format(as.numeric(len)/1000, digits = 4), "km")
}
visual <- function(n = 100, basemap = NULL) {
  tps <- traj_long_pts$temps[n]
  pts <- traj_long_pts[seq_len(n),]
  lin <- st_cast(st_combine(pts), "LINESTRING")
  basemap + 
  tm_shape(lin, bbox = st_bbox(traj_long_pts)) + 
    tm_lines(size = .25, col = "#62852eaa") +
    tm_layout(title = paste(txt_temps(tps), txt_distance(lin)) , title.position = c("right","top"))
}
animation <- function(nb_img = 10, basemap = NULL) {
  tmap_mode("plot")
  for (i in floor(seq(2, nrow(traj_long_pts), length.out = nb_img))) {
    print(visual(i, basemap))
  }
}
```

```R
library(animation)
library(tmap)
library(rosm)
x <- osm.raster(extent(traj_long_pts), crop = TRUE)

saveGIF(animation(10, tm_shape(x) + tm_rgb()))
```

![](Module9/img/animation.gif)









### Précipitations et Température autour du Mont-Mégantic. 

#### Importer les données 

Les données sont au format [NetCDF (Network Common Data Form) ](https://fr.wikipedia.org/wiki/NetCDF)
et peuvent être importées de la sorte. 
<!-- TODO prendre les données de chelsa -->

```{r stack}
library(raster)
mint <- stack("Module9/data/mint.nc")
maxt <- stack("Module9/data/maxt.nc")
pcp <- stack("Module9/data/pcp.nc")
```


#### Les stack de raster

- Dans ce chapitre, on veut jouer avec les `rasterStack`. Préparation d'un `rasterStack` avec la précipitation totale par mois pour le même bonding box que le raster de DEM. 


```{r}
class(mint)
class(mint[[1]])
```

`rasterStack` est une collection d'objet de class `rasterLayer`.



```{r}
extent(mint)
projection(mint)
```

```{r manip_stack}
dim(mint)
ncell(mint)
nlayers(mint)
```

Facilement extraire les différentes couches avec `[[()`


```{r}
class(mint[[1:3]])
class(mint[[1]])
```


```{r}
mapview(mint[[1:3]])
```

```{r}
getValues(mint)
summary(mint)
```

TODO 
<!-- crop -->

```{r}
plot(max(mint))
plot(max(mint))
```

```{r}
quantile(mint)
```

```{r}
plot(calc(mint, quantile)) 
```



```{r}
paste0(rep(1:12, 10), "/", rep(1:10, each = 12))
temps <- my(paste0(rep(1:12, 10), "/", rep(1:10, each = 12)))
names(mint) <- paste0(temps)
```

```{r setZ}
mint <- setZ(mint, temps)
getZ(mint)
```

```{r}
temps <- my(paste0(rep(1:12, 10), rep(1:10, each = 12)))
names(mint) <- paste0(temps)
```



#### Question 1

* Quelle est le mois disposant du plus faible niveau de pluviométrie pour le parc national possédant ce sommet?


1. cropper elevation raster autour du parc

2. Sur dix ans, mois par mois


```{r}
ra_mean <- list()
for (i in 1:12) {
  ra_mean[[i]] <- mean(mint[[i + (0:9)*12]])
}
ra <- stack(ra_mean)
names(ra) <- month.name[1:12]
plot(ra)
```


```{r}
val <- apply(getValues(ra), 2, mean)
val 
which.min(val)
```


* Trouver le mois le moins pluvieux pour préparer notre saison de randonnée.

- On extract les valeurs de précipitation (par mois) du rasterStack pour le parc que l'on a ciblé
- On montre comment on peut réaliser une moyenne entre deux mois rasterStack[[1]] + rasterStack[[2]] / 2 ou alors mean rasterStack[[1:2]]. 

- which.min pour déterminer le raster du stack disposant de la plus petite valeur
- Compléter avec d'autre chose, ca me parait léger... à voir quand au dessus ce sera écrit..


#### Profile temperature et precipitation


```{r}
# TODO le mettre en fonction!
plot(0.1*apply(getValues(mint), 2, mean), type = "l", lty = 2)
lines(1:120, apply(getValues(maxt), 2, mean), lty = 2, col = 2)
```


#### Visualisation

<!-- profile et raster a coté avec le parc -->
<!-- 
plot(mint[[2]]) 
plot(0.1*apply(getValues(mint), 2, mean), type = "l", lty = 2) -->


### Remarques finales

L'écosystème de package R est toujours en activement, aisn quelque années
vous pourrez faire les même opérations avec des finctoins au nom similaires. 
Cela dit tout ce qui a été vu ici reste valid.




## Exercice {#ex_spatiotemp}


