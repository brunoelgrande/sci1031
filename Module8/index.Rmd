# Manipulation de données matricielles {#manip_mat}


L'objectif principal de ce module est de manipuler conjointement des données matricielles et vectorielles pour résoudre des problèmes spatiaux précis.

À la fin de ce module vous saurez:

- Sélectionner des cellules d'un raster selon leur valeur.
- Sélectionner des cellules d'un raster selon leur coordonnée.
- Découper un raster en utiliser un rectangle de délimitation.
- Découper un raster en utiliser un objet vectoriel.

Vous utiliserez les bibliothèques suivantes:

- `mapview`
- `raster`
- `sf`

Vous apprendrez à utiliser les fonctions suivantes:

- `getValues()`
- `nrow()`, `ncol()` et `ncell()`
- `as.data.frame()`
- `crop()` `mask()`
- `extract()`
- `plot()`


Dans la section Leçon, vous utiliserez des données de parc nationaux québécois.

Dans la section Exercice, vous utiliserez TODO

```{r load-libraries8, echo = FALSE, results = 'hide', warning = FALSE, message = FALSE}
library(raster)
library(sf)
```


## Leçon

Au [module 5](#mat), vous avez appris les fonctions essentielles pour lire et visualiser des données spatiales matricielles sous R. Le présent module vous amènera maintenant à manipuler conjointement des données matricielles et vectorielles pour répondre à des questions précises.


### Importer les données

Dans le cadre de cette leçon, nous allons repartir des 4 parcs nationaux présents dans le secteur de la ville de Sherbrooke. Nous allons utiliser le modèle d'élévation numérique aussi appelé *Digital Elevation Model* (DEM). Cette couche d'information spatiale (donnée matricielle) est produite par le gouvernement du Canada ([accessible sur ce portail](https://maps.canada.ca/czs/index-en.html)) est une matrice contenant l'élévation. Nous allons, dans un premier temps, extraire et manipuler les valeurs d'élévation des parcs de la région de Sherbrooke. Nous allons isoler le parc disposant du plus haut point culminant. Enfin, nous dresserons le profil d'élévation du sentier de randonnées de la SÉPAQ (LINESTRINGS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/sentiers-estivaux)) se rendant au plus proche de se point culminant. 

Afin de faciliter l'importation de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargez en cliquant sur un seul lien: [données sur l'élévation et les parcs de la région de Sherbrooke](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Elevation_Parcs_Sherbrooke.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Donnees` pour ce module, et dézippez-le. Le dossier `Elevation_Parcs_Sherbrooke` comprend deux sous-dossiers et un fichier:

- buffer_sherbrooke
- parcs_sherbrooke
- DEM.tif


Afin de se familiariser avec la manipulation de données matricielles, nous allons explorer le région de Sherbrooke en se posant deux questions. Dans la première partie, nous manipulerons les données d'élévation pour répondre à l’interrogation suivante: 

* **Parmi les 4 parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?**

Celle-ci demande d’extraire l'ensemble des valeurs d'élévation associées aux 4 parcs et de les comparer. Cela nous amènera à manipuler conjointement des données matricielles et vectorielles.

En deuxième partie, nous chercherons à répondre à la question suivante:

* **Quelle est le profil topographique du sentier se rendant au plus proche de ce sommet?**

Ce qui nécessite de nouvelles extraction et surtout une étape de visualisation. 

Dans ce chapitre, nous allons passer détailler chacune des étapes réalisées en vue de répondre à nos deux questions.



### Parmi les 4 parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?

#### Suite d'opérations à réaliser

Pour parvenir il faut 


Dans la suite, nous completer ce qui a été vu au chapire aisb reste indispensavle aurons donc besoin d'extraire les données de raster, si votre mémoire fait défaut, reportez-vous au [module 5](#mat) pour plus de détails.


#### Importation des données {-}

Dans un premier temps, nous allons charger dans l'environnement R, les différentes couches d'informations spatiales. Nous Commençons par charger les bibliothèques requises pour importer les données spatiales vectorielles (`sf`), et les données spatiales matricielles (`raster`).

```{r load80}
library(sf)
library(raster)
```

On charge également la bibliothèque `mapview` permettant de visualiser les données spatiales.

```{r, warning = FALSE}
library(mapview)
```

Maintenant, nous importons le *shapefile* des 4 parcs de la régions de Sherbrooke que nous avons isolé à l'intérieur du module 7. 

```{r, eval = FALSE}
chemin <- "D:/votrechemin/SCI1031/Module8/Donnees/"
chemin_parcs <- paste(chemin, "/parcs_sherbrooke/parcs_sherbrooke.shp", sep = "")
parcs <- st_read(chemin_parcs)
```

```{r, echo = FALSE}
parcs <- st_read("Module8/data/parcs_sherbrooke/parcs_sherbrooke.shp")
```

Enfin, nous importons la couche d'élévation pour la région d'intérêt.

```{r, eval = FALSE}
chemin_dem <- paste(chemin, "/DEM.tif", sep = "")
dem <- raster(chemin_dem)
```

```{r, echo = FALSE}
dem <- raster("Module8/data/DEM.tif")
```

Nous visualisons ensuite les deux objets spatiaux afin de valider l'importation.

```{r, warning=FALSE}
mapview(dem) + mapview(parcs, zcol = "TRQ_NM_", legend = FALSE)
```




#### Modifier les valeurs contenues dans le raster {-}

Après avoir exploré la distribution des valeurs avec `summary(getValues(dem))`, on a pu s'apercevoir que certains pixels contenaient des valeurs négatives. Ces valeurs ne sont pas aberrantes et signifient que ces pixels se retrouvent en dessous du niveau de la mer. Nous allons cependant leur assigné une valeur de `NA`. La première approche consiste à tester les valeurs et les remplacer si elles rencontrent la condition: `valeur < 0`.

```{r}
which(getValues(dem) < 0)
```

La fonction `which` permet de renvoyer les numéros de pixels qui satisfont la condition du test logique `getValues(dem) < 0`. On souhaite à présent remplacer ces valeurs par `NA`.

```{r}
dem[which(getValues(dem) < 0)] <- NA
```

On peut valider que l'opération a été complété avec succès en effectuant une seconde fois le test logique.

```{r}
which(getValues(dem) < 0)
```

`integer(0)` indique qu'aucun pixel dispose d'une valeur inférieur à 0.

Si l'on veut modifier le domaine de valeurs d'un raster, une seconde approche consiste à utiliser la fonction `reclassify()`. Imaginons que l'on désire catégoriser le niveau d'élévation en 3 classes / catégories: de 0 à 250m comme une classe d'élévation faible, de 251 à 500m comme modérée et enfin 501 à 1200 comme classe forte. La fonction `reclassify()` nécessite une matrice comprenant les bornes limites des différentes classes. Note: N'oubliez pas qu'un raster ne peut pas entreposé de valeurs de type `factor` , c.a.d en caractère. Nous allons donc assigné un entier (1 à 3 pour faible à forte) comme étant un identifiant de la classe. La première étape consiste à construire la matrice permettant de re-classifier le domaine de valeurs du raster.

```{r}
new_class <- matrix(c(0, 250, 1, 250, 500, 2, 500, 1200, 3), nrow = 3, ncol = 3, byrow = TRUE)
colnames(new_class) <- c("from", "to", "new_class")
new_class
```

Cette matrice est utilisée comme argument de la fonction `reclassify()` afin de déterminer les nouvelles classes de valeurs.

```{r}
new_class_dem <- reclassify(dem, new_class)
```

On peut valider la nouvelle classification du domaine de valeurs du raster d'élévation `dem` à l'aide de la fonction `mapview()`.

```{r, warning=FALSE}
mapview(new_class_dem)
```

#### Changer la résolution d'un raster {-}

La résolution spatiale d'un raster fait référence à la taille des pixels d'un raster. Tous les pixels d'un raster disposent d'une taille identique. La résolution peut cependant différé entre x (longitude) et y (latitude). Pour connaître la résolution d'un raster on utilise la fonction `res()`.

```{r}
res(dem)
```

On peut s'apercevoir ici que la résolution en `x` (premier élément du vecteur) et y (deuxième élément) est identique et que l'unité de la résolution affiché ici est en degré, telle qu'affiché dans la projection du raster. Ce type d'unité est plus difficilement interprétable. On peut re-projeter le raster dans le système *Conique conforme de Lambert du Québec* (NAD83, EPSG: 32198) afin d'obtenir la résolution en système métrique et non en degré. Cette projection est identique à l'objet spatial `parcs`.

```{r}
st_crs(parcs) 
dem_lcc <- projectRaster(dem, crs = crs(parcs))
res(dem_lcc)
```

La largeur (x) d'un pixel est de `r res(dem_lcc)[1]`&nbsp;m de largeur et `r res(dem_lcc)[2]`&nbsp;m de hauteur.

Parfois, il peut être utile d'ajuster la résolution d'un raster afin de conduire des analyses sur des tailles de pixels de références. Par exemple, nous voudrions que chaque pixel du modèle d'élévation numérique (DEM) est une taille prédéfinis de 500 par 500 mètres. La première étape consiste à créer un raster de référence disposant de cette résolution.

```{r}
dem500 <- raster(extent(dem_lcc), res = 500, crs = crs(dem_lcc))
```
On utilise `extent()` pour créer un nouveau raster de référence (`dem500`) dont l'étendu spatiale est identique à celle du raster d'élévation `dem_lcc`. On définit la résolution à 500 mètres à l'aide de l'argument `res`. Enfin, on définit la projection comme identique au raster d'élévation avec la fonction (`crs()`). 

```{r}
head(getValues(dem500)) 
```

Par défaut, les pixels du nouveau raster possèdent tous une valeur `NA`. La dernière étape consiste à échantillonner le raster d'élévation afin de remplir le raster de référence avec les valeurs du raster d'élévation. La fonction `resample()` permet d'aller échantillonner les valeurs selon deux méthodes.

```{r, echo=FALSE,out.width="49%", out.height="20%",fig.cap="caption",fig.show='hold',fig.align='center', fig.cap = "Méthodes de ré-échantillonnage d'un raster de référence vide à partir d'un autre raster contenant des valeurs. Figures adaptés de [Arcgis Pro](https://pro.arcgis.com/fr/pro-app/help/analysis/spatial-analyst/performing-analysis/cell-size-and-resampling-in-analysis.htm)"}
knitr::include_graphics("Module8/images/resampling.png")
``` 

- Méthode A: L'affectation par le voisin le plus proche est la technique de rééchantillonnage la plus adaptée aux données discrètes (catégoriques) car elle ne modifie pas la valeur des pixels en entrée. L'affectation par le voisin le plus proche détermine l'emplacement du centre du pixel la plus proche (bleu) sur le raster en entrée et attribue la valeur de ce pixel au pixel du raster en sortie. Cette méthode présente l'avantage qu'elle ne modifie en rien les valeurs.

- Méthode B: L'interpolation bilinéaire utilise les centroïdes des quatre pixels (en bleu) les plus proches pour déterminer la valeur sur du pixel en sortie (rouge). La nouvelle valeur pour le pixel (rouge) correspond à la moyenne pondérée de ces quatre valeurs (bleu), ajustée pour tenir compte de la distance les séparant du centre de la cellule en sortie. Cette méthode d'interpolation crée une surface à l'aspect plus lisse qu'avec l'affectation par le voisin le plus proche.

Afin d'obtenir des valeurs de pixels contenus dans `dem_lcc`, nous allons utiliser la méthode A.

```{r}
dem500 <- resample(dem_lcc, dem500, method = "ngb")
dem500
```

On a présent un nouveau raster d'élévation dont la résolution d'un pixel est de 100 mètres par 100 mètres.
On peut également facilement changer la résolution de ce raster à l'aide des fonctions `disaggregate()` et `aggregate()`. Par exemple, il est possible de diminuer la résolution du raster par 10 (1 pixel = 1000 mètres par 1000 mètres) à l'aide de la fonction suivante:

```{r}
dem1000 <- aggregate(dem500, fact = 2, fun = max, na.rm = TRUE)
```

L'argument `fact` permet de spécifier le facteur d’agrégation et l'argument `fun` précise quelle fonction sera utilisé pour réaliser l’agrégation 4 des pixels ensemble. Si l'on veut augmenter la résolution d'un raster on utilisera la fonction `disaggregate()`. 





### Parmi les 4 parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?

Nous avons à présent couvert les opérations sur un raster permettant de vérifier sa composition et la distribution de ses valeurs. Nous pouvons maintenant passer à répondre à la première question qui vise à déterminer parmi les 4 parcs nationaux dans un rayon de 70&nbsp;kms autour de Sherbrooke lequel dispose du plus haut sommet. 

La première étape consiste à isoler les pixels se retrouvant dans les 4 parcs nationaux. Pour cela, on utilise la fonction `mask()`. 

```{r, warning = FALSE}
dem_parcs <- mask(dem_lcc, parcs)
mapview(dem_parcs)
```

La fonction `mask()` attribue une valeur `NA` aux pixels se retrouvant à l'extérieur des 4 parcs (polygones contenus dans l'objet `parcs`). On a ainsi isoler les valeurs d'élévation se retrouvant à l'intérieur des parcs.
On peut maintenant retourner la valeur d'élévation la plus élevé en utilisant la fonction `max()`. On désire conserver cette valeur maximale afin d'isoler les pixels du raster `dem_parcs` disposant de cette valeur.

```{r}
max(getValues(dem_parcs), na.rm = TRUE)
vmax <- max(getValues(dem_parcs), na.rm = TRUE)
```

L'étape suivante consiste à isoler le pixel disposant de cette valeur et d'obtenir sa coordonnée. Pour cela, on transforme le raster en `data.frame` avec la fonction `as.data.frame()` tel que vue précédemment. 

```{r}
df_dem_parcs <- as.data.frame(dem_parcs, xy = TRUE, centroid = TRUE, na.rm = TRUE)
head(df_dem_parcs)
```

On retire les valeurs masquées (`NA`) en utilisant l'argument `na.rm=FALSE` puisque ces dernières ne nous intéressent pas. On s'assure également d'obtenir la coordonnées au centre du pixel avec `centroid = TRUE`. On peut à présent d'isoler la ligne du `data.frame` (1 ligne = 1 pixel) contenant la valeur maximale d'élévation (contenu dans `vmax`). Pour cela, on utilise la fonction `subset()`.

```{r}
df_max_elev <- subset(df_dem_parcs, DEM == vmax) 
df_max_elev
```

Une fois isolé, les coordonnées du pixel (x et y) peuvent être utilisé pour un créer un objet spatial (POINT) contenant le centroïde de ce pixel grâce à la fonction `st_as_sf()`. On n'oublie pas de spécifier que le système de projection est identique à celui du raster d'élévation (`dem_parcs`) pour les 4 parcs autours de la ville de Sherbrooke. Nous nous servirons par la suite de ce point pour vérifier dans lequel des 4 parc nationaux il se retrouve. 

```{r}
sf_point_max_elev <- st_as_sf(df_max_elev, coords = c("x", "y"), crs = 32198)
sf_point_max_elev
```

Une autre façon d'obtenir le point d'élévation maximal est d'utiliser la fonction `rasterToPoints()` de la manière suivante:

```{r}
sp_max_elev <- rasterToPoints(dem_parcs, fun = function(x) x == vmax, spatial = TRUE)
st_as_sf(sp_max_elev)
```

L'objet renvoyé par la fonction `rasterToPoints(... , spatial = TRUE)` permet d'obtenir un objet spatial contenant également le point d'élévation maximale. Cependant, la classe d'objet retourné ne provient pas de la bibliothèque `sf` mais de la bibliothèque `sp`. Cette bibliothèque spatiale est plus ancienne et ne sera pas abordé dans ce cours, puisque elle est amené à être remplacé par la bibliothèque `sf`. Si jamais vous devez l'utiliser ailleurs que dans ce cours, sachez qu'il est possible de convertir un objet de classe `sf` à tout moment vers la classe `sp` grâce à la fonction `as(... , "Spatial")`. En voici un exemple. Cette conversion est possible pour l'ensemble des couches spatiales vectorielles mais ne s'applique par aux rasters.


```{r}
as(sf_point_max_elev, "Spatial")
```

En superposant les couches d'informations spatiales avec `mapview`, on peut observer dans quel parc se retrouve à présent ce point d'élévation maximal. 

```{r, fig.cap = "En cliquant sur le polygon du parc contenant le point rouge (point d'élévation maximal), il est possible de constater que le point se retrouve dans le Parc national du Mont-mégantic", warning=FALSE}
mapview(dem_parcs) + mapview(parcs, alpha = 0.01) + mapview(sf_point_max_elev,  col.regions = "red")
```

Ce point se retrouve dans le **Parc national du Mont-Mégantic**. On réalise à présent une opération sur la topologie permettant d'isoler le polygon du parc dans lequel se retrouve ce point. 

```{r}
parcs[which(st_intersects(parcs, sf_point_max_elev, sparse = FALSE) == TRUE), ]
```

NOTE: Cette opération pourrait être réécrite beaucoup plus simplement sous la forme:

```{r}
parcs[sf_point_max_elev,]
```

Cette syntaxe permet d'isoler le polygon du parc mégantic dans lequel se retrouve le point culminant entre les 4 parcs.




### Quelle est le profil topographique du sentier se rendant au plus proche de ce sommet?

Le sommet le plus élevé des parcs nationaux se situe dans le Parc national du Mont-Mégantic. On désire maintenant se rendre sur ce sommet en randonnée pédestre et réaliser un profil topographique du sentier ce rendant au plus proche. Les profils topographiques sont des outils de visualisation puissants: ils permettant de caractériser le dénivelé et donc l'effort que l'on devra fournir pour compléter cette randonnée. 

```{r geoide2, fig.align='left', echo=FALSE,fig.cap="Exemple de profil topographique: le sentier international des Appalaches", out.width = '100%'}
knitr::include_graphics('Module8/images/gas_coupe_grande_traversee.png')
```

Pour obtenir le sentier estival se retrouvant au plus proche du sommet, il faut croiser deux couches d'informations spatiales: (i) [les sentiers estivaux de la SEPAQ](https://www.donneesquebec.ca/recherche/dataset/sentiers-estivaux) et (ii) la coordonnée géographique du sommet que nous avons isolé précédemment. On utilise la fonction `st_nearest()` afin de sélectionner le sentier (`LINES`) le plus proche du sommet (`POINT`). La première étape consiste à lire le fichier de forme (*shapefile*).

```{r, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module8/Donnees/"
chemin_sentiers <- paste(chemin, "/sentiers_sepaq/Sentier_ete_l.shp", sep = "")
sentiers <- st_read(chemin_parcs)
```

```{r, echo = FALSE}
sentiers <- st_read("Module8/data/sentiers_sepaq/Sentier_ete_l.shp")
```

Nous pouvons à présent inspecter visuellement cette couche d'information spatiale.

```{r}
mapview(sentiers)
```

En se référant à la section TODO, on peut à présent isoler les sentiers se retrouvant à l'intérieur du parc du Mont-Mégantic.

parc_megantic <- subset(parcs, TRQ_NM_ == 'Parc national du Mont-Mégantic')
sentiers_megantic <- sentiers[parc_megantic,]



# mapview(sentiers[st_nearest_feature(sf_point_max_elev, sentiers),])

pour cela, on doit croiser les couches spatiales des sentiers estivaux de ce parc avec le 

- Isoler le sentier le plus proche du sommet (st_nearest)
- Puis, extraire les pixels du rasters se retrouvant sous la ligne du sentier (extract)
- mapview des pixels passant sous la ligne du sentier
- On montre habituellement les figures (distance parcourue vs élévation) présenté par la SEPAQ, on veut améliorer le rendu visuelle.
- Utiliser la resolution du raster pour déterminer la distance inter-pixels - Ici ca va prendre de l'illustration pour être sûr que la notion est saisie
- Faire la figure de distance cumulée versus élévation 
- On vient de répondre à notre question







## Exercice {#ex_mat_manip}
