# Manipulation de données matricielles {#manip_mat}


L'objectif principal de ce module est de manipuler conjointement des données matricielles et vectorielles pour résoudre des problèmes spatiaux précis.

À la fin de ce module vous saurez:

- Filtrer des cellules d'un raster selon leur valeur.
- Filtrer des cellules d'un raster selon leur coordonnée.
- Découper un raster en utiliser un rectangle de délimitation.
- Découper un raster en utiliser un objet vectoriel.

Vous utiliserez les bibliothèques suivantes:

- `mapview`
- `raster`
- `sf`

Vous apprendrez à utiliser les fonctions suivantes:

- `getValues()`
- `nrow()`, `ncol()` et `ncell()`
- `summary()`
- `which()`
- `as.data.frame()`, `data.frame()`
- `extent()`
- `plot()`
- `crop()` `mask()`
- `extract()`
- `st_crs()`
- `st_sfc()`, `st_polygon()`, `st_as_sf()`



Dans la section Leçon, vous utiliserez des données de parc nationaux québécois.

Dans la section Exercice, vous utiliserez TODO

```{r load-libraries8, echo = FALSE, results = 'hide', warning = FALSE, message = FALSE}
library(raster)
library(sf)
```


## Leçon

Au [module 5](#mat), vous avez appris les fonctions essentielles pour lire et visualiser des données spatiales matricielles sous R. Le présent module vous amènera maintenant à manipuler conjointement des données matricielles et vectorielles pour répondre à des questions précises. Nous allons en effet explorer le région de Sherbrooke en se posant deux questions. Dans la première partie, nous manipulerons les données d'élévation pour répondre à l’interrogation suivante: 

* **Parmi les 4 parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?**

Celle-ci demande d’extraire l'ensemble des valeurs d'élévation associées aux 4 parcs et de les comparer. Cela nous amènera à manipuler conjointement des données matricielles et vectorielles.

En deuxième partie, nous chercherons à répondre à la question suivante:

* **Quelle est le profil topographique du sentier se rendant au plus proche de ce sommet?**

Ce qui nécessite de nouvelles extraction et surtout une étape de visualisation. 

Dans ce chapitre, nous allons détailler chacune des étapes réalisées en vue de répondre à nos deux questions. Nous commencerons par importer les données et compléter les modules [3](#vec), [5](#mat) et [7]({#manip_vec}) en montrant comment filtrer des cellules d'un raster en utilisant leur valeur et leur coordonnée spatiale.



### Importer les données

Dans le cadre de cette leçon, nous allons repartir des 4 parcs nationaux présents dans le secteur de la ville de Sherbrooke. Nous allons utiliser le modèle d'élévation numérique aussi appelé *Digital Elevation Model* (DEM). Cette couche d'information spatiale (donnée matricielle) est produite par le gouvernement du Canada ([accessible sur ce portail](https://maps.canada.ca/czs/index-en.html)) est une matrice contenant l'élévation. Nous allons, dans un premier temps, extraire et manipuler les valeurs d'élévation des parcs de la région de Sherbrooke. Nous allons isoler le parc disposant du plus haut point culminant. Enfin, nous dresserons le profil d'élévation du sentier de randonnées de la SÉPAQ (LINESTRINGS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/sentiers-estivaux)) se rendant au plus proche de se point culminant. 

Afin de faciliter l'importation de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargez en cliquant sur un seul lien: [données sur l'élévation et les parcs de la région de Sherbrooke](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Elevation_Parcs_Sherbrooke.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Donnees` pour ce module, et dézippez-le. Le dossier `Elevation_Parcs_Sherbrooke` comprend deux sous-dossiers et un fichier:

- buffer_sherbrooke
- parcs_sherbrooke
- DEM.tif

Nous allons charger ces différentes couches d'informations spatiales dans l'environnement R. Nous commençons par charger les bibliothèques requises pour importer les données spatiales vectorielles (`sf`), et les données spatiales matricielles (`raster`) et les visualiser (`mapview`).

```{r load80, warning = FALSE}
library(sf)
library(raster)
library(mapview)
```

Maintenant, nous importons le *shapefile* des 4 parcs de la régions de Sherbrooke que nous avons isolé à l'intérieur du module 7. 

```{r, eval = FALSE}
chemin <- "D:/votrechemin/SCI1031/Module8/Donnees/"
chemin_parcs <- paste(chemin, "/parcs_sherbrooke/parcs_sherbrooke.shp", sep = "")
parcs <- st_read(chemin_parcs)
```

```{r, echo = FALSE}
parcs <- st_read("Module8/data/parcs_sherbrooke/parcs_sherbrooke.shp")
```

Enfin, nous importons la couche d'élévation pour la région d'intérêt.

```{r, eval = FALSE}
chemin_dem <- paste(chemin, "/DEM.tif", sep = "")
dem <- raster(chemin_dem)
```

```{r, echo = FALSE}
dem <- raster("Module8/data/DEM.tif")
```

Nous visualisons ensuite les deux objets spatiaux afin de valider l'importation.

```{r, warning = FALSE}
mapview(dem) + mapview(parcs, zcol = "TRQ_NM_", legend = FALSE)
```






### Filtrer les cellules d'un raster 

Comme indiquer ci-dessus pour réaliser l'ensemble des opérations, nous allons avoir besoin de filter des données spatiales selon leur valeur et leur coordonnée spatiale. Nous allons détailler comment procéder dans cette section.


#### Filtrer en utilisant la valeur des cellules

Au [module 5](#mat), nous avons vu comment accéder et manipuler les données de raster, en utilisant, entre autres, `getValues()`. 
Par exemple, il est possible d'avoir une idée de la distribution des valeurs de `dem` en utilisant la ligne suivante :

```{R getval_dem}
summary(getValues(dem))
```

Avec cette commande, nous pouvons nous apercevoir que certains pixels
contenaient des valeurs négatives. Ces valeurs ne sont pas aberrantes et
signifient que ces pixels se retrouvent en dessous du niveau de la mer. Pour la
suite du module (et à titre d'exemple), nous allons exclure ces valeurs
négatives. En d'autre terme, nous allons appliquer un filtre sur les cellules du
raster, filtre qui ne laisse passé que les valeurs positives. Avant cela, nous allons voir comment identifier les cellules avec la function `which()`. Cette fonction nous permet d'identifié les `TRUE` dans un vecteur logique, par exemple: 

```{r which}
which(c(1, 2, 1) == 2)
```
Nous pouvons aussi l'utiliser pour les valeurs d'un raster et ici, nous allons le faire pour trouver identifier les cellules qui ont des valeurs d'élévation négatives.


```{r}
ind <- which(getValues(dem) < 0)
ind
```

La ligne ci-dessus nous retourne des indices des cellules demandées. Pour savoir combien il y en a, nous pouvons les compter en regardant le vecteur que nous retourne R, mais si les cellules sélectionnées étaient très nombreuses ou si nous avions besoin de ce nombre dans notre code, nous utiliserions `length()` qui nous retourne la taille du vecteur: 

```{r}
length(ind)
```

Notez qu'il est aussi possible d'accéder aux valeurs en utilisant ces indices:

```{r}
getValues(dem)[ind]
```

Pour filtrer ces données, nous allons remplacer les valeurs des cellules identifiées par `NA`.

```{r}
dem[ind] <- NA
summary(getValues(dem))
```

L'élévation minimale est maintenant de 0 et le nombre de `NA` a augmenté de `r length(ind)`, notre filtre a bien été appliqué. 

Avec l'approche présentée nous pouvons utiliser des expressions logiques plus complexes. Ainsi, nous pouvons remplacer `getValues(dem) < 0` par `getValues(dem) < 0 | getValues(dem) > 1000` pour aussi exclure cellules avec des valeurs plus grandes que 1000&nbsp;m. De plus, il est aussi possible de changer les valeurs des cellules identifiées en utilisant la valeur désirée à la place de `NA`. La fonction `reclassify()` vous permet de réaliser plusieurs de ces opérations très facilement. Imaginons que nous désirions catégoriser le niveau d'élévation en 3 catégories: de 0 à 250&nbsp;m comme une classe d'élévation faible, de 251 à 500&nbsp;m comme modérée et enfin 501 à 1200&nbsp;m comme classe forte. Nous pouvons utiliser la fonction `reclassify()` pour le faire. Celle-ci nécessite une matrice comprenant les bornes limites des différentes classes et donc la première étape consiste à construire cette matrice.

```{r}
new_class <- matrix(c(0, 250, 1, 250, 500, 2, 500, 1200, 3), nrow = 3, ncol = 3, byrow = TRUE)
colnames(new_class) <- c("from", "to", "new_class")
new_class
```

Cette matrice est utilisée comme argument de la fonction `reclassify()` afin de déterminer les nouvelles classes de valeurs.

```{r reclassify}
new_class_dem <- reclassify(dem, new_class)
```

Visualisons la nouvelle classification du domaine de valeurs du raster d'élévation `dem` à l'aide de la fonction `mapview()`:

```{r, warning = FALSE}
mapview(new_class_dem)
```

Notez que nous pouvons aussi utiliser `NA` pour exclure certaines cellules:

```{r, warning = FALSE}
new_class2 <- matrix(c(0, 250, NA, 250, 500, 2, 500, 1200, 3), nrow = 3, ncol = 3, byrow = TRUE)
mapview(reclassify(dem, new_class2))
```


#### Filtrer en utilisant les coordonnées spatiales des cellules

##### Utiliser `crop()`

Une des opérations les plus fréquentes sur les raster est de filtrer les cellules d'un raster en fonction de leur coordonnée spatiale. Dans cette section nous allons utiliser `crop()` et `mask()` pour réalisé de telle type. 

La fonction `crop()` vous permet de rogner un raster, autrement dit utiliser un rectangle pour filter les cellules selon qu'elles soient ou non dedans. Pour utiliser `crop()`, en plus du raster à rogner, il faut un objet de classe `Extent` qui peut être créé en utilisant les coordonnées des points inférieur-gauche (`xmin`, `ymin`) et supérieur-droit (`xmax`, `ymax`) du rectangle utilisé pour rogner:

```{r extent}
ext <- extent(c(-72, -71.5, 45.2, 45.8))
ext 
```


Avec `plot()`, nous pouvons visualiser quelle partie du raster va être rogner. 

```{r}
plot(dem)
plot(ext, add = TRUE) 
```

Il est très important de relever que de manière implicite les valeurs des coordonnées utilisées dans `extent()` sont exprimées dans le SCR de notre raster `dem`. Nous utilisons maintenant la fonction `crop()` dont le premier argument est le raster à rogner et le second argument l'objet de classe `Extent`.

```{r}
dem_cr <- crop(dem, ext)
```

La sortie est un raster (que nous appelons `dem_cr`) qui est recadré selon `ext`, les cellules qui ne sont pas dans ce rectangle sont exclues.

```{r, warning = FALSE}
mapview(dem_cr)
```

La fonction `crop()` accepte en fait, en second argument, tout object dont un object de classe `Extent` peut être extrait, cela inclut, entre autres, les objets de classe `RasterLayer` et les objets spatiaux de classe `sf`. Nous allons utiliser alors utiliser le premier parc de `parcs` pour rogner `dem`, mais avant, nous avons besoin de re-projeter `dem` dans le SCR de `parcs` (notez que nous aurions pu faire l'inverse). L'opération qui suit utilise l'étendue spatiale de `parcs[1, ]` pour rogner `dem_lcc`.


```{r, warning = FALSE}
dem_lcc <- projectRaster(dem, crs = crs(parcs))
dem_cr_p <- crop(dem_lcc, parcs[1, ])
mapview(dem_cr_p)
```



##### Utiliser `mask()`

Avec la fonction `mask()` il est possible de découper un raster non plus selon un rectangle uniquement, mais selon n'importe quel polygon. Pour illustrer cette fonction nous allons créer un polygon avec `sf`:

```{r pol}
# coordonnées du polygon
mat <- matrix(c(
  -72.5, 45.8,
  -72, 45.5,
  -72.5, 45.2,
  -71.5, 45.2,
  -71.5, 45.8,
  -72.5, 45.8), ncol = 2, byrow = TRUE)
# transform les coordonnées en 1 objet de class sp
pol <- st_as_sf(
    data.frame(
      var = 1,
      geom = st_sfc(st_polygon(x = list(mat)))
      ),
      crs = st_crs(dem) 
  )
```

Notons que nous avons utilisé le même SCR que `dem`. Regardons ce à quoi ressemble le polygon que nous venons de créer.

```{r}
plot(dem)
plot(pol, add = TRUE, col = NA) 
```

Avec `mask()`, nous sélectionnons seulement les cellules qui sont dans `pol` (passé en second argument): 

```{r mask, warning = FALSE}
dem_ma <- mask(dem, pol)
mapview(dem_ma)
```


La fonction `mask()` a également un argument `inverse` qui s'il prend la valeur `TRUE`, nous permet de sélectionner tout ce qui m'est pas dans le polygon, ce que nous faisons ci-dessous.

```{r mask_inv, warning = FALSE}
dem_ma_inv <- mask(dem, pol, inverse = TRUE)
mapview(dem_ma_inv)
```

Nous avons de cette manière réaliser simplement, un filtre spatial relativement complex. Les valeurs de `dem_ma` sont, en effet, seulement le sont ensemble des valeurs des cellules qui sont dans `pol`. Nous avons donc filtré spatialement les données de `dem` et nous avons assigné ce raster à la variable `dem_ma` que nous pouvons alors utiliser comme tout autre raster.

```{r, warning = FALSE}
summary(getValues(dem_ma))
```

Trois remarques pour finir: 

1. L'étendue du raster retourné par `crop()` sera différente de celle du raster initial (sauf si l'étendue initiale est utilisée pour rogner). À l'inverse, `mask()` préserve l'étendue spatiale.

2. L'opération `crop()` est souvent très rapide ce qui n'est pas le cas de `mask()` quand le polygon est complexe. Il est parfois possible d'avoir des gains d'efficacité en faisant un appel à `crop()` avant d'utiliser `mask()`.

3. Dans le cas où seulement les valeur du raster sont à utiliser, il est possible d'appeler `extract()` à la place de `mask()` qui nous retourne une liste chaque élément de la liste correspond au valeur à extraire pour les différentes couche du raster (ici nous n'avons qu'une seule couche).


```{r, warning = FALSE}
summary(extract(dem, pol)[[1]])
```



### Parmi les 4 parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?

Nous sommes maintenant en mesure de répondre à cette première question. Les données étant déjà importées, il nous reste à : 

1. nous assurer que le raster d'élévation `dem` et les limites des parcs `parcs` sont dans le même SCR,

2. uiliser `mask()` pour extraire les cellules de `dem` qui sont dans les parcs nationaux considérés



```{r, eval = FALSE}
st_crs(parcs) 
dem_lcc <- projectRaster(dem, crs = crs(parcs))
res(dem_lcc)
```


Nous avons à présent couvert les opérations sur un raster permettant de vérifier sa composition et la distribution de ses valeurs. Nous pouvons maintenant passer à répondre à la première question qui vise à déterminer parmi les 4 parcs nationaux dans un rayon de 70&nbsp;kms autour de Sherbrooke lequel dispose du plus haut sommet. 

La première étape consiste à isoler les pixels se retrouvant dans les 4 parcs nationaux. Pour cela, on utilise la fonction `mask()`. 

```{r, warning = FALSE}
dem_parcs <- mask(dem_lcc, parcs)
mapview(dem_parcs)
```

La fonction `mask()` attribue une valeur `NA` aux pixels se retrouvant à l'extérieur des 4 parcs (polygones contenus dans l'objet `parcs`). On a ainsi isoler les valeurs d'élévation se retrouvant à l'intérieur des parcs.
On peut maintenant retourner la valeur d'élévation la plus élevé en utilisant la fonction `max()`. On désire conserver cette valeur maximale afin d'isoler les pixels du raster `dem_parcs` disposant de cette valeur.

```{r}
max(getValues(dem_parcs), na.rm = TRUE)
vmax <- max(getValues(dem_parcs), na.rm = TRUE)
```

L'étape suivante consiste à isoler le pixel disposant de cette valeur et d'obtenir sa coordonnée. Pour cela, on transforme le raster en `data.frame` avec la fonction `as.data.frame()` tel que vue précédemment. 

```{r}
df_dem_parcs <- as.data.frame(dem_parcs, xy = TRUE, centroid = TRUE, na.rm = TRUE)
head(df_dem_parcs)
```

On retire les valeurs masquées (`NA`) en utilisant l'argument `na.rm=FALSE` puisque ces dernières ne nous intéressent pas. On s'assure également d'obtenir la coordonnées au centre du pixel avec `centroid = TRUE`. On peut à présent d'isoler la ligne du `data.frame` (1 ligne = 1 pixel) contenant la valeur maximale d'élévation (contenu dans `vmax`). Pour cela, on utilise la fonction `subset()`.

```{r}
df_max_elev <- subset(df_dem_parcs, DEM == vmax) 
df_max_elev
```

Une fois isolé, les coordonnées du pixel (x et y) peuvent être utilisé pour un créer un objet spatial (POINT) contenant le centroïde de ce pixel grâce à la fonction `st_as_sf()`. On n'oublie pas de spécifier que le système de projection est identique à celui du raster d'élévation (`dem_parcs`) pour les 4 parcs autours de la ville de Sherbrooke. Nous nous servirons par la suite de ce point pour vérifier dans lequel des 4 parc nationaux il se retrouve. 

```{r}
sf_point_max_elev <- st_as_sf(df_max_elev, coords = c("x", "y"), crs = 32198)
sf_point_max_elev
```

Une autre façon d'obtenir le point d'élévation maximal est d'utiliser la fonction `rasterToPoints()` de la manière suivante:

```{r}
sp_max_elev <- rasterToPoints(dem_parcs, fun = function(x) x == vmax, spatial = TRUE)
st_as_sf(sp_max_elev)
```

L'objet renvoyé par la fonction `rasterToPoints(... , spatial = TRUE)` permet d'obtenir un objet spatial contenant également le point d'élévation maximale. Cependant, la classe d'objet retourné ne provient pas de la bibliothèque `sf` mais de la bibliothèque `sp`. Cette bibliothèque spatiale est plus ancienne et ne sera pas abordé dans ce cours, puisque elle est amené à être remplacé par la bibliothèque `sf`. Si jamais vous devez l'utiliser ailleurs que dans ce cours, sachez qu'il est possible de convertir un objet de classe `sf` à tout moment vers la classe `sp` grâce à la fonction `as(... , "Spatial")`. En voici un exemple. Cette conversion est possible pour l'ensemble des couches spatiales vectorielles mais ne s'applique par aux rasters.


```{r}
as(sf_point_max_elev, "Spatial")
```

En superposant les couches d'informations spatiales avec `mapview`, on peut observer dans quel parc se retrouve à présent ce point d'élévation maximal. 

```{r, fig.cap = "En cliquant sur le polygon du parc contenant le point rouge (point d'élévation maximal), il est possible de constater que le point se retrouve dans le Parc national du Mont-mégantic", warning=FALSE}
mapview(dem_parcs) + mapview(parcs, alpha = 0.01) + mapview(sf_point_max_elev,  col.regions = "red")
```

Ce point se retrouve dans le **Parc national du Mont-Mégantic**. On réalise à présent une opération sur la topologie permettant d'isoler le polygon du parc dans lequel se retrouve ce point. 

```{r}
parcs[which(st_intersects(parcs, sf_point_max_elev, sparse = FALSE) == TRUE), ]
```

NOTE: Cette opération pourrait être réécrite beaucoup plus simplement sous la forme:

```{r}
parcs[sf_point_max_elev,]
```

Cette syntaxe permet d'isoler le polygon du parc mégantic dans lequel se retrouve le point culminant entre les 4 parcs.







### Quelle est le profil topographique du sentier se rendant au plus proche de ce sommet?

Le sommet le plus élevé des parcs nationaux se situe dans le Parc national du Mont-Mégantic. On désire maintenant se rendre sur ce sommet en randonnée pédestre et réaliser un profil topographique du sentier ce rendant au plus proche. Les profils topographiques sont des outils de visualisation puissants: ils permettant de caractériser le dénivelé et donc l'effort que l'on devra fournir pour compléter cette randonnée. 

```{r geoide2, fig.align='left', echo=FALSE,fig.cap="Exemple de profil topographique: le sentier international des Appalaches", out.width = '100%'}
knitr::include_graphics('Module8/images/gas_coupe_grande_traversee.png')
```

Pour obtenir le sentier estival se retrouvant au plus proche du sommet, il faut croiser deux couches d'informations spatiales: (i) [les sentiers estivaux de la SEPAQ](https://www.donneesquebec.ca/recherche/dataset/sentiers-estivaux) et (ii) la coordonnée géographique du sommet que nous avons isolé précédemment. On utilise la fonction `st_nearest()` afin de sélectionner le sentier (`LINES`) le plus proche du sommet (`POINT`). La première étape consiste à lire le fichier de forme (*shapefile*).

```{r, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module8/Donnees/"
chemin_sentiers <- paste(chemin, "/sentiers_sepaq/Sentier_ete_l.shp", sep = "")
sentiers <- st_read(chemin_parcs)
```

```{r, echo = FALSE}
sentiers <- st_read("Module8/data/sentiers_sepaq/Sentier_ete_l.shp")
```

Nous pouvons à présent inspecter visuellement cette couche d'information spatiale.

```{r}
mapview(sentiers)
```

En se référant à la section TODO, on peut à présent isoler les sentiers se retrouvant à l'intérieur du parc du Mont-Mégantic.

parc_megantic <- subset(parcs, TRQ_NM_ == 'Parc national du Mont-Mégantic')
sentiers_megantic <- sentiers[parc_megantic,]



# mapview(sentiers[st_nearest_feature(sf_point_max_elev, sentiers),])

pour cela, on doit croiser les couches spatiales des sentiers estivaux de ce parc avec le 

- Isoler le sentier le plus proche du sommet (st_nearest)
- Puis, extraire les pixels du rasters se retrouvant sous la ligne du sentier (extract)
- mapview des pixels passant sous la ligne du sentier
- On montre habituellement les figures (distance parcourue vs élévation) présenté par la SEPAQ, on veut améliorer le rendu visuelle.
- Utiliser la resolution du raster pour déterminer la distance inter-pixels - Ici ca va prendre de l'illustration pour être sûr que la notion est saisie
- Faire la figure de distance cumulée versus élévation 
- On vient de répondre à notre question







## Exercice {#ex_mat_manip}
