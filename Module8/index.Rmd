# Manipulation de données matricielles {#manip_mat}


Cette leçon porte sur la manipulation des données spatiales matricielles. Son objectif principal est d'apprendre les fonctions principales pour XXXX. Vous apprendrez aussi à manipuler conjointement des données matricielles et vectorielles pour résoudre des problèmes spatiaux.

À la fin de ce module vous saurez:

- Filtrer des cellules d'un *raster* selon leur valeur.
- Filtrer des cellules d'un *raster* selon leurs coordonnées.
- Découper un *raster* en utilisant un rectangle de délimitation.
- Découper un *raster* en utilisant un objet vectoriel.

Vous utiliserez les bibliothèques suivantes:

- `mapview`
- `raster`
- `sf`

Vous apprendrez à utiliser les fonctions suivantes:


<!-- - `getValues()`
- `nrow()`, `ncol()` et `ncell()`
- `summary()`
- `unique()`
- `subset()`
- `which()`, `which.max()`
- `max()`
- `as.data.frame()`, `data.frame()`
- `extent()`
- `plot()` -->
- `reclassify()`
- `crop()` `mask()`
- `extract()`
<!-- - `crs()`, `st_crs()` -->
<!-- `st_distance()` -->
- `st_sfc()`, `st_polygon()`, `st_as_sf()`
- `st_intersects()` 
- `st_combine()`
- `st_nearest_feature()`
- `xyFromCell()`



Dans la section [Leçon](#lecon_mat_mani), vous utiliserez des données d'élévation pour le Québec et les limites de quatre parcs nationaux québécois.

Dans la section [Exercice](#ex_mat_manip), vous utiliserez XXX

```{r load-libraries8, echo = FALSE, results = 'hide', warning = FALSE, message = FALSE}
library(raster)
library(sf)
```


## Leçon {#lecon_mat_mani}

Au [module 5](#mat), vous avez appris les fonctions essentielles pour lire et visualiser des données spatiales matricielles sous R. Le présent module vous amènera maintenant à XXX et à manipuler conjointement des données matricielles et vectorielles. 

Comme pour le [module 7](#manip_vec) portant sur la manipulation des données vectorielles, la présente leçon est articulée autour d'une problématique donnée qui nécessite de manipuler des données matricielles et vectorielles. Au cours des différentes étapes permettant d'explorer la problématique, vous apprendrez à utiliser diverses fonctions R.

Nous allons en effet explorer le région de la ville de Sherbrooke en se posant deux questions. Dans la première partie, nous manipulerons les données d'élévation pour répondre à l’interrogation suivante: 

> Parmi les quatre parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?

Pour y répondre, nous devrons extraire l'ensemble des valeurs d'élévation associées aux quatre parcs et les comparer. Cela nous amènera à manipuler conjointement des données matricielles et vectorielles.

En deuxième partie, nous chercherons à répondre à la question suivante:

> Quelle est le profil topographique du sentier se rendant au plus proche de ce sommet?

Répondre à cette question nécessite de nouvelles extractions mêlant vecteurs et *raster* ainsi qu'une étape de visualisation. 

Dans cette leçon, nous allons détailler chacune des étapes réalisées en vue de répondre à nos deux questions. Nous commencerons par importer les données et compléter XXXXPAS SURles modules [3](#vec), [5](#mat) et [7]({#manip_vec}) en montrant comment filtrer des cellules d'un raster en utilisant leur valeur et leur coordonnée spatiale.



### Télécharger les données

Dans le cadre de cette leçon, nous allons utiliser le travail réalisé au [module 7]({#manip_vec}) et reprendre les quatre parcs nationaux présents dans le secteur de la ville de Sherbrooke (plus précisément dans un rayon de 70&nbsp;kms autour de Sherbrooke). 

Nous allons aussi utiliser le modèle d'élévation numérique aussi appelé *Digital Elevation Model* (DEM). Cette couche d'information spatiale est produite par le gouvernement du Canada ([accessible sur ce portail](https://maps.canada.ca/czs/index-en.html)). Cette couche est une matrice de données (*raster*) contenant des valeurs d'élévation. 

Afin de faciliter le téléchargement de ces données, l'ensemble de ces couches d'informations spatiales peuvent être téléchargée en cliquant sur un seul lien: [données sur l'élévation et les parcs de la région de Sherbrooke](https://github.com/elisefilotas/Donnees_spatiales/blob/master/Elevation_Parcs_Sherbrooke.zip). Une fois téléchargé, le dossier compressé (`zip`) doit être dézippé dans votre répertoire de travail. Le dossier `Elevation_Parcs_Sherbrooke` comprend deux sous-dossiers et un fichier:

- buffer_sherbrooke
- parcs_sherbrooke
- DEM.tif

### Démarche de résolution

XXX À détailler
Dans un premier temps, nous allons extraire et manipuler les valeurs d'élévation des parcs de la région de Sherbrooke. Nous allons ensuite isoler le parc disposant du plus haut point culminant. Enfin, nous dresserons le profil d'élévation du sentier de randonnées de la SÉPAQ (LINESTRINGS, [source](https://www.donneesquebec.ca/recherche/fr/dataset/sentiers-estivaux)) se rendant au plus proche de se point culminant. 

#### Importer, lire et visualiser les données {-}

Dans allons charger ces différentes couches d'informations spatiales dans l'environnement R. Nous commençons par charger les bibliothèques requises pour importer les données spatiales vectorielles (`sf`), pour importer les données spatiales matricielles (`raster`) et pour visualiser ces données (`mapview`).

```{r load80, warning = FALSE}
library(sf)
library(raster)
library(mapview)
```

Maintenant, nous importons le *shapefile* des 4 parcs de la régions de Sherbrooke que nous avons isolé à l'intérieur du [module 7](#manip_vec) en utilisant la fonction `st_read()`. 
XXX A-t-On sauvegarder ce shapefile au module 7? Pas ŝur de saisir l'utilisation du terme "isolé"

```{r, eval = FALSE}
chemin <- "D:/votrechemin/SCI1031/Module8/Donnees/"
chemin_parcs <- paste(chemin, "/parcs_sherbrooke/parcs_sherbrooke.shp", sep = "")
parcs <- st_read(chemin_parcs)
```

```{r, echo = FALSE}
parcs<-st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module8/data/parcs_sherbrooke/parcs_sherbrooke.shp")
#parcs <- st_read("Module8/data/parcs_sherbrooke/parcs_sherbrooke.shp")
```

Enfin, nous importons la couche d'élévation pour la région d'intérêt en utilisant la fonction `raster()``.

```{r, eval = FALSE}
chemin_dem <- paste(chemin, "/DEM.tif", sep = "")
dem <- raster(chemin_dem)
```

```{r, echo = FALSE}
dem<-raster("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module8/data/DEM.tif")

#dem <- raster("Module8/data/DEM.tif")
```

Nous visualisons ensuite les deux objets spatiaux afin de valider l'importation en utilisant la fonction `mapview()`.

```{r, warning = FALSE}
mapview(dem) + mapview(parcs, zcol = "TRQ_NM_", legend = FALSE)
```
<br>


### Filtrer les cellules d'un *raster* 

XXX
Comme indiqué ci-dessus, afin de réaliser l'ensemble des opérations, nous allons avoir besoin de filtrer des données spatiales selon leur valeur et leur coordonnée spatiale. Nous allons détailler comment utiliser R pour réaliser ces opérations dans cette section.


#### Filtrer en utilisant la valeur des cellules


##### Fonction `which()`
Au [module 5](#mat), nous avons vu comment accéder et manipuler les données de *raster* en utilisant, entre autres, les fonctions `summary()` et `getValues()`. Il est ainsi possible d'avoir une idée de la distribution des valeurs du *raster* `dem` en utilisant la ligne de commande suivante :

```{R getval_dem}
summary(getValues(dem))
```

Nous pouvons apercevoir que certaines cellules du *raster* `dem` contiennent des valeurs négatives. Notez que ces valeurs ne sont pas aberrantes et signifient simplement que ces pixels se retrouvent en dessous du niveau de la mer. Pour la suite de la leçon (et à titre d'exemple), nous allons exclure ces valeurs
négatives. En d'autres termes, nous allons appliquer un filtre sur les cellules du
*raster*, filtre qui ne laissera passé que les valeurs positives. 

Plus précisément, nous allons utiliser la fonction `which()` pour filter les données du *raster* `dem`. Comment fonctionne la fonction `which()`? La fonction `which()` n'est pas spécifique aux données spatiales, c'est une fonction générale qui identifie la position des éléments de valeur `TRUE` dans un vecteur logique. Par exemple: 

```{r which}
#Exemple 1
which(c(TRUE, FALSE, TRUE, FALSE, TRUE))

#Exemple 2
which(c(1, 1, 2) == 2)
```
Nous pouvons aussi appliquer la fonction `which()` pour filtrer les valeurs d'un *raster*. Utilisons donc cette fonction pour trouver les cellules qui ont des valeurs d'élévation négatives.


```{r}
ind <- which(getValues(dem) < 0)
ind
```

La ligne de commande ci-dessus retourne les **indices** des cellules qui satisfont la condition demandée (c'est-à-dire avoir une valeur négative). 

Pour savoir combien de cellules possèdent une valeur d'élévation négative, nous pouvons tout simplement compter le nombre d'éléments contenus dans le vecteur retourné par la fonction `which()`. Si les cellules identifiées étaient nombreuses ou si nous avions besoin de conserver ce nombre en mémoire pour l'utiliser dans la suite de notre analyse, nous pourrions obtenir ce compte en utilisant la fonction générale `length()` qui retourne la taille d'un vecteur: 

```{r}
nombre <- length(ind)
nombre
```

Notons qu'il est aussi possible d'accéder aux **valeurs** de ces cellules en utilisant les indices `ind` identifiés:

```{r}
getValues(dem)[ind]
```
Nous observons que les valeurs sont belles et bien négatives! 

Pour filtrer ces cellules aux valeurs négatives, c'est-à-dire exclure ces valeurs de notre analyse, nous allons remplacer leur valeur par le terme `NA`. Rappelons que `NA` signifie non applicable.

```{r}
dem[ind] <- NA
```
Voyons maintenant comment cette modification aux valeurs de certaines cellules altère les statistiques générales sur les valeurs du *raster* `dem`
```{r}
summary(getValues(dem))
```

L'élévation minimale est maintenant de 2 et le nombre de `NA` a augmenté de `r length(ind)`. Ceci confirme que notre filtre a bien été appliqué. 

La fonction `which()` peut aussi être utilisée pour filtrer des données selon des expressions logiques plus complexes. Nous pouvons, par exemple, remplacer `getValues(dem) < 0` par `getValues(dem) < 0 | getValues(dem) > 1000` pour exclure également les cellules avec des valeurs plus grandes que 1000&nbsp;m. De plus, il est aussi possible de changer les valeurs des cellules identifiées en d'autres valeurs que `NA`. 


##### Fonction `reclassify`{-}

La fonction `reclassify()` de la bibliothèque `raster` permet également de filtrer des données matricielles et de leur assigner de nouvelles valeurs.  

Démontrons son utilisation par un cas simple. Nous allons catégoriser le niveau d'élévation, c'est-à-dire les valeurs du *raster* `dem`, en trois catégories: 

* catégorie 1: classe d'élévation faible allant de 0 à 250&nbsp;m, 
* catégorie 2: classe d'élévation modérée allant de 251 à 500&nbsp;m, 
* catégorie 3: classe d'élévation forte allant de 501 à 1200&nbsp;m.

Avant de pouvoir utiliser la fonction `reclassify()` il est nécessaire de construire une matrice indiquant les bornes limites des différentes classes.

XXX Vérifier 251, 501
```{r}
nouvelles_classes <- matrix(c(0, 250, 1, 250, 500, 2, 500, 1200, 3), nrow = 3, ncol = 3, byrow = TRUE)
colnames(nouvelles_classes) <- c("Limite_min", "Limite_max", "nouvelles_classes")
nouvelles_classes
```

Cette matrice est utilisée comme argument de la fonction `reclassify()` afin d'assigner les nouvelles classes aux valeurs du *raster* `dem`.

```{r reclassify}
nouvelles_classes_dem <- reclassify(dem, nouvelles_classes)
```

Visualisons la nouvelle classification du domaine de valeurs du raster d'élévation `dem` à l'aide de la fonction `mapview()`:

```{r, warning = FALSE}
mapview(nouvelles_classes_dem)
```
<br>

Notez que nous pouvons aussi utiliser `NA` pour exclure certaines cellules:

```{r, warning = FALSE}
nouvelles_classes2 <- matrix(c(0, 250, NA, 250, 500, 2, 500, 1200, 3), nrow = 3, ncol = 3, byrow = TRUE)
mapview(reclassify(dem, nouvelles_classes))
```
<br>

#### Filtrer en utilisant les coordonnées spatiales des cellules

Une des opérations les plus fréquentes sur les *raster* est de filtrer les cellules en fonction de leurs coordonnées spatiales. Dans cette section nous allons apprendre à utiliser les fonctions `crop()` et `mask()` pour réaliser ces manipulations. 

##### Fonction `crop()`{-}

La fonction `crop()` vous permet de rogner un *raster*, autrement dit d'utiliser un rectangle pour filter les cellules selon qu'elles soient ou non à l'intérieur de ce dernier. 

Pour utiliser la fonction `crop()`, nous avons besoin de deux objets. Le premier objet est le *raster* à rogner et le second objet est le rectangle avec lequel le *raster* sera rogné. Ce rectangle est un objet de classe `Extent` (étendue en français). Un tel objet peut être créé en utilisant les coordonnées de ses coins inférieur-gauche (`xmin`, `ymin`) et supérieur-droit (`xmax`, `ymax`):

```{r extent}
ext <- extent(c(-72, -71.5, 45.2, 45.8))
ext 
```

Avec la fonction `plot()`, nous pouvons visualiser la partie du *raster* qui sera rognée. Notez que la fonction `mapview()` ne peut pas être utilisée pour visualiser des objets de classe `Extent`.


```{r}
plot(dem)
plot(ext, add = TRUE) 
```
<br>


Il est très important de relever que de manière implicite les valeurs des coordonnées utilisées dans `extent()` sont exprimées dans le SCR de notre *raster* `dem`. 

Utilisons maintenant la fonction `crop()` dont le premier argument est le *raster* à rogner et le second argument est l'objet de classe `Extent`.

```{r}
dem_cr <- crop(dem, ext)
```

La sortie est un raster (que nous appelons `dem_cr`) qui est recadré selon `ext`. Les cellules qui ne sont pas dans ce rectangle sont exclues.

```{r, warning = FALSE}
mapview(dem_cr)
```
<br>

La fonction `crop()` accepte en second argument, non seulement les objets de classe `Extent`, mais aussi tout objet à partir duquel un objet de classe `Extent` peut être extrait. Ceci signifie que le second argument peut aussi comprendre les objets spatiaux de classe `RasterLayer` et de classe `sf`.


En guise d'exemple, nous allons maintenant rogner le *raster* `dem` en utilisant les limites du premier parc de la SÉPAQ identifié dans les données vectorielles `parcs`. Il est en effet possible d'extraire un objet de classe `Extent` à partir de ces données. Vérifions-le en utilisant la fonction `extent()`:

```{r}
extent(parcs[1,])
```

Avant d'utiliser la fonction `crop()` nous avons besoin de re-projeter le *raster* `dem` dans le SCR des données vectorielles `parcs` (notez que nous pourrions aussi faire l'inverse). L'opération qui suit utilise de façon implicite l'étendue spatiale de `parcs[1, ]` pour rogner `dem_lcc`.

```{r, warning = FALSE}
dem_lcc <- projectRaster(dem, crs = crs(parcs))
dem_cr_p <- crop(dem_lcc, parcs[1, ])
mapview(dem_cr_p)
```
<br>

##### Fonction `mask()`{-}

La fonction `mask()` permet de découper un raster avec un polygone de n'importe quelle forme et non uniquement selon un rectangle. Pour illustrer cette fonction nous allons créer un polygone avec la bibliothèque `sf`:

```{r pol}
# `mat` est une matrice 6x2 des coordonnées du polygone.
mat <- matrix(c( -72.5, 45.8,
                   -72, 45.5,
                 -72.5, 45.2,
                 -71.5, 45.2,
                 -71.5, 45.8,
                 -72.5, 45.8), ncol = 2, byrow = TRUE)

# nous transformons mat en un data frame puis en un objet de class `sf`
pol <- st_as_sf(
    data.frame(
      var = 1,
      geom = st_sfc(st_polygon(x = list(mat)))
      ),
      crs = st_crs(dem) 
  )
```

XXX Cette dernière opération m'apparait complexte et me fait réaliser que nous n'avons jamais utiliser la fonction st_polygone au module 4.

Notons que nous avons utilisé le même SCR que `dem`. Regardons ce à quoi ressemble le polygone que nous venons de créer.

```{r, warning=FALSE}
mapview(dem)+mapview(pol)
```
<br>

La fonction `mask()` permet de sélectionner uniquement les cellules du *raster* `dem` qui sont à l'**intérieur** du polygone `pol` (passé en second argument): 

```{r mask, warning = FALSE}
dem_ma <- mask(dem, pol)
mapview(dem_ma)
```
<br>

La fonction `mask()` est dotée d'un argument `inverse` qui, s'il prend la valeur `TRUE`, permet de sélectionner toutes les cellules d'un *raster* qui sont à l'**extérieur** du polygone fourni:

```{r mask_inv, warning = FALSE}
dem_ma_inv <- mask(dem, pol, inverse = TRUE)
mapview(dem_ma_inv)
```
<br>

La fonction `mask()` permet ainsi de filtrer les données matricielles de façon plus complexe qu'avec la fonction `which()`. En effet, les valeurs du *raster* `dem_ma` correspondent aux valeurs du sous-ensemble des cellules de `dem` qui sont à l'intérieur du polygone `pol` de forme complexe. Nous avons donc filtré spatialement les données de `dem` et nous avons assigné ce *raster* à la variable `dem_ma` que nous pouvons alors utiliser comme tout autre *raster*.

```{r, warning = FALSE}
summary(getValues(dem_ma))
```

Terminons cette section sur les opérations de filtre par trois remarques importantes: 
>
>1. L'étendue du *raster* retourné par la fonction `crop()` sera différente de celle du *raster* initial (sauf si l'étendue initiale est utilisée pour rogner). À l'inverse, la fonction `mask()` préserve l'étendue spatiale.
>

Vous pouvez en faire la vérification:
```{r}
extent(dem)
extent(dem_cr)
extent(dem_ma)
```

>
>2. Le temps de calcul pour réaliser l'opération `crop()` est souvent très rapide, ce qui n'est pas le cas de l'opération `mask()` quand le polygone est complexe. Il est parfois possible d'avoir des gains d'efficacité en faisant appel à `crop()` avant d'utiliser `mask()`.
>

>
>3. Dans la situation où seules les valeurs des cellules filtrées nous intéresse, il est possible d'utiliser la fonction `extract()` plutôt que la fonction `mask()`. La fonction `extract()` de la bibliothèque `raster` retourne une liste pour laquelle chaque élément donne les valeurs des cellules extraites pour chaque couche du *raster*. 
>

Par exemple, le *raster* `dem` possède une seule couche, ainsi la liste retournée par la fonction `extract()` ne possède qu'un seul élément. Toutefois, cet élément est un vecteur de taille `r length(extract(dem, pol)[[1]])` correspondant aux valeurs des cellules extraites.

```{r, warning = FALSE}
dem_ex <- extract(dem, pol)

length(dem_ex[[1]])

summary(dem_ex[[1]])
```

### Combiner des *raster*


##### Fonction `merge()` {-}

##### Fonction `mosaic()` {-}


### Parmi les quatre parcs nationaux de la région de Sherbrooke, lequel dispose du plus haut sommet?

Maintenant que nous avons appris les opérations de base pour manipuler les données matricielles, nous sommes en mesure de répondre à la première question. Les données étant déjà importées, les étapes que nous devons résoudre sont les suivantes:

1. nous assurer que le *raster* d'élévation `dem` et les données vectorielles `parcs` sont dans le même SCR,

2. utiliser la fonction `mask()` pour extraire les cellules de `dem` qui sont dans les parcs nationaux considérés,

3. déterminer la valeur maximale d'élévation dans ce sous-ensemble de cellules extraites,

4. trouver les coordonnées spatiales associées à ce point de valeur d'élévation maximale.


##### Vérication des SRC {-}
Commençons par vérifier si les systèmes de coordonnées de référence de `dem` et de `parcs` sont identiques:
```{r}
st_crs(dem) == st_crs(parcs)
```
Puisque les SCR diffèrent, nous allons re-projeter le raster `dem` en utilisant le SCR de `parcs`. Nous avons déjà réalisé cette opération à la section précédente et nous reprenons donc ci-dessous la ligne de commande vue plus haut&nbsp;: 

```{r, eval = FALSE}
dem_lcc <- projectRaster(dem, crs = crs(parcs))
```

Pour les prochaines manipulations, nous utiliserons donc `dem_lcc` et `parcs`. 

##### Filtrer le raster `dem` {-}

Nous cherchons ensuite à filtrer les cellules du *raster* d'élévation `dem` pour extraire celles situées à l'intérieur des limites de l'un ou de l'autre des quatre parcs nationaux considérés. Le *shapefile* `parcs` contient justement les polygones déliminant les quatre parcs. Nous pouvons donc appliquer la fonction `mask()` au *raster* `dem` en utilisant directement le *shapefile* `parcs` en second argument. 

```{r, warning = FALSE}
dem_parcs <- mask(dem_lcc, parcs)
mapview(dem_parcs)
```

Le *raster* `dem_parcs` obtenus par l'opération `mask()` possède la même étendue que le *raster* original `dem_lcc` mais ces valeurs diffèrent. Les cellules de  `dem_parcs` prennent la valeur `NA` partout sauf à l'intérieur des quatre parcs nationaux où elles prennent alors la même valeur que la cellule correspondate dans `dem_lcc`. 


##### Trouver l'élévation maximale {-}
Nous pouvons maintenant trouver la valeur d'élévation la plus élevée en utilisant la fonction `getValues()` suivi de la fonction `max()`. 

```{r}
vmax <- max(getValues(dem_parcs), na.rm = TRUE)
vmax
```
Nous avons ainsi obtenu l’élévation maximale de ces parcs qui est de `r format(vmax, digits = 4)`&nbsp;m. Nous cherchons alors les coordonnées spatiales associées à cette valeur. Nous pouvons faire appel à la fonction `which()` pour trouver l'**indice** de la cellule (ou les indices des cellules, si il y en a plusieurs) en question.

```{r}
ind_max <- which(getValues(dem_parcs) ==  max(getValues(dem_parcs), na.rm = TRUE))
ind_max 
```

Notons qu'il existe une fonction pour identifier le maximum, `which.max()`, qui réalise la même opération mais requière une syntaxe un peu plus simple.

```{r which.max}
which.max(getValues(dem_parcs))
```
##### Déterminer les coordonnées du plus haut sommet {-}
Pour déterminer les coordonnées de la cellule identifiée nous utilisons l'indice `ind_max` et la fonction `as.data.frame()` avec `xy = TRUE` et `centroid = TRUE` comme vu au [module 5](#mat)&nbsp;:

```{r}
df_max <- as.data.frame(dem_parcs[ind_max, drop = FALSE], xy = TRUE, centroid = TRUE, na.rm = TRUE)
df_max
```

Deux remarques méritent d'être mentionnées concernant cette opération&nbsp;: 

1. L'argument `drop = FALSE` permet d'éviter que R ne convertisse `dem_parcs[ind_max, ]` en un vecteur, c'est important car nous voulons conserver sa forme matricielle. 

2. `na.rm = TRUE` permet d'ignorer toutes les valeurs masquées, comme nous l'avons dans d'autres fonctions (e.g. `mean()`).


Une fois isolées, les coordonnées `x` et `y` du pixel d'élévation maximale peuvent être utilisées pour créer un objet spatial de classe `sf` contenant le centroïde de ce pixel grâce à la fonction `st_as_sf()`. Nous nous servirons par la suite de ce point pour visualiser sa position et déterminer dans quel parc national il est situé. 

```{r}
sf_point_max <- st_as_sf(df_max, coords = c("x", "y"), 
  crs = st_crs(dem_parcs))
sf_point_max
```

Remarquez que nous avons attribué à ce point le même SRC que celui du *raster* `dem_parcs()`.

En superposant avec `mapview()` les trois couches d'informations spatiales que nous venons de manipuler, nous pouvons repérer le parc dans lequel se trouve ce point d'élévation maximale. 

```{r, fig.cap = "En cliquant sur le polygone du parc contenant le point rouge (point d'élévation maximal), il est possible de constater que le point se retrouve dans le Parc national du Mont-Mégantic", warning = FALSE}
mapview(dem_parcs) + mapview(parcs, alpha = 0.01) + mapview(sf_point_max,  col.regions = "red")
```

Nous constatons que ce point est situé dans le **parc national du Mont-Mégantic**. Au lieu de déduire sa localisation de manière visuelle, nous allons à présent réaliser une opération topologique pour isoler le polygone du parc abritant ce plus haut sommet. Pour ce faire, nous utilisons la fonction `st_intersects()` étudiée au [module 7](#manip_vec). Rappelons que cette fonction retourne la valeur `TRUE` lorsque deux objets vectoriels se recoupent et `TRUE` autrement.

```{r}
st_intersects(parcs, sf_point_max, sparse = FALSE)
```
 
Nous utilisons ensuite ce vecteur logique pour identifier le parc auquel ce sommet appartient. Notez que le nom des parcs est donné par l'attribut `TRQ_NM_`.

```{r}
parcs[st_intersects(parcs, sf_point_max, sparse = FALSE), ]$TRQ_NM_
```

Cette opération peut être écrite plus simplement sous la forme:

```{r}
parcs[sf_point_max, ]$TRQ_NM_

```

Cette dernière manipulation nous permet de répondre à notre première question: 
parmi les quatre parcs nationaux sélectionnés, c'est le Parc national du Mont-Mégantic qui a le plus haut sommet, sommet qui culmine à `r format(vmax, digits = 4)`&nbsp;m d'altitude.




### Quelle est le profil topographique du sentier se rendant au plus proche de ce sommet?

Nous allons maintenant nous placer dans la situation suivante&nbsp;: nous désirons faire une randonnée pédestre jusqu'au sommet que nous venons d'identifier (à tout le moins, le plus proche possible du sommet). Afin de nous faire une idée précise de l'effort physique que nous devrons fournir lors de cette randonnée, nous allons réaliser un profil topographique du sentier se rendant au plus proche de ce sommet. 

La figure \@ref(fig:prof_topo) donne un exemple de profil topographique pour sentier de la grande traversée dans le Parc national de la Gaspésie.

```{r prof_topo, fig.align = 'left', echo = FALSE, fig.cap = "Exemple de profil topographique: le sentier international des Appalaches [taille réelle](Module8/images/gas_coupe_grande_traversee.png)", out.width = '100%'}
knitr::include_graphics('Module8/images/gas_coupe_grande_traversee.png')
```

Voici les étapes que nous allons suivre en vue de répondre à la question posée: 

1. créer un *shapefile* du Parc national du Mont-Mégantic, `parc_megantic`, à partir de `parcs`,

2. importer les données des [sentiers estivaux de la SEPAQ](https://www.donneesquebec.ca/recherche/dataset/sentiers-estivaux) et des données d'élévation plus précises (voir ci-dessous),

3. s'assurer que les nouveaux objets importés et `parc_megantic` ont le même SCR,

4. isoler les sentiers estivaux du Parc national du Mont-Mégantic,

5. trouver le chemin le plus proche du sommet identifié à la section précédente,

6. extraire les cellules d'élévation de `dem_lcc` sur ce sentier,

7. faire un profile d'élévation. 


<br>

##### Créer un *shapefile* du Parc national du Mont-Mégantic {-}
Puisque le profil topographique que nous désirons créer se situe à l'intérieur du Parc national du Mont-Mégantic, isolons le polygone constituant ce parc à partir du *shapefile* `parcs` regroupant les quatre parcs. Rappelons que le Parc national du Mont-Mégantic est celui qui possède le plus haut sommet. En nous basant sur les commandes réalisées plus haut, nous pouvons définir le *shapefile* `parc_megantic` de la façon suivante: 

```{r}
parc_megantic <- parcs[st_intersects(parcs, sf_point_max, sparse = FALSE), ]
# Ou plus simplement:
# parc_megantic <- parcs[sf_point_max, ]
```


##### Importer les données {-}
Maintenant importons les données vectorielles pour tous les sentiers de la SEPAQ:

```{r, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module8/Donnees/"
chemin_sentiers <- paste(chemin, "/sentiers_sepaq/Sentier_ete_l.shp", sep = "")
sentiers <- st_read(chemin_parcs)
```

```{r, echo = FALSE}
#sentiers <- st_read("Module8/data/sentiers_sepaq/Sentier_ete_l.shp")
sentiers <- st_read("E:/ELF/Dropbox/TELUQ/ENSEIGNEMENT/Cours/SCI1031/Developpement/Structure_test/sci1031/Module8/data/sentiers_sepaq/Sentier_ete_l.shp")
mapview(sentiers)
```
<br>

Notre objectif est de savoir comment l'élévation varie le long du sentier qui conduit le plus près possible du plus haut sommet. Ainsi, en plus des données sur la localisation des sentiers, nous avons besoin des données d'élévation. Or, au lieu d'utiliser le *raster* `dem_lcc` dont la résolution spatiale est de `r res(dem_lcc)[1]` par `r res(dem_lcc)[2]` $m^2$, nous allons nous procurer une autre couche d'élévation de résolution plus fine afin d'obtenir un profil topologique plus précis.

Pour ce faire, nous utiliserons la fonction `get_elev_raster()` de la bibliothèque [`elevatr`](https://CRAN.R-project.org/package=elevatr). Cette fonction permet d'accéder aux données d'élévation disponibles sur le service d'infonuagique d'Amazon ([AWS](https://registry.opendata.aws/terrain-tiles/)) et cela à différents niveaux de résolution.

La fonction `get_elev_raster()` requière deux arguments. Le premier argument spécifie la localisation des données recherchées. Dans notre cas, la localisation est définie le polygone `parc_megantic`. Le deuxième argument spécifie le niveau de résolution des données recherchées, c'est-à-dire le [*zoom*](https://github.com/tilezen/joerd/blob/master/docs/data-sources.md#what-is-the-ground-resolution), une valeur allant de z = 1 à z = 14.  

```{R, eval = FALSE}
# install.packages("elevatr")
library(elevatr)
elv_megantic <- get_elev_raster(parc_megantic, z = 13) 

```


```{R, echo = FALSE}
# writeRaster(ra_elv,  "megantic_elevation.grd")
elv_megantic <- raster("Module8/data/megantic_elevation.grd")
```
Nous avons ainsi obtenu le *raster* d'élévation `elv_megantic` pour le Parc national du Mont-Mégantic. La résolution spatiale de cette couche est plus fine que celle de la couche `dem_lcc`:
```{r}
res(elv_megantic)
```
Ce qui correspond à environ `round(res(elv_megantic)[1], digits = 1)` par `round(res(elv_megantic)[2], digits = 1)` $m^2$.


##### Vérication des SRC {-}
Vérifions ensuite que les SCR&nbsp; utilisés pour répondre à la question sont tous identiques en utilisant la fonction `st_crs()`:

```{r check_crs}
st_crs(sentiers) == st_crs(parc_megantic)
st_crs(elv_megantic) == st_crs(parc_megantic)
```
Puisque c'est le cas, aucune transformation de SRC n'est nécessaire et nous pouvons poursuivre la résolution de notre problème.

##### Isoler les sentiers estivaux du Parc national du Mont-Mégantic {-}
À présent, nous allons isoler les sentiers du parc du Mont-Mégantic qui se trouvent dans `sentiers`. Commençons par inspecter la table des attributs&nbsp;:

```{r} 
head(sentiers)
```

La colonne `Nom_etab` contient le non des parcs que nous pouvons lister rapidement avec la fonction `unique()` qui enlève les doublons.

```{r} 
unique(sentiers$Nom_etab)
```

Nous observons que le Parc national du Mont-Mégantic est identifié par le nom "Mont-Mégantic". 
Pour isoler ses sentiers nous pouvons procéder de deux façons. La première façon consiste à utiliser la fonction `subset()` (vue au [module 7](#manip_vec)) pour filtrer le *shapefile* `sentiers` et sélectionner seulement les sentiers pour lesquels l'attribut `Nom_etab` prend la valeur "Mont-Mégantic":

```{r}
sentiers_megantic <- subset(sentiers, Nom_etab == "Mont-Mégantic")
```

La deuxième façon est d'utiliser un filtre spatial avec les limites du Parc national du Mont-Mégantic contenues dans `parc_megantic`&nbsp;:

```{r sentier_megantic} 
sentiers_megantic <- sentiers[parc_megantic, ]
mapview(sentiers_megantic)
```

Nous avons ainsi obtenu, quelle que soit la méthode choisie, un objet vectoriel, `sentiers_megantic`, qui contient les sentiers du Parc national du Mont-Mégantic. 


##### Trouver le sentier le plus proche du sommet le plus haut {-}
Nous allons maintenant utiliser la fonction `st_nearest_feature()` de la bibliothèque `st` pour déterminer quel sentier (`LINES`) se trouve le plus proche du sommet (`POINT`). Notez qu'en anglais "near" signifie *proche* et "feature" signifie *éléments* ou plus précisément une *entité spatiale* (aussi appelée une géométrie) dans le présent contexte. La fonction `st_nearest_feature(x,y)` comprend deux arguments x et y et retourne l'indice de l'entité spatiale dans y qui est le plus près de l'entité x. 


```{r, st_nearest_feature}
id_nearest <- st_nearest_feature(sf_point_max, sentiers_megantic)
id_nearest
```
Nous pouvons ainsi trouver le sentier recherché à partir de l'indice que nous venons d'identifier.

```{r}
sentier_top <- sentiers_megantic[id_nearest, ]
sentier_top
```
Observez que la géométrie de cette entité spatiale est une multiligne (`MULTILINESTRING`).

Notons que nous aurions pu faire la même opération directement sur l'objet `sentiers`. C'est-à-dire par la commande suivante:
```{r}
sentiers[st_nearest_feature(sf_point_max, sentiers),]
```

Regardons où ce sentier se situe par rapport aux autres sentiers du parc&nbsp;:

```{r}
mapview(sentiers_megantic) + mapview(sentier_top, color="red")
```

Nous observons que ce sentier n'est en fait qu'une petite portion du parcours qu'un.e randonneur.se devra faire pour se rendre le plus près possible du plus haut sommet. Or, nous voulons le sentier complet à parcourir depuis le pied de la montagne. L'attribut `Toponyme1` nous donne justement le nom du sentier (*Sentier du Mont-Mégantic*) auquel appartient la section `sentier_top` que nous venons d'identifier. 

Revenons maintenant au shapefile `sentiers_megantic` pour y extraire toutes les autres portions du sentier nommé "Sentier du Mont-Mégantic" qui ensemble formeront la randonnée complète. Pour ce faire nous utilisons la fonction `subset()`&nbsp;:

```{r rando_sections}
rando_sections <- subset(sentiers_megantic, Toponyme1 == "Sentier du Mont-Mégantic")
```

Visualisons ensuite ces différentes portions en les colorant selon un identifiant `id`&nbsp;:

```{r}
rando_sections$id <- 1:5
mapview(rando_sections, zcol = "id")
```

Changeons l'ordre des portions afin qu'elles suivent l'ordre selon lequel elles seront parcourues à partir du sommet jusqu'au pied de la montagne (c'est-à-dire de 1 à 5 plutôt que 5,1,2,3,4)&nbsp;:
```{r}
rando_sections <- rando_sections[c(5, 1:4),]
rando_sections$id <-1:5
mapview(rando_sections, zcol = "id")
```

Combinons maintenant ces cinq portions en une seule entité spatiale (`MULTILINESTRING`) en utilisant la fonction `st_combine()` de la bibliothèque `st`&nbsp;: 

```{r}
rando <- st_combine(rando_sections)
rando
```

Observez que nous avons effectivement une seule entité spatiale.


##### Extraire les cellules d'élévation le long du sentier {-}

Pour faire le profil topographique du sentier `rando`, nous devons extraire des données d'élévation du parc (`elv_megantic`) celles qui se trouvent le long du sentier. Pour ce faire nous allons utiliser la fonction `extract()` de la bibliothèque `raster`` comme suit.

```{r elv_profile}
topo_elv <- extract(elv_megantic, st_as_sf(rando), along = TRUE, cellnumbers = TRUE) 
```

Notons que cette opération peut prendre plusieurs secondes pour être complétée par votre ordinateur.

Trois remarques méritent d'être mentionnées concernant cette opération&nbsp;: 


1. Nous avons besoin de convertir `rando` qui est de classe `sfc` en objet de classe `sf` pour l'utiliser avec `extract()`, ce que nous faisons avec `st_as_sf()`,

2. `along = TRUE` permet d'obtenir les cellules ordonnées le long des lignes de `rando_sections`,

3. `cellnumbers = TRUE` nous permet d'avoir les indices des cellules extraites.


Comme vu un peu plus haut, la fonction `extract()` retourne une liste. Ainsi, `topo_elv` est un objet de classe `list`, mais cette fois le premier élément est une matrice avec deux colonnes: la première colonne contient les identifiants des cellules, et la seconde, les valeurs d’élévation (précédemment, le résultat de `extract()` était simplement un vecteur avec des valeurs d'élévation).  

Nous pouvons confirmer ces propos par les commandes suivantes&nbsp;:
```{r}
class(topo_elv)       #topo_elv est un objet de classe "list"
length(topo_elv)      #cette liste comprend une seule entrée
dim(topo_elv[[1]])    #La première entrée de liste est une matrice de 2 colonnes et 876 lignes.
```

Attribuons des noms à chacune des colonnes de la matrice contenue dans la première entrée de la liste `topo_elv`&nbsp;
```{r}
colnames(topo_elv[[1]]) <- c("cellule_id", "elevation")
head(topo_elv[[1]])
```

Nous avons donc toutes les valeurs d'élévation le long du sentier. 

##### Obtenir le profil topographique {-}
 
Rappelons qu'un profil topographique est une représentation graphique du relief qui affiche l'élévation à chaque point le long d'un sentier (voir la figure \@ref(fig:prof_topo)). L'abscisse d'un tel graphique (c'est-à-dire l'axe des x) correspond à la distance parcourue depuis le début de la randonnée (par exemple de 0 à 100 km) et l'ordonnée (c'est-à-dire l'axe des y) correspond à l'élévation. Maintenant que nous avons l'élévation pour chaque point le long du sentier (`topo_elv`), nous devons déterminer la distance parcourue depuis le début du trajet jusqu'à chaque point le long de ce sentier. 

Tout d'abord, nous devons calculer la distance parcourue entre chaque paires de points qui se suivent le long du sentier. Pour ce faire, nous utiliserons la fonction `st_distance()` de la bibliothèque `st`. Or, cette fonction ne peut être utilisée que sur un objet spatial, et comme nous venons de le constater `topo_elv` est un objet de classe `list`. Nous devons donc transformer `topo_elv` en objet spatial avec la fonction `st_as_sf()`. 

De plus, un objet spatial doit être défini par des coordonnées spatiales. Pour l'instant, les cellules formant le sentier dans `topo_elv` sont identifiées par leur indice et non par leurs coordonnées. Une étape préliminaire est donc nécessaire pour retrouver les coordonnées spatiales correspondant à chaque indice. Cela est possible grâce à la fonction `xyFromCell()` de la bibliothèque `raster` qui retourne les coordonnées spatiales associées à chaque indice dans le *raster* à partir duquel nous avons extrait `topo_elv`, c'est-à-dire `elv_megantic`. 

```{r xyFromCell}
df_pts <- as.data.frame(xyFromCell(elv_megantic, topo_elv[[1]][, 1]))
head(df_pts)
```

Nous avons mis les coordonnées spatiales dans le tableau `df_pts` de type *data frame*. Notez que l'argument `topo_elv[[1]][, 1]` correspond aux indices des cellules (c'est la première colonne de la première entrée de la liste `topo_elv`). 

Nous pouvons ensuite utiliser la fonction `st_as_sf()` pour transformer `df_pts` en objet de classe `sf`&nbsp;:

```{r}
topo_pts <- st_as_sf(df_pts,
    coords = c("x", "y"),
    crs = st_crs(sentiers_megantic) 
  )
```
Remarquez que nous avons également attribué un SCR au nouvel objet spatial `topo_pts`. 

Nous pouvons finalement utiliser la fonction `st_distance()` pour calculer les distances entre points successifs de `topo_pts`. La fonction `st_distance(x,y)` nécessite obligatoirement deux objets spatiaux (`x` et `y`) en argument. Elle calcule alors la distance entre chaque paire d'éléments de `x` et de `y`, qu'elle retourne sous forme de matrice. Par exemple, l'opération suivante calcule la distance entre toutes les paires de points compris dans `topo_pts`&nbsp;:

```{r}
dist_tout <- st_distance(topo_pts,topo_pts)
dist_tout[1:5,1:5]
```

L'élément `dist_tout[1,1]` est la distance entre le premier point de `topo_pts` et lui-même (donc zéro), l'élément `dist_tout[1,2]` est la distance entre le premier et le deuxième points de `topo_pts`, `dist_tout[1,3]` entre le premier et le troisième points de `topo_pts`, et ainsi de suite pour tous les points de `topo_pts`. 

La fonction `st_distance()` s'utilise aussi avec l'argument `by_element = TRUE`. Dans ce cas, la fonction retourne un vecteur dont le premier élément correspond à la distance entre le premier élément de `x` et le premier élément de `y`; le deuxième élément, à la distance entre le deuxième élément de `x` et le deuxième élément de `y`, et ainsi de suite. Par exemple, l'opération suivante&nbsp;:

```{r}
dist0 <- st_distance(topo_pts,topo_pts,by_element = TRUE)
dist0[1:5]
```
retourne un vecteur nul puisque chaque élément correspond à la distance entre un point et lui-même.

Pour répondre à notre question, nous devons calculer la distance entre des points successifs de `topo_pts` (c'est-à-dire la distance entre le premier et le deuxième point, entre le deuxième et le troisième point, entre le troisième et le quatrième point, etc.). Il s'agit calculer la distance pour des paires de points formés entre `topo_pts` et une version de `topo_pts` qui est décalée d'un élément. Nous utilisons donc la fonction `st_distance()` avec comme premier argument `topo_pts` sans le premier point, et comme deuxième argument `topo_pts` aussi mais cette fois sans le dernier point:


```{r}
dist_pts <- st_distance(topo_pts[-1, ], topo_pts[-nrow(topo_pts),],
 by_element = TRUE)
```

Nous pouvons maintenant calculer la distance parcourue à chaque point le long du sentier depuis le début de la randonnée. Pour ce faire nous utilisons la fonction `cumsum()` qui calcule la somme cumulée des distances entre chaque point&nbsp;:
```{r}
dist_parcourue <- cumsum(dist_pts)
```


Nous pouvons finalement visualiser l'élévation (la deuxième colonne de `topo_elv[[1]][, 2]`) en fonction de la somme cumulée des distances, `dist_parcourue`. Remarquons que le vecteur `dist_parcourue` comprend un élément de moins que le vecteur `topo_elv[[1]][, 2]`. Ceci s'explique par le fait que `dist_pts`, à partir duquel nous calculons `dist_parcourue`, mesure la distance entre les points (c'est à dire des intervalles). Par conséquent, nous ajountons la distance initiale de 0m au vecteur des distances parcourues.  

```{r profile_topo, fig.width = 9.5}
plot(c(0, dist_parcourue), topo_elv[[1]][, 2], 
  main = "Profil topographique du Sentier du Mont-Mégantic", 
  xlab = "Distance depuis le sommet (en mètre)", 
  ylab = "Altitude (en mètre)", 
  type = "l", # pour utiliser une ligne
  lwd = 2 # augmente le trait de la ligne 
) 
```



 



## Exercice {#ex_mat_manip}

