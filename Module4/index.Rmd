
# Données vectorielles {#vec}


L'objectif principal de ce module est d'apprendre à lire, interpréter et visualiser des données vectorielles^[L’ensemble du matériel disponible dans ce module est adapté du cours *Introduction to Geospatial Raster and Vector Data with R* [@Data_Carpentry_IntroGeospatial] de l’organisme [Data Carpentry](https://datacarpentry.org/).  Data Carpentry développe et offre des formations variées et spécialisées sur le traitement et l’analyse de données. Ses formations s’adressent surtout aux chercheuses et chercheurs scientifiques, mais peuvent être consultées par quiconque car leur matériel est libre d’accès. N’hésitez donc pas à y jeter un coup d’œil.]

À la fin de ce module vous saurez:

- Lire un *shapefile*, explorer ses métadonnées et interpréter sa géométrie.
- Lire une *geodatabase*, et explorer ses couches.
- Visualiser des données vectorielles de type point, ligne et polygone.
- Visualiser des données vectorielles par attribut.
- Visualiser plusieurs données vectorielles au sein d'une même figure.
- Transformer le système de coordonnées de référence de données vectorielles.

Vous utiliserez les librairies suivantes:

- `sf`
- `rgdal`
- `dplyr`
- `ggplot2`
- `ggpubr`

Vous apprendrez à utiliser les fonctions suivantes:

- `st_read()`, `st_write()`
- `st_geometry_type()`
- `st_crs()`
- `st_bbox()`
- `geom_sf`
- `filter()`
- `select()`
- `st_transform()`
- `ggarrange()`

Dans la section [leçon](#lecon_vec), vous utiliserez deux ensembles de données vectorielles. 

Le premier ensemble contient des données *shapefile* relatives au réseau de pistes cyclables de la ville de Montréal et aux accidents routiers impliquant des bicyclettes.

Le second ensemble consitutie une *géodatabase* contenant des données du Ministère de l'Éducation et de l'Enseignement Supérieur du Québec relatives aux établissements d'enseignement sur le territoire québécois.

Dans la section [exercice](#ex_vec), vous utiliserez XXXXX

```{r load-libraries4, echo = FALSE, results='hide', warning = FALSE, message = FALSE}
#library(raster)
library(rgdal)
library(ggplot2)
library(dplyr)
library(sf)
library(svglite) ## J'ai pas besoin de ça pour créer les figures, mais pour les inclure dans le markdown, oui.
library(ggpubr)
library(mapview)
```


## Leçon {#lecon_vec}


Cette leçon est une introduction aux données spatiales sous `R`. 
Les trois premières sections porteront sur des données vectorielles en format *shapefile* puisque celles-ci sont couramment utilisées.
La quatrième section vous familiarisera avec les données vectorielles en format *geodatabase* puisque celles-ci sont de plus en plus utilisées au sein de grandes organisations comme des ministères. 



### Lire un *shapefile* et interpréter sa géométrie


Dans cette section, nous allons explorer des données vectorielles relatives au réseau de pistes cyclables de la ville de Montréal et aux accidents routiers impliquant des bicyclettes.


#### Importer les données {-}

Téléchargez les [données sur le réseau de pistes cyclables](https://github.com/sci1031/sci1031/tree/master/Module4/data/Montreal_Velo.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Donnees` pour ce module, et dézippez-le. Le dossier Montreal_Velo comprend trois sous-dossiers:

- `accidents`
- `pistes`
- `terre`.


#### Lire les données {-}

Pour lire des données vectorielles contenues dans un fichier *shapefile*, nous allons utiliser la librairie `sf`. Notez que la librairie `rgdal` se charge automatiquement lorsque `sf` se charge.

```{r load-sf, eval = FALSE}
library(sf)
```

Nous allons lire les trois *shapefiles* suivants :

- Des données vectorielles de type polygone représentant la frontière de notre zone d’étude, ici, l'île de Montréal.
- Des données vectorielles de type ligne représentant les pistes cyclables sur l'île de Montréal, et
- Des données vectorielles de type point représentant la position d'accidents impliquant des bicyclettes.


Dans un premier temps, nous allons ouvrir les données vectorielles de type polygone qui contiennent les limites terrestres de l'île de Montréal. Pour lire ces données nous utiliserons la fonction `st_read()` de la librarie `sf`. Pour utiliser `st_read()` nous devons spécifier le chemin menant au fichier *shapefile* à lire.

```{r fake-terre, eval = FALSE}
chemin<-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier <- paste(chemin, "Montreal_Velo/terre/terre_shp.shp", sep = "")
limites_terrestres <- st_read(nom_du_fichier)
```

```{r terre, eval = TRUE, echo = FALSE}
limites_terrestres <- st_read("Module4/data/Montreal_Velo/terre/terre_shp.shp")
```

La fonction `st_read()` vous permet d'ores et déjà d'obtenir certaines informations sur la structure des données vectorielles que vous venez de lire: le type de géométrie (`geometry type`), la dimension des données (`dimension`), l’étendue spatiale des données (`bbox`), et les informations relatives au système de coordonnées de référence, le SPSG (`epsg (SRID)`) et la projection (`proj4string`). Nous explorerons ces propriétés en détails plus bas.

Nous allons maintenant lire les données vectorielles de type ligne, en utilisant encore la fonction `st_read()`.

```{r fake-pistes, eval = FALSE}
chemin <-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier<- paste(chemin, "Montreal_Velo/pistes/pistes_cyclables_type.shp", sep = "")
pistes_cyclables <- st_read(nom_du_fichier)
```

```{r pistes, eval = TRUE, echo = FALSE}
pistes_cyclables <- st_read("Module4/data/Montreal_Velo/pistes/pistes_cyclables_type.shp")
#pistes_cyclables$TYPE_VOIE = rep(1:5, length.out = 34)
```

Finalement, nous allons lire les données vectorielles de type point, en utilisant toujours la fonction `st_read()`.

```{r fake-accidents, eval = FALSE}
chemin<-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier<- paste(chemin, "Montreal_Velo/accidents/accidents2018_Mtl_velo.shp", sep = "")
pistes_cyclables <- st_read(nom_du_fichier)
```

```{r accidents, eval = TRUE}
accidents_velo <- st_read("Module4/data/Montreal_Velo/accidents/accidents2018_Mtl_velo.shp")
```

Remarquez que le type de géométrie (`geometry type`) diffère pour les trois classes de données lues comme nous nous y attendions.
<br>

#### Explorer les métadonnées d’un *shapefile* {-}

Les informations contenues dans un *shapefile* sont appelées des métadonnées. Nous sommes particulièrement intéressées aux métadonnées géospatiales.

Les métadonnées fondamentales d’un *shapefile* sont :

1.	Le type de géométrie : le type de classes des données vectorielles téléchargées.
2.	La projection : le système de coordonnées de référence utilisé pour représenter les données.
3.	L’étendue spatiale : la superficie géographique couvrant les données vectorielles.

##### Le type de géogmétrie {-}

Nous pouvons explorer chacune de ces métadonnées en utilisant des fonctions de la librairie `sf`. Le type de géométrie est obtenu par la fonction `st_geometry_type()`. Par exemple, pour les limites terrestres de la ville de Montréal, cette fonction nous donne:

```{r type-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_geometry_type(limites_terrestres)
```
Nous avons ainsi la confirmation que ces données vectorielles correspondent à des polygones (plus exactement, 72 polygones). Les 18 niveaux donnés en dessous constituent une liste des classes possibles de géométrie.

En comparaison, pour les données de type ligne et de type point nous obtenons plutôt :

```{r type-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, output.lines = 2}
st_geometry_type(pistes_cyclables)
```

```{r type-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, output.lines = 2}
st_geometry_type(accidents_velo)
```

Vous remarquez alors que les pistes cyclables sont composées de nombreuses multilignes. Une multiligne étant elle-même un ensemble de lignes.
Quant aux accidents de vélo, ce sont des points qui désignent la position précise des accidents. On en compte 796 en 2018.

##### La projection {-}


Vérifions maintenant la projection des *shapefiles* en utilisant la fonction `st_crs()` de la librarie `sf`:

```{r proj-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_crs(limites_terrestres)
```

```{r proj-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_crs(pistes_cyclables)
```

```{r proj-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_crs(accidents_velo)
```
Les données de tous les *shapefiles* sont dans la projection de Mercator transverse (`+proj=tmerc`) et utilisent le Système de référence géodésique nord-américan de 1983 (`+datum=NAD83`). Il n'y a pas de EPSG assigné à ces données. Connaitre le SCR est essentiel pour interpréter l’étendue spatiale des objets spatiaux puisque celui-ci précise, en quelque sorte, les unités de mesure.

##### L'étendue spatiale {-}

Pour connaître l’étendue spatiale des *shapefiles*, nous utilisons la fonction `st_bbox()` de la librairie `sf` :
```{r bbox-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_bbox(limites_terrestres)
```

```{r bbox-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_bbox(pistes_cyclables)
```

```{r bbox-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_bbox(accidents_velo)
```

L’étendue spatiale d’un *shapefile* ou d’un objet spatial dans `R` représente les limites géographiques des données, ou la localisation des données les plus au sud, nord, est et ouest.

##### Les attributs {-}


Finalement, nous pouvons visualiser toutes les métadonnées et les attributs d'un *shapefile* simplement en écrivant son nom dans la console `R`:
```{r tout-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
limites_terrestres
```

```{r tout-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
pistes_cyclables
```

```{r tout-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
accidents_velo
```


### Visualisation de *shapefiles* sous R

#### Visualisation avec la fonction `R` `ggplot` {-}

Vous allez maintenant apprendre à visualer des données *shapefile* en utilisant la fonction `ggplot()` de la librairie `ggplot2`.

```{r load-ggplot2}
library(ggplot2)
```

Dans un premier temps, visualisons les limites terrestres de l'île de Montréal (Fig \@ref(fig:plot-terre)).
```{r plot-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Limites terrestres de l'île de Montréal"}
ggplot() +
geom_sf(data = limites_terrestres, size = 1, color = "black", fill = "white") +
ggtitle("Limites terrestres de l'île de Montréal")
```
La fonction `geom_sf()` permet de faire des représentations simples d'objets vectoriels de géométrie de type point, ligne et polygone.
Cette fonction peut prendre plusieurs arguments^[Pour plus d'information sur la fonction `geom_sf`, consultez le chapitre [Visualise sf objects](https://ggplot2.tidyverse.org/reference/ggsf.html) [@Wickham_ggplot2_2016]]. Les arguments utilisés ici sont:

- les données (`data`)
- la taille du trait avec laquelle on illustre l'objet (`size`)
- la couleur du trait, et la couleur de la surface délimitée par le trait (`color`).

La fonction ggtitle permet d'ajouter un titre à la figure générée.

Remarquez que chaque fonction est écrite sur sa propre ligne, pour faciliter la lecture des lignes de commande, et que chaque fonction qui s'ajoute à `ggplot()` est précédée par le signe plus `+`.

Dans un deuxième temps, visualisons les pistes cyclables (Fig \@ref(fig:plot-velo)).
```{r plot-velo, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Pistes cyclables sur l'île de Montréal"}
ggplot() +
geom_sf(data = pistes_cyclables, size = 1, color = "darkgreen") +
ggtitle("Pistes cyclables sur l'île de Montréal")
```

Pour visualiser des lignes, nous n'avons évidemment pas besoin de définir l'argument `fill` car nous visualisons des lignes plutôt qu'une surface. Vous remarquerez que les lignes, cette fois, sont vertes foncées (`darkgreen`).

Il existe 657 couleurs prédéfinies dans `R`. Taper la commande `colors()` dans votre console `R` pour voir afficher le nom des couleurs. Celles-sont sont listées par ordre alphabétique sauf pour la première couleur, qui est le blanc (`white`). Ainsi, vous pouvez utiliser une couleur en assignant son nom ou son numéro. Pour produire la figure précédente, `color = "darkgreen"` aurait pu être remplacé par
`color = colors()[81]`. Essayez pour voir.

Les couleurs peuvent aussi être définies selon leur composition en rouge, vert et bleu sur un intervalle allant de 0 à 255 - ce qu'on nomme le vecteur RGB (red, green, blue). Par exemple, la couleur jaune est représentée par le vecteur RGB (255, 255, 0). La couleur verte foncée, utilisée précédemment, est, quant à elle, représentée par le vecteur RGB (0, 100, 0). Les couleurs peuvent aussi être exprimées selon le système de notation [hexadécimal](https://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal). La fonction `rgb` permet de traduire un vecteur de couleur RGB en notation hexadécimal. Ainsi, pour produire la figure précédente, nous aurions pu définir le vecteur  `vert_fonce = rgb(0, 100, 0, maxColorValue=255)`, et remplacer `color = "darkgreen"` par `color = vert_fonce`. Essayez pour voir.

Pour en apprendre davantage sur les couleurs dans `R`, vous êtes invité à consulter le site [Earl Glynn](https://github.com/EarlGlynn/colorchart/wiki/Color-Chart-in-R) et à conserver dans vos notes son [tableau synthèse des couleurs](Module4/4_TableauCouleurs.pdf) dans `R`.

Finalement, visualisons les accidents de la route impliquant des bicyclettes (Fig \@ref(fig:plot-accidents)).
```{r plot-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Accidents de la route avec cyclistes sur l'île de Montréal"}
ggplot() +
geom_sf(data = accidents_velo, pch = 19, cex = 1.25, color = "red") +
ggtitle("Accidents de la route avec cyclistes sur l'île de Montréal")
```

Le symbole utilisé pour illustrer la position des accidents est défini par l'argument `pch = 19`. Il existe 25 formats de points différents prédéfinis dans `R`. Les voici:

```{r plot-symbols, echo=FALSE, fig.cap="Symboles disponibles", out.width = '50%'}
knitr::include_graphics('Module4/4_symbolesR.png')
```


L'argument `cex`, quant à lui, indique le facteur par lequel la taille du symbole sera augmentée ou réduite par rapport à 1, la valeur par défaut. Par exemple, 'cex = 1.5' indique que le symbole sera 50% plus grand, alors que 0.5 indique que le symbole sera 50% plus petit.

Ainsi, nous pouvons changer les valeurs de ces arguments et représenter les accidents de vélo par des triangles oranges (Fig \@ref(fig:plot-accidents2)).
```{r plot-accidents2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap = "Symbole et couleur différents pour illustrer les accidents de la route avec cyclistes sur l'île de Montréal"}
ggplot() +
geom_sf(data = accidents_velo, pch = 24, cex = 1.5, color = "black", fill = "orange") +
ggtitle("Accidents de la route avec cyclistes sur l'île de Montréal")
```

<br>

#### Visualiser des données vectorielles par attribut {-}

Lorsque nous avons affiché les métadonnées du *shapefile* `pistes_cyclables`, vous avez peut-être observé que ce dernier comprenait l'attribut `TYPE_VOIE` qui caractérise le type de pistes cyclables de chaque multiligne. Affichons les métadonnées à nouveau:
```{r plot-voie0, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
pistes_cyclables
```
Utilisons la fonction `levels` pour connaître ces types de voie cyclables. La fonction `levels` donne les différentes valeurs que peuvent prendre un attribut.

```{r plot-voie1, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
levels(pistes_cyclables$TYPE_VOIE)
```
Si vous ne connaissez pas la distinction entre ces types d'aménagement cyclable, consulter ce [document sommaire](Module4/4_Amenagement3Cyclable3Mtl.pdf) de la *Ville de Montréal*^[Ville de Montréal. Aménagements cyclables. Repéré le 19 mars 2020]

Nous voulons maintenant représenter les données vectorielles associées aux pistes cyclables de type `"Bande cyclable"`. Pour représenter une valeur précise d'un attribut, nous utiliserons la fonction `filter` de la librarie `dplyr`. Commençons par charger cette librairie.

```{r load-dplyr, eval = FALSE}
library(dplyr)
```

Utilisons la fonction `filter` qui permet de filtrer l'ensemble des valeurs de l'attribut `TYPE_VOIE`, pour ne retenir que les données dont la valeur est identique (ce qui s'exprime par l'opération `==`) à '"Bande cyclable"'. Nous nommerons ce sous-ensemble de données `Bande`.
```{r plot-voie2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
Bande <-pistes_cyclables %>%
  filter(TYPE_VOIE =="Bande cyclable")
```

Nous représentons ce sous-ensemble de données de la même manière que pour l'ensemble complet (Fig \@ref(fig:plot-velo)).
```{r plot-voie3, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Bandes cyclables sur l'île de Montréal"}
ggplot()+
  geom_sf(data = Bande,  size = 1, color = "darkgreen")+
  ggtitle("Pistes cyclables sur l'île de Montréal", subtitle = "Bande cyclable")
```

Nous voulons maintenant représenter les six types de voie cyclable par six couleurs différentes. Créons d'abord un vecteur de six couleurs, ce qu'on appelle une palette de couleurs.
```{r plot-voie4, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
couleurs_voie<-c("darkgreen", "turquoise", "yellow","darkblue","violet","orange")
```
Nous pouvons demander à `ggplot` d'utiliser ces couleurs pour illustrer les différents types de voie cyclable (Fig \@ref(fig:plot-voie5)).

```{r plot-voie5, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Types de voie cyclable sur l'île de Montréal"}
ggplot()+
  geom_sf(data = pistes_cyclables,  aes(color = TYPE_VOIE))+
  scale_color_manual(values = couleurs_voie)+
  labs(color = 'Types de voie')+
  ggtitle("Pistes cyclables sur l'île de Montréal", subtitle = "Types de voie")
```

La fonction `aes` décrit quelles variables dans les données (`data`) sont illustrées (dans notre exemple, ce sont `TYPE_VOIE`) et par quelles
caractéristiques visuelles^[Pour plus d'information sur la fonction `aes`, consultez le chapitre [Construct aesthetic mappings](https://ggplot2.tidyverse.org/reference/aes.html) [@Wickham_ggplot2_2016]]. On nomme ces caractéristiques visuelles les "esthétiques" (`aes` pour "aesthetic" en anglais). Dans le présent exemple, nous nous préoccupons seulement de la couleur des données vectorielles, mais nous aurions pu aussi changer leur taille, le type de lignes, ou la forme des symboles (si la géométrie des données étaient de type point).

La fonction `scale_color_manual` permet de spécifier nos propres couleurs, sans quoi ce seront les couleurs par défaut qui seront utilisées^[Pour plus d'information sur la fonction `scale_colour_manual`, consultez le chapitre [Create your own discrete scale](https://ggplot2.tidyverse.org/reference/scale_manual.html) [@Wickham_ggplot2_2016]].

Finalement, la fonction `labs` permet d'assigner un titre à la légende, sans quoi c'est le nom de la variable, telle que nous l'avons définie dans `R` qui sera affichée, ici, `TYPE_VOIE`.

Nous pouvons aussi demander à `ggplot` de représenter les types de voie cyclable en utilisant différentes tailles de trait. De la même façon que précédemment, nous créons un vecteur de six tailles.
```{r plot-voie6, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
tailles_voie<-c(1,1.2,1.5,1.7,2,2.2)
```

Puis représentatons les types de voie cyclable (Fig \@ref(fig:plot-voie7)).
```{r plot-voie7, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Types de voie cyclable sur l'île de Montréal (couleur et taille des traits)"}
ggplot()+
  geom_sf(data = pistes_cyclables,  aes(color = TYPE_VOIE, size = TYPE_VOIE))+
  scale_color_manual(values = couleurs_voie)+
  labs(color = 'Types de voie')+
  scale_size_manual(values = tailles_voie)+
  labs(size = 'Types de voie')+
  ggtitle("Pistes cyclables sur l'île de Montréal", subtitle = "Types de voie")+
  theme(legend.position = "bottom")

```
La légende tient compte à la fois de la couleur, et de la taille des traits. De plus, nous l'avons affichée au bas de la figure.

#### Visualiser plusieurs *shapefiles* {-}

Nous allons maintenant représenter les données vectorielles `limites terrestres`, `pistes_cyclables` et `accidents_velo` au sein d'une même figure. Il s'agit d'utiliser la fonction `geom_sf` pour chaque couche de données et de les combiner en utilisant le `+`.

```{r plot-all1, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Pistes cyclables et position des accidents routiers impliquant des bicyclettes sur l'île de Montréal"}
ggplot()+
  geom_sf(data = limites_terrestres, size = 1, color = "black", fill = "white")+
  geom_sf(data = pistes_cyclables, size = 1, color = "darkgreen")+
  geom_sf(data = accidents_velo, pch = 19, cex = 1.25, color = "red")+
  ggtitle("Pistes cyclables sur l'île de Montréal et Accidents routiers impliquant des vélos")
```

Nous pouvons créer une carte plus précise qui spécifie les types de voie cyclable et ajouter une légende.

```{r plot-all2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Types de voie cyclable et position des accidents routiers impliquant des bicyclettes sur l'île de Montréal."}
ggplot()+
  geom_sf(data = limites_terrestres, size = 1, color = "black", fill = "white")+
  geom_sf(data = pistes_cyclables, size = 1.5, aes(color = TYPE_VOIE),  show.legend = "line")+
  scale_color_manual(values = couleurs_voie,name = "Types de voie")+
  geom_sf(data = accidents_velo, pch = 24, cex = 2, fill = "red", color = "black")+
  ggtitle("Types de voie cyclable et Accidents routiers impliquant des vélos")+
theme(
      #Caractéristiques de la figure elle-même
      panel.background = element_rect(fill = "black"), #le dessous de la carte
      plot.background = element_rect(fill = "black"),  #le contour de la carte
      panel.grid.major = element_blank(),              #retirer la grille cartésienne
      axis.ticks = element_blank(),                    #retirer les traits sur les axes
      axis.text.x = element_blank(),                   #retirer les traits les noms ou les numéros de ces traits
      axis.text.y = element_blank(),
      plot.title = element_text(colour = "white", size = 16, hjust = 0.5), #Centrer le titre de la carte
      #Caractéristiques de la légende
      legend.position = "top",                         #position de la légende
      legend.title = element_text(colour="blue", size = 11, face = "bold"), #titre de la légende
      legend.text = element_text(size = 10, face = "italic"),               #texte des éléments de la légende
      legend.background = element_rect(fill = "white", size = 1, linetype = "solid", colour = "red"), #rectangle autour de la légende
      legend.key = element_rect(fill = "white")        #couleur blanche sous les éléments de la légende
)

```
La fonction `theme()` permet d'ajuster l'apparence de la carte (couleur du fond, couleur, taille et position du titre, format de la légende, etc.). Le chapitre [Modify components of theme](https://ggplot2.tidyverse.org/reference/theme.html) [@Wickham_ggplot2_2016] énumère l'ensemble des paramètres pouvant être modifiés pour changer l'apparence d'une carte.


### Reprojection de données vectorielles sous R
Dans cette section vous apprendrez à manipuler le système de coordonnées de référence de données vectorielles. Nous avons vu en début de leçon que les données utilisées sont dans la projection de Mercator transverse (`tmerc`) et utilisent le Système de référence géodésique nord-américan de 1983 (`NAD83`). Par exemple, pour connaître le SCR des données `limites_terrestres`, nous avions fait:

```{r proj-terre2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_crs(limites_terrestres)
```

Nous allons maintenant transformer le SCR vers la projection de Robinson (`robin`) et le Système géodésique mondial de 1984 (`WGS84`). Pour se faire nous utilisons la fonction `st_transform` de la librarie `st`.
```{r reproj-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
limites_terrestres_rob <- st_transform(limites_terrestres,
    CRS("+proj=robin +datum=WGS84"))
```

Comparons les données transformées avec les données initiales. Pour se faire, nous voulons représenter les deux cartes une au-dessous de l'autre. La librarie `ggpubr` permet de créer facilement des figures avec des panneaux multiples. Installez la librarie si ce n'est pas déjà fait, et chargez-là dans votre session de travail.
```{r load-ggpubr, results='hide', eval = FALSE, message = FALSE,  warning = FALSE}
library(ggpubr)
```

```{r plot-terre2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Limites terrestres de l'île de Montréal selon les projections Mercartor (A) et Robinson (B)"}
carte1<-ggplot()+
  geom_sf(data = limites_terrestres, size = 1, color = "black", fill = "white") +
  ggtitle("Projection Mercator")
carte2<-ggplot()+
  geom_sf(data = limites_terrestres_rob, size = 1, color = "black", fill = "yellow") +
  ggtitle("Projection Robinson")
figure <- ggarrange(carte1, carte2, labels = c("A","B"),ncol = 1, nrow = 2)
figure
```

Finalement, pour sauvegarder des données vectorielles, nous utilisons la fonction `st_write` de la librarie `st`, de la même façon que nous avons utilisé la fonction `st_read` en début de leçon. Par exemple, sauvons les données `limites_terrestres_rob` que nous venons de créer.

```{r save-terre2, echo = FALSE,  warning = FALSE, message = FALSE, eval = FALSE}
nom_du_fichier<- paste(module, "/Montreal_Velo/terre/terre_rob_shp.shp", sep = "")
limites_terrestres <- st_write(limites_terrestres_rob,nom_du_fichier)
```

```{r fake-terre2, echo = TRUE,  warning = FALSE, message = FALSE, eval = FALSE}
chemin<-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier<- paste(chemin, "Montreal_Velo/terre/terre_rob_shp.shp", sep = "")
st_read(limites_terrestres_rob,nom_du_fichier)
```

### Lire une géodatabase et explorer ses couches

Dans cette section, nous allons explorer les données vectorielles d'une géodatabase du Ministère de l'Éducation et de l'Enseignement supérieur du Québec (MEES).


#### Importer les données {-}

Téléchargez les [données du MEES](https://github.com/sci1031/sci1031/tree/master/Module4/data/Donnees_Ouvertes_MEES.gbd.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Donnees` pour ce module, et dézippez-le. Le dossier Donnees_Ouvertes_MEES.gdb est la geodatabase contenant de multiples fichiers de formats différents.

#### Lire les données {-}

Dans la section portant sur le [format des données vectorielles](##### Format de données vectorielles) du [Module 2](#base), nous avons expliqué qu'une géodatabase est une façon de rassembler et d’organiser des données propres à un sujet dans une unique base de données.

La géodatabase Donnees_Ouvertes_MEES.gdb que vous venez de télécharger contient plusieurs couches de données vectorielles (*layers*) sur les établissements d'enseignement au Québec.

Pour lire et explorer une géodatabase, on continue à utiliser la libraries `sf`. Chaque couche peut être lue individuellement en utilisant la fonction `st_read()`: `st_read("nom_de_la_geodatabase.gdb", layer = "nom_de_la_couche")`. Il est donc nécessaire de connaître d'abord les noms donnés aux couches composants la géodatabase - information qui nous est, pour l'instant, inconnue.

Pour connaître les couches d'une géodatabase, nous utilisons la fonction `st_layers()`

```{r fake-mees-layers, eval = FALSE}
chemin<-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier <- paste(chemin, "Donnees_Ouvertes_MEES.gdb", sep = "")
couches_mees <- st_layers(nom_du_fichier)
couches_mees
```

```{r mees-layers, eval = TRUE, echo = FALSE}
couches_mees <- st_layers("Module4/data/Donnees_Ouvertes_MEES.gdb")
couches_mees
```

Nous observons que la géodatabase contient 18 couches différentes. Nous pouvons connaître le nom donné à chaque couche (`layer_name`), leur géométrie (`geometry_type`), le nombre d'objets vectoriels qu'elles contiennent (`features`), et le nombre d'attributs qu'elles décrivent (`fields`).

Les couches dont le nom commence par `CS_` contiennent des données vectorielles relatives aux centres de services scolaires^[Les centres de services scolaires (qui remplacent les commissions scolaires depuis 2020) ont pour rôle d'épauler les établissements d'enseignement situés sur leur territoire. Pour plus d'informations, consultez le site web du [MEES]^(https://www.quebec.ca/education/prescolaire-primaire-et-secondaire/gouvernance-scolaire/#c42437)]. Puisque chacun de ces centres couvre un territoire qui leur est propre, ces données sont des multi-polygones.

Les couches dont le nom commence par `PPS_` et `ES_` contiennent des données vectorielles relatives aux établissements d'enseignement primaire, secondaire et supérieure. Puisque chacun de ces établissements est identifié par une paire de coordonnées, ces données sont des points. 

Lisons les données vectorielles de la couche `PPS_Public_Ecole` en utilisant la fonction `st_read()`. 
```{r fake_ecoles_pub, eval = FALSE}
chemin<-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier <- paste(chemin, "Donnees_Ouvertes_MEES.gdb", sep = "")
ecoles_pub <- st_read(nom_du_fichier, layer = "PPS_Public_Ecole")
```

```{r ecoles_pub, eval = TRUE, echo = FALSE}
ecoles_pub <- st_read("Module4/data/Donnees_Ouvertes_MEES.gdb", layer = "PPS_Public_Ecole")
```
Cette couche donne la localisation des 5202 écoles primaires et secondaires publiques de la province ainsi que 28 autres attributs associés à ces établissements. 

Notez le système de coordonnées de référence: le datum WGS84 et la projection Pseudo-Mercator (ou Mercator Web) sont utilisés.

Notez aussi que cette couche de la géodatabase possède la même structure que celle d'un *shapefile*.

Nous pouvons visualiser la position des écoles publiques du Québec en utilisant la librarie `mapview`.
```{r plot-ecoles-pub, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Les écoles publiques du Québec"}
mapview(ecoles_pub)
```
Nous remarquons qu'il est difficile de visualiser la position des écoles dans la région Sud du Québec car il y a énormément de points.

#### Explorer les attributs d'une couche {-}

Pour explorer les attributs associés à la couche `ecoles_pub`, commençons d'abord par utiliser la fonction `names` qui retourne le nom associé à chaque attribut de la couche.


```{r names-ecoles-pub, eval = TRUE, echo = TRUE}
names(ecoles_pub)
```

Notre première réaction à la lecture de ces noms est qu'ils ne sont pas tous intuitifs!
Examinons les quatre attributs suivants: "NOM_OFFCL_ORGNS", "NOM_MUNCP_GDUNO_IMM", "TYPE_CS", et "SHAPE".

L'attribut "NOM_OFFCL_ORGNS" correspond au nom de chaque école publique. On peut lire les premières entrées de cette liste de noms en utilisant la fonction `head`:
```{r head-noms-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$NOM_OFFCL_ORGNS)
```
La fonction `head` indique aussi le nombre de `levels`, c'est-à-dire le nombre de valeurs différentes que peut prendre l'attribut. Dans le cas présent, chaque école possède un nom unique. Il y a donc autant de valeurs d'attribut qu'il y a d'écoles.

L'attribut "NOM_MUNCP_GDUNO_IMM" correspond au nom de la municipalité dans laquelle se trouve une école publique. Pour avoir un aperçu des valeurs données, on utilise encore la fonction `head`:
```{r head-villes-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$NOM_MUNCP_GDUNO_IMM)
```

L'attribut "TYPE_CS" identifie les écoles selon leur appartenance à une commision scolaire francophone, anglophone ou à statut linguistique particulier. 

```{r head-type-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$TYPE_CS)
```

Dans ce cas, on remarque qu'il y a trois niveaux ("levels") possibles: Anglo, Franco, et Statut. Il est aussi possible d'obtenir cette information en utilisant la fonction `levels`:
```{r levels-type-ecoles-pub, eval = TRUE, echo = TRUE}
levels(ecoles_pub$TYPE_CS)
```

Finalement, l'attribut "SHAPE" donne la position géographique de chaque école publique et les métadonnées spatiales associées à cette couche:
information en utilisant la fonction `levels`:
```{r head-shape-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$SHAPE)
```

#### Sélection d'un sous-ensemble de données 
Pour simplifier la visualisation de cette couche, nous allons nous concentrer sur les écoles de la municipalité de Montréal.
Pour ce faire, nous créons un nouveau *shapefile* en sélectionnant les données propres à la municipalité de Montréal:
```{r ecoles-pub-Mtl, eval = TRUE, echo = TRUE}
ecoles_pub_Mtl<- ecoles_pub[ecoles_pub$NOM_MUNCP_GDUNO_IMM == "Montréal",]
```
Interprétons cette ligne de commande: elle utilise l'opérateur logique `==` pour sélectionner les écoles publiques de la municipalité de Montréal, ainsi que tous les autres attributs au sein de la couche `ecoles_pub`.

Visualisons maintenant ce nouveau *shapefile* en utilisant la fonction `mapview`.
```{r plot-ecoles-pub-mtl, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Les écoles publiques de la ville de Montréal"}
map_pub_mtl<-mapview(ecoles_pub_Mtl, cex = 2)
map_pub_mtl
```

Ici, nous avons utilisé l'argument `cex` pour diminuer la taille des points sur la carte (la taille par défaut est 6).
En cliquant sur l'un ou l'autre des points vous obtiendrez l'ensemble des attributs propres à l'école sélectionnée.

#### Visualisation de plusieurs couches d'une géodatabse
Nous voulons visualiser d'autres types d'établissement d'enseignement donnés dans la géodatabase du Ministère de l'Éducation et de l'Enseignement supérieur du Québec. Choisissons les écoles privées, les établissements de niveau collégial (e.g. CÉGEP) et les universités. Pour se faire nous utilisons encore la fonction `st_read` en spécifiant le nom de la couche (`layer`) désirée.

```{r fake_autres_institutions, eval = FALSE}
chemin<-"D:/votrechemin/SCI1031/Module4/Donnees/"
nom_du_fichier <- paste(chemin, "Donnees_Ouvertes_MEES.gdb", sep = "")
ecoles_priv <- st_read(nom_du_fichier, layer = "PPS_Prive_Etablissement")
college<- st_read(nom_du_fichier, layer = "ES_Collegial")
univ <- st_read(nom_du_fichier, layer = "ES_Universitaire")
```

```{r autres-institutions, eval = TRUE, echo = FALSE, message = FALSE,}
ecoles_priv <- st_read("Module4/data/Donnees_Ouvertes_MEES.gdb", layer = "PPS_Prive_Etablissement")
college<- st_read("Module4/data/Donnees_Ouvertes_MEES.gdb", layer = "ES_Collegial")
univ <- st_read("Module4/data/Donnees_Ouvertes_MEES.gdb", layer = "ES_Universitaire")
```


Toujours dans le but de simplifier la visualisation, sélectionnons au sein des couches `ecoles_priv`, `college` et `univ` les établissements situés à Montréal. Attention, pour ces couches le nom de l'attribut associé à la municipalié où se situe les établissements listés est "NOM_MUNCP" et non "NOM_MUNCP_GDUNO_IMM".

```{r autres-institutions-Mtl, eval = TRUE, echo = TRUE}
ecoles_priv_Mtl <- ecoles_priv[ecoles_priv$NOM_MUNCP == "Montréal",] 
college_Mtl<-college[college$NOM_MUNCP == "Montréal",]
univ_Mtl<-univ[univ$NOM_MUNCP == "Montréal",]
```

Nous pouvons visualiser chacun de ces nouveaux *shapefile* individuellement en utilisant la fonction `mapview`, mais plus intéressant encore est de les visualiser ensemble au sein d'une même carte. Pour se faire nous créons d'abord des cartes individuelles.

```{r plot-ecoles-each-mtl, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
map_priv_mtl<-mapview(ecoles_priv_Mtl, color = "red", col.regions = "red", cex = 2)
map_college_mtl<-mapview(college_Mtl, color = "green", col.regions = "green", cex = 4)
map_univ_mtl<-mapview(univ_Mtl, color = "orange", col.regions = "orange", cex = 6)
```

Remarquez que nous utilisons différentes tailles de points et différentes couleurs pour bien différencier le type d'institution dans la carte qui les combinera. La couleur du contour du point est donnée par l'argument `color` et celle de l'intérieur du point par l'argument `col.regions`. Nous combinons toutes les couches par une simple addition des cartes individuelles
```{r plot-ecoles-all-mtl, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Institutions d'enseignement à Montréal"}
map_pub_mtl+map_priv_mtl+map_college_mtl+map_univ_mtl
```
Dans le menu dans le coin supérieur gauche de la carte, remarquez que vous pouvez sélectionner/désélectionner chaque couche selon l'information que vous désirez explorer.

Il serait intéressant de créer une nouvelle géodatabase pour sauvegarder les quatre nouveaux *shapefiles* des institutions d'enseignement à Montréal au sein d'une même structure. Malheureusement `R` peut seulement lire des géodatabases mais ne peut pas sauvegarder ce format qui est propriétaire de ESRI. Ainsi, il faudrait utiliser la fonction `st_write` pour sauvegarder chacun des *shapefiles* individuellement. 

Nouvelle visualisation
* peut sauver chaque sous-ensemble sous forme de shapefile, mais ne peut pas combiner sous forme de geodatabase.


## Exercice {#ex_vec}




